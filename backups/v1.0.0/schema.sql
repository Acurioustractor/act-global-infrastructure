

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE SCHEMA IF NOT EXISTS "drizzle";


ALTER SCHEMA "drizzle" OWNER TO "postgres";


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "fuzzystrmatch" WITH SCHEMA "public";






CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pg_trgm" WITH SCHEMA "public";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "vector" WITH SCHEMA "public";






CREATE TYPE "public"."analysis_job_status_enum" AS ENUM (
    'queued',
    'processing',
    'completed',
    'failed'
);


ALTER TYPE "public"."analysis_job_status_enum" OWNER TO "postgres";


CREATE TYPE "public"."business_category" AS ENUM (
    'markets',
    'arts',
    'accommodation',
    'services',
    'food',
    'wellness',
    'retail',
    'other'
);


ALTER TYPE "public"."business_category" OWNER TO "postgres";


CREATE TYPE "public"."business_status" AS ENUM (
    'pending',
    'approved',
    'rejected'
);


ALTER TYPE "public"."business_status" OWNER TO "postgres";


CREATE TYPE "public"."connection_strength_enum" AS ENUM (
    'weak',
    'moderate',
    'strong',
    'very_strong',
    'foundational'
);


ALTER TYPE "public"."connection_strength_enum" OWNER TO "postgres";


CREATE TYPE "public"."connection_type_enum" AS ENUM (
    'family',
    'professional',
    'community',
    'organizational',
    'cultural',
    'educational',
    'mentorship',
    'collaboration',
    'service',
    'advocacy'
);


ALTER TYPE "public"."connection_type_enum" OWNER TO "postgres";


CREATE TYPE "public"."consent_type_enum" AS ENUM (
    'general_participation',
    'ai_analysis',
    'quote_sharing',
    'story_sharing',
    'image_use',
    'contact_permission',
    'research_participation',
    'platform_features'
);


ALTER TYPE "public"."consent_type_enum" OWNER TO "postgres";


CREATE TYPE "public"."event_category" AS ENUM (
    'market',
    'community',
    'arts',
    'workshop',
    'music'
);


ALTER TYPE "public"."event_category" OWNER TO "postgres";


CREATE TYPE "public"."event_status" AS ENUM (
    'pending',
    'approved',
    'rejected'
);


ALTER TYPE "public"."event_status" OWNER TO "postgres";


CREATE TYPE "public"."evidence_strength" AS ENUM (
    'rigorous_rct',
    'quasi_experimental',
    'longitudinal_study',
    'evaluation_report',
    'promising_practice',
    'emerging'
);


ALTER TYPE "public"."evidence_strength" OWNER TO "postgres";


CREATE TYPE "public"."evidence_strength_enum" AS ENUM (
    'weak',
    'moderate',
    'strong',
    'very_strong',
    'exceptional'
);


ALTER TYPE "public"."evidence_strength_enum" OWNER TO "postgres";


CREATE TYPE "public"."global_region" AS ENUM (
    'north_america',
    'europe',
    'asia_pacific',
    'africa',
    'latin_america',
    'middle_east',
    'australasia'
);


ALTER TYPE "public"."global_region" OWNER TO "postgres";


CREATE TYPE "public"."impact_scope_enum" AS ENUM (
    'individual',
    'family',
    'local_community',
    'regional',
    'national',
    'international',
    'cultural_group',
    'professional_network',
    'online_community'
);


ALTER TYPE "public"."impact_scope_enum" OWNER TO "postgres";


CREATE TYPE "public"."impact_type_enum" AS ENUM (
    'personal_growth',
    'community_development',
    'social_change',
    'economic_impact',
    'cultural_preservation',
    'education_advancement',
    'health_improvement',
    'environmental_benefit',
    'innovation_creation',
    'policy_influence',
    'relationship_building',
    'knowledge_transfer'
);


ALTER TYPE "public"."impact_type_enum" OWNER TO "postgres";


CREATE TYPE "public"."proficiency_level_enum" AS ENUM (
    'beginner',
    'developing',
    'competent',
    'proficient',
    'expert',
    'master'
);


ALTER TYPE "public"."proficiency_level_enum" OWNER TO "postgres";


CREATE TYPE "public"."program_type" AS ENUM (
    'custodial_reform',
    'diversion',
    'restorative_justice',
    'family_therapy',
    'community_based',
    'education_vocational',
    'mentoring',
    'prevention',
    'reentry_support',
    'policy_initiative',
    'traditional_practice'
);


ALTER TYPE "public"."program_type" OWNER TO "postgres";


CREATE TYPE "public"."research_category" AS ENUM (
    'trauma-informed',
    'indigenous-diversion',
    'family-engagement',
    'restorative-justice',
    'youth-rights',
    'recidivism',
    'mental-health'
);


ALTER TYPE "public"."research_category" OWNER TO "postgres";


CREATE TYPE "public"."research_jurisdiction" AS ENUM (
    'Australia',
    'Queensland',
    'New Zealand',
    'Scotland',
    'International',
    'Nordic'
);


ALTER TYPE "public"."research_jurisdiction" OWNER TO "postgres";


CREATE TYPE "public"."research_type" AS ENUM (
    'research-paper',
    'systematic-review',
    'meta-analysis',
    'policy-brief',
    'case-study',
    'video',
    'report'
);


ALTER TYPE "public"."research_type" OWNER TO "postgres";


CREATE TYPE "public"."sharing_consent_enum" AS ENUM (
    'none',
    'anonymous_only',
    'attributed_sharing',
    'full_sharing',
    'community_only'
);


ALTER TYPE "public"."sharing_consent_enum" OWNER TO "postgres";


CREATE TYPE "public"."skill_category_enum" AS ENUM (
    'technical',
    'creative',
    'interpersonal',
    'leadership',
    'analytical',
    'cultural',
    'traditional',
    'entrepreneurial',
    'educational',
    'healing',
    'community_building',
    'innovation',
    'communication',
    'problem_solving'
);


ALTER TYPE "public"."skill_category_enum" OWNER TO "postgres";


CREATE TYPE "public"."user_role" AS ENUM (
    'user',
    'admin'
);


ALTER TYPE "public"."user_role" OWNER TO "postgres";


CREATE TYPE "public"."wisdom_type_enum" AS ENUM (
    'life_lesson',
    'practical_advice',
    'philosophical_insight',
    'cultural_knowledge',
    'professional_guidance',
    'personal_reflection',
    'community_wisdom',
    'traditional_teaching',
    'innovation_insight'
);


ALTER TYPE "public"."wisdom_type_enum" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_new_storyteller"("p_email" "text", "p_full_name" "text", "p_community" "text" DEFAULT NULL::"text", "p_bio" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_user_id UUID;
BEGIN
    INSERT INTO users (
        email, 
        full_name, 
        community_affiliation, 
        bio, 
        role,
        created_at
    ) VALUES (
        p_email,
        p_full_name,
        p_community,
        p_bio,
        'storyteller',
        NOW()
    ) RETURNING id INTO v_user_id;
    
    RETURN v_user_id;
END;
$$;


ALTER FUNCTION "public"."add_new_storyteller"("p_email" "text", "p_full_name" "text", "p_community" "text", "p_bio" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."analyze_contact_strategic_value"() RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
        DECLARE
          rec RECORD;
          updated_count INTEGER := 0;
          score DECIMAL(3,2);
          tags TEXT[];
          strategic_level TEXT;
        BEGIN
          FOR rec IN SELECT id, current_position, current_company FROM linkedin_contacts WHERE last_analyzed_at IS NULL OR last_analyzed_at < now() - INTERVAL '1 week'
          LOOP
            score := 0.00;
            tags := ARRAY[]::TEXT[];
            strategic_level := 'low';
            
            IF rec.current_position ~* '(ceo|chief executive|director|founder|president|secretary)' THEN
              score := score + 0.30;
              tags := array_append(tags, 'leadership');
            END IF;
            
            IF rec.current_position ~* '(government|ministry|department|council|authority)' THEN
              score := score + 0.25;
              tags := array_append(tags, 'government');
            END IF;
            
            IF rec.current_position ~* '(foundation|charity|nonprofit|ngo)' THEN
              score := score + 0.20;  
              tags := array_append(tags, 'social_impact');
            END IF;
            
            IF rec.current_company ~* '(government|ministry|department|council|authority)' THEN
              score := score + 0.20;
              tags := array_append(tags, 'government');
            END IF;
            
            IF rec.current_company ~* '(foundation|charity|nonprofit|ngo|social)' THEN
              score := score + 0.15;
              tags := array_append(tags, 'social_impact');
            END IF;
            
            IF rec.current_company ~* '(indigenous|aboriginal)' THEN
              score := score + 0.25;
              tags := array_append(tags, 'indigenous');
            END IF;
            
            IF rec.current_company ~* '(youth|housing|health|education|settlement)' THEN
              score := score + 0.15;
              tags := array_append(tags, 'community_services');
            END IF;
            
            IF rec.current_company ~* '(funding|grant|finance|investment|development)' THEN
              score := score + 0.20;
              tags := array_append(tags, 'funding');
            END IF;
            
            IF score >= 0.70 THEN strategic_level := 'high';
            ELSIF score >= 0.40 THEN strategic_level := 'medium';
            END IF;
            
            UPDATE linkedin_contacts SET
              relationship_score = LEAST(score, 1.00),
              strategic_value = strategic_level,
              alignment_tags = tags,
              last_analyzed_at = now()
            WHERE id = rec.id;
            
            updated_count := updated_count + 1;
          END LOOP;
          
          RETURN updated_count;
        END;
        $$;


ALTER FUNCTION "public"."analyze_contact_strategic_value"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."approve_proposal"("proposal_id" "uuid", "reviewer" "text", "notes" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_proposal agent_proposals%ROWTYPE;
BEGIN
  -- Get the proposal
  SELECT * INTO v_proposal FROM agent_proposals WHERE id = proposal_id;

  IF v_proposal.status != 'pending' THEN
    RAISE EXCEPTION 'Proposal is not pending (status: %)', v_proposal.status;
  END IF;

  -- Update to approved
  UPDATE agent_proposals SET
    status = 'approved',
    reviewed_by = reviewer,
    reviewed_at = NOW(),
    review_notes = notes,
    updated_at = NOW()
  WHERE id = proposal_id;

  RETURN proposal_id;
END;
$$;


ALTER FUNCTION "public"."approve_proposal"("proposal_id" "uuid", "reviewer" "text", "notes" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."assign_engagement_tier"("person_uuid" "uuid") RETURNS "text"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  tier TEXT := 'low';
  person_record person_identity_map;
  scores_record contact_intelligence_scores;
  recent_interactions INTEGER;
  project_connections INTEGER;
BEGIN
  SELECT * INTO person_record FROM person_identity_map WHERE person_id = person_uuid;
  SELECT * INTO scores_record FROM contact_intelligence_scores WHERE person_id = person_uuid;

  SELECT COUNT(*) INTO recent_interactions
  FROM contact_interactions
  WHERE person_id = person_uuid
    AND interaction_date > NOW() - INTERVAL '6 months';

  SELECT COUNT(*) INTO project_connections
  FROM linkedin_project_connections lpc
  JOIN linkedin_contacts lc ON lpc.contact_id = lc.id
  WHERE lc.person_id = person_uuid;

  -- Tier 1: Critical
  IF (
    (scores_record.composite_score >= 80) OR
    (scores_record.influence_score >= 90) OR
    (scores_record.strategic_value_score >= 85) OR
    (recent_interactions >= 10)
  ) THEN
    tier := 'critical';

  -- Tier 2: High
  ELSIF (
    (scores_record.composite_score >= 70) OR
    (recent_interactions >= 5) OR
    (project_connections >= 3)
  ) THEN
    tier := 'high';

  -- Tier 3: Medium
  ELSIF (
    (scores_record.composite_score >= 40) OR
    (recent_interactions >= 1) OR
    (project_connections >= 1)
  ) THEN
    tier := 'medium';

  ELSE
    tier := 'low';
  END IF;

  UPDATE person_identity_map
  SET engagement_priority = tier, updated_at = NOW()
  WHERE person_id = person_uuid;

  RETURN tier;
END;
$$;


ALTER FUNCTION "public"."assign_engagement_tier"("person_uuid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."assign_task_to_agent"("p_task_id" "uuid", "p_agent_id" "text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Update task
  UPDATE agent_task_queue
  SET assigned_agent = p_agent_id,
      status = 'assigned',
      updated_at = NOW()
  WHERE id = p_task_id;

  -- Update agent
  UPDATE agents
  SET current_task_id = p_task_id,
      last_heartbeat = NOW()
  WHERE id = p_agent_id;
END;
$$;


ALTER FUNCTION "public"."assign_task_to_agent"("p_task_id" "uuid", "p_agent_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auto_approve_high_confidence"("confidence_threshold" double precision DEFAULT 0.90, "dry_run" boolean DEFAULT false) RETURNS TABLE("action" "text", "queue_item_id" "uuid", "title" "text", "confidence" double precision, "suggested_type" "text")
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  item_record RECORD;
  new_page_id UUID;
  approval_count INTEGER := 0;
BEGIN
  -- Find high-confidence pending items
  FOR item_record IN
    SELECT
      q.id,
      q.source_id as notion_page_id,
      q.raw_title,
      q.extracted_knowledge as extracted_content,
      q.confidence_score::float,
      q.suggested_type,
      q.source_url,
      q.created_at
    FROM knowledge_extraction_queue q
    WHERE q.status = 'pending'
    AND q.confidence_score >= confidence_threshold
    AND q.confidence_score IS NOT NULL
    ORDER BY q.confidence_score DESC, q.created_at ASC
  LOOP
    IF dry_run THEN
      -- Dry run: just return what would be approved
      RETURN QUERY SELECT
        'would_approve'::TEXT,
        item_record.id,
        item_record.raw_title,
        item_record.confidence_score,
        item_record.suggested_type;
    ELSE
      -- Check if page already exists for this Notion page
      SELECT id INTO new_page_id
      FROM wiki_pages
      WHERE notion_page_id = item_record.notion_page_id;

      IF new_page_id IS NULL THEN
        -- Create new wiki page
        INSERT INTO wiki_pages (
          title,
          slug,
          content,
          page_type,
          status,
          notion_page_id,
          source_urls,
          auto_approved,
          approval_confidence,
          created_at,
          updated_at
        ) VALUES (
          item_record.raw_title,
          lower(regexp_replace(
            regexp_replace(item_record.raw_title, '[^a-zA-Z0-9\s-]', '', 'g'),
            '\s+', '-', 'g'
          )),
          item_record.extracted_content,
          item_record.suggested_type,
          'active',
          item_record.notion_page_id,
          ARRAY[item_record.source_url],
          true,
          item_record.confidence_score,
          item_record.created_at,
          NOW()
        )
        RETURNING id INTO new_page_id;

        -- Mark queue item as approved
        UPDATE knowledge_extraction_queue
        SET
          status = 'approved',
          approved_at = NOW(),
          wiki_page_id = new_page_id
        WHERE id = item_record.id;

        approval_count := approval_count + 1;

        RETURN QUERY SELECT
          'approved'::TEXT,
          item_record.id,
          item_record.raw_title,
          item_record.confidence_score,
          item_record.suggested_type;
      ELSE
        -- Page already exists, mark as duplicate
        UPDATE knowledge_extraction_queue
        SET
          status = 'rejected',
          rejected_at = NOW(),
          rejection_reason = 'Duplicate: Page already exists'
        WHERE id = item_record.id;

        RETURN QUERY SELECT
          'duplicate'::TEXT,
          item_record.id,
          item_record.raw_title,
          item_record.confidence_score,
          item_record.suggested_type;
      END IF;
    END IF;
  END LOOP;

  -- Log summary
  IF NOT dry_run AND approval_count > 0 THEN
    RAISE NOTICE 'âœ… Auto-approved % high-confidence items (>= % confidence)', approval_count, confidence_threshold;
  END IF;
END;
$$;


ALTER FUNCTION "public"."auto_approve_high_confidence"("confidence_threshold" double precision, "dry_run" boolean) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."auto_approve_high_confidence"("confidence_threshold" double precision, "dry_run" boolean) IS 'Auto-approves high-confidence knowledge extractions (default >= 90%)';



CREATE OR REPLACE FUNCTION "public"."auto_create_person_identity"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_person_id UUID;
BEGIN
  -- Only process if newly enriched and has email
  IF NEW.exa_enriched = TRUE
     AND NEW.email_address IS NOT NULL
     AND (OLD.exa_enriched IS NULL OR OLD.exa_enriched = FALSE)
     AND NEW.exa_confidence_score >= 0.5 THEN

    -- Check if person identity already exists
    SELECT person_id INTO v_person_id
    FROM person_identity_map
    WHERE email = NEW.email_address
    LIMIT 1;

    IF v_person_id IS NOT NULL THEN
      -- Update existing person identity
      UPDATE person_identity_map
      SET
        full_name = COALESCE(NEW.full_name, full_name),
        contact_data = JSONB_SET(
          COALESCE(contact_data, '{}'::jsonb),
          '{exa_enrichment}',
          JSON_BUILD_OBJECT(
            'bio', NEW.bio,
            'linkedin_url', NEW.linkedin_url,
            'current_company', NEW.current_company,
            'current_position', NEW.current_position,
            'location', NEW.location,
            'industries', NEW.industries,
            'confidence_score', NEW.exa_confidence_score,
            'enriched_at', NEW.exa_last_enriched
          )::jsonb
        ),
        updated_at = NOW()
      WHERE person_id = v_person_id;

      -- Link linkedin_contacts to person_identity_map
      NEW.person_id = v_person_id;

      RAISE NOTICE 'Updated existing person_identity_map: %', v_person_id;

    ELSE
      -- Create new person identity
      INSERT INTO person_identity_map (
        full_name,
        email,
        contact_data,
        data_source,
        discovered_via,
        created_at,
        updated_at
      ) VALUES (
        NEW.full_name,
        NEW.email_address,
        JSON_BUILD_OBJECT(
          'exa_enrichment', JSON_BUILD_OBJECT(
            'bio', NEW.bio,
            'linkedin_url', NEW.linkedin_url,
            'current_company', NEW.current_company,
            'current_position', NEW.current_position,
            'location', NEW.location,
            'industries', NEW.industries,
            'confidence_score', NEW.exa_confidence_score,
            'enriched_at', NEW.exa_last_enriched
          )
        )::jsonb,
        'exa_enrichment',
        'auto_trigger',
        NOW(),
        NOW()
      ) RETURNING person_id INTO v_person_id;

      -- Link linkedin_contacts to new person_identity_map
      NEW.person_id = v_person_id;

      RAISE NOTICE 'Created new person_identity_map: %', v_person_id;
    END IF;

  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_create_person_identity"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."auto_create_person_identity"() IS 'Automatically creates or updates person_identity_map when linkedin_contacts are enriched with Exa.
Triggered when exa_enriched changes to TRUE and confidence >= 0.5';



CREATE OR REPLACE FUNCTION "public"."backfill_all_community_programs_to_alma"() RETURNS TABLE("program_id" "uuid", "intervention_id" "uuid", "program_name" "text", "status" "text")
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_program RECORD;
  v_intervention_id UUID;
BEGIN
  FOR v_program IN
    SELECT id, name, alma_intervention_id
    FROM community_programs
    WHERE alma_intervention_id IS NULL -- Only backfill programs not yet linked
    ORDER BY is_featured DESC, created_at ASC -- Featured programs first
  LOOP
    BEGIN
      -- Backfill this program
      v_intervention_id := backfill_community_program_to_alma_intervention(v_program.id);

      -- Return success
      program_id := v_program.id;
      intervention_id := v_intervention_id;
      program_name := v_program.name;
      status := 'Success';
      RETURN NEXT;

    EXCEPTION WHEN OTHERS THEN
      -- Return error
      program_id := v_program.id;
      intervention_id := NULL;
      program_name := v_program.name;
      status := 'Error: ' || SQLERRM;
      RETURN NEXT;
    END;
  END LOOP;
END;
$$;


ALTER FUNCTION "public"."backfill_all_community_programs_to_alma"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."backfill_all_community_programs_to_alma"() IS 'Batch backfill all community programs to ALMA interventions';



CREATE OR REPLACE FUNCTION "public"."backfill_community_program_to_alma_intervention"("p_program_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_intervention_id UUID;
  v_program RECORD;
  v_intervention_type TEXT;
BEGIN
  -- Get the community program
  SELECT * INTO v_program
  FROM community_programs
  WHERE id = p_program_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Community program not found: %', p_program_id;
  END IF;

  -- Map approach to intervention type
  v_intervention_type := CASE v_program.approach
    WHEN 'Indigenous-led' THEN 'Community-Led'
    WHEN 'Community-based' THEN 'Community-Led'
    WHEN 'Grassroots' THEN 'Community-Led'
    WHEN 'Culturally-responsive' THEN 'Cultural Connection'
    ELSE 'Community-Led'
  END;

  -- Create ALMA intervention
  INSERT INTO alma_interventions (
    name,
    type,
    description,
    geography,
    evidence_level,
    cultural_authority,
    consent_level,
    permitted_uses,
    operating_organization,
    years_operating,
    review_status,
    linked_community_program_id,
    metadata
  ) VALUES (
    v_program.name,
    v_intervention_type,
    v_program.description || E'\n\nImpact: ' || v_program.impact_summary,
    ARRAY[v_program.state],
    CASE
      WHEN v_program.indigenous_knowledge THEN 'Indigenous-led (culturally grounded, community authority)'
      WHEN v_program.success_rate >= 80 THEN 'Effective (strong evaluation, positive outcomes)'
      WHEN v_program.success_rate >= 60 THEN 'Promising (community-endorsed, emerging evidence)'
      ELSE 'Promising (community-endorsed, emerging evidence)'
    END,
    CASE
      WHEN v_program.indigenous_knowledge THEN v_program.organization || ' (Indigenous-led)'
      ELSE v_program.organization
    END,
    'Community Controlled', -- Default to Community Controlled for existing programs
    ARRAY['Query (internal)', 'Publish (JusticeHub)']::TEXT[],
    v_program.organization,
    v_program.years_operating,
    'Approved', -- Mark as Approved since they're already published in JusticeHub
    v_program.id,
    jsonb_build_object(
      'source', 'backfill_from_community_programs',
      'original_approach', v_program.approach,
      'success_rate', v_program.success_rate,
      'participants_served', v_program.participants_served,
      'community_connection_score', v_program.community_connection_score,
      'is_featured', v_program.is_featured,
      'tags', v_program.tags
    )
  ) RETURNING id INTO v_intervention_id;

  -- Link back to community program
  UPDATE community_programs
  SET alma_intervention_id = v_intervention_id
  WHERE id = p_program_id;

  -- Create consent ledger entry
  INSERT INTO alma_consent_ledger (
    entity_type,
    entity_id,
    consent_level,
    permitted_uses,
    cultural_authority,
    contributors,
    attribution_text,
    consent_given_by,
    revenue_share_enabled
  ) VALUES (
    'intervention',
    v_intervention_id,
    'Community Controlled',
    ARRAY['Query (internal)', 'Publish (JusticeHub)']::TEXT[],
    CASE
      WHEN v_program.indigenous_knowledge THEN v_program.organization || ' (Indigenous-led)'
      ELSE v_program.organization
    END,
    jsonb_build_array(
      jsonb_build_object(
        'name', v_program.organization,
        'role', 'Program operator',
        'contact', COALESCE(v_program.contact_email, v_program.contact_phone)
      )
    ),
    'Data sourced from ' || v_program.organization || ' community program',
    'JusticeHub backfill migration',
    true -- Enable revenue sharing for community contributions
  );

  RETURN v_intervention_id;
END;
$$;


ALTER FUNCTION "public"."backfill_community_program_to_alma_intervention"("p_program_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."backfill_community_program_to_alma_intervention"("p_program_id" "uuid") IS 'Convert a community program to an ALMA intervention with consent tracking';



CREATE OR REPLACE FUNCTION "public"."calculate_api_cost"("p_provider" "text", "p_model" "text", "p_endpoint" "text", "p_input_tokens" integer, "p_output_tokens" integer) RETURNS numeric
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_pricing RECORD;
    v_cost DECIMAL(10,6);
BEGIN
    SELECT * INTO v_pricing
    FROM api_pricing
    WHERE provider = p_provider
      AND model = p_model
      AND endpoint = COALESCE(p_endpoint, 'default')
      AND effective_from <= CURRENT_DATE
      AND (effective_until IS NULL OR effective_until >= CURRENT_DATE)
    ORDER BY effective_from DESC
    LIMIT 1;

    IF NOT FOUND THEN
        -- Fallback: try default endpoint
        SELECT * INTO v_pricing
        FROM api_pricing
        WHERE provider = p_provider
          AND model = p_model
          AND endpoint = 'default'
        LIMIT 1;
    END IF;

    IF NOT FOUND THEN
        RETURN NULL;  -- Unknown pricing
    END IF;

    -- Calculate cost
    v_cost :=
        (COALESCE(p_input_tokens, 0) * v_pricing.input_price_per_1m / 1000000.0) +
        (COALESCE(p_output_tokens, 0) * v_pricing.output_price_per_1m / 1000000.0) +
        COALESCE(v_pricing.price_per_request, 0);

    RETURN v_cost;
END;
$$;


ALTER FUNCTION "public"."calculate_api_cost"("p_provider" "text", "p_model" "text", "p_endpoint" "text", "p_input_tokens" integer, "p_output_tokens" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_api_cost"("p_provider" "text", "p_model" "text", "p_endpoint" "text", "p_input_tokens" integer, "p_output_tokens" integer) IS 'Calculate USD cost for an API call based on current pricing';



CREATE OR REPLACE FUNCTION "public"."calculate_community_authority_signal"("intervention_id" "uuid") RETURNS double precision
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  signal FLOAT := 0.0;
  cultural_auth TEXT;
BEGIN
  SELECT cultural_authority INTO cultural_auth
  FROM alma_interventions
  WHERE id = intervention_id;

  IF cultural_auth IS NULL THEN
    RETURN 0.0;
  END IF;

  -- Aboriginal Community Controlled Organization = 1.0
  IF cultural_auth ILIKE '%Aboriginal Community Controlled%' OR
     cultural_auth ILIKE '%community-controlled%' THEN
    signal := 1.0;
  -- Indigenous-led with community partnership = 0.9
  ELSIF cultural_auth ILIKE '%Indigenous-led%' OR
        cultural_auth ILIKE '%Aboriginal-led%' THEN
    signal := 0.9;
  -- Co-designed with Aboriginal community = 0.7
  ELSIF cultural_auth ILIKE '%co-design%' OR
        cultural_auth ILIKE '%partnership%' THEN
    signal := 0.7;
  -- Culturally adapted mainstream = 0.5
  ELSIF cultural_auth ILIKE '%culturally adapted%' OR
        cultural_auth ILIKE '%Culturally Responsive%' THEN
    signal := 0.5;
  -- Consultation only = 0.3
  ELSIF cultural_auth ILIKE '%consultation%' THEN
    signal := 0.3;
  END IF;

  RETURN signal;
END;
$$;


ALTER FUNCTION "public"."calculate_community_authority_signal"("intervention_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_community_investment_score"("p_jurisdiction" "text") RETURNS TABLE("jurisdiction" "text", "community_percent" numeric, "detention_cost_ratio" numeric, "investment_score" numeric, "recommendation" "text")
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    f.jurisdiction,
    CASE WHEN f.total_expenditure > 0 THEN
      ROUND((f.community_expenditure / f.total_expenditure * 100)::numeric, 1)
    END as community_pct,
    CASE WHEN f.cost_per_day_community > 0 THEN
      ROUND((f.cost_per_day_detention / f.cost_per_day_community)::numeric, 1)
    END as cost_ratio,
    -- Score: Higher community % and lower recidivism = better
    ROUND(
      (COALESCE(f.community_expenditure / NULLIF(f.total_expenditure, 0), 0) * 50 +
       (1 - COALESCE(f.recidivism_rate / 100, 0.5)) * 50
      )::numeric, 1
    ) as score,
    CASE
      WHEN f.community_expenditure / NULLIF(f.total_expenditure, 0) < 0.35 THEN 'INCREASE community investment'
      WHEN f.recidivism_rate > 50 THEN 'EVALUATE program effectiveness'
      ELSE 'MAINTAIN current approach'
    END as rec
  FROM alma_funding_data f
  WHERE f.jurisdiction = p_jurisdiction
    OR p_jurisdiction IS NULL
  ORDER BY score DESC;
END;
$$;


ALTER FUNCTION "public"."calculate_community_investment_score"("p_jurisdiction" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_community_investment_score"("p_jurisdiction" "text") IS 'Calculates a score for community investment effectiveness';



CREATE OR REPLACE FUNCTION "public"."calculate_coverage_metrics"() RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Clear old metrics
  DELETE FROM alma_coverage_metrics WHERE calculated_at < NOW() - INTERVAL '1 day';

  -- Calculate jurisdiction coverage
  INSERT INTO alma_coverage_metrics (dimension_type, dimension_value, source_count, intervention_count, coverage_score)
  SELECT
    'jurisdiction',
    COALESCE(s.jurisdiction, 'Unknown'),
    COUNT(DISTINCT s.id),
    COALESCE(SUM(s.total_entities_extracted), 0),
    LEAST(100, COUNT(DISTINCT s.id) * 5 + COALESCE(SUM(s.total_entities_extracted), 0) * 0.5)
  FROM alma_source_registry s
  GROUP BY s.jurisdiction
  ON CONFLICT (dimension_type, dimension_value) DO UPDATE SET
    source_count = EXCLUDED.source_count,
    intervention_count = EXCLUDED.intervention_count,
    coverage_score = EXCLUDED.coverage_score,
    calculated_at = NOW();

  -- Calculate source type coverage
  INSERT INTO alma_coverage_metrics (dimension_type, dimension_value, source_count, intervention_count, coverage_score)
  SELECT
    'source_type',
    COALESCE(s.source_type, 'Unknown'),
    COUNT(DISTINCT s.id),
    COALESCE(SUM(s.total_entities_extracted), 0),
    LEAST(100, COUNT(DISTINCT s.id) * 5 + COALESCE(SUM(s.total_entities_extracted), 0) * 0.5)
  FROM alma_source_registry s
  GROUP BY s.source_type
  ON CONFLICT (dimension_type, dimension_value) DO UPDATE SET
    source_count = EXCLUDED.source_count,
    intervention_count = EXCLUDED.intervention_count,
    coverage_score = EXCLUDED.coverage_score,
    calculated_at = NOW();
END;
$$;


ALTER FUNCTION "public"."calculate_coverage_metrics"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_empowerment_score"("analysis_data" "jsonb") RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  score INTEGER := 50; -- Base score
  assets_count INTEGER;
  cultural_awareness INTEGER;
BEGIN
  -- Add points for community assets identified
  assets_count := (
    COALESCE(jsonb_array_length(analysis_data->'community_assets'->'strengths_mentioned'), 0) +
    COALESCE(jsonb_array_length(analysis_data->'community_assets'->'innovations_described'), 0) +
    COALESCE(jsonb_array_length(analysis_data->'community_assets'->'expertise_demonstrated'), 0) +
    COALESCE(jsonb_array_length(analysis_data->'community_assets'->'support_systems'), 0)
  );
  
  score := score + LEAST(assets_count * 5, 30); -- Max 30 points for assets
  
  -- Add points for cultural awareness
  cultural_awareness := COALESCE(jsonb_array_length(analysis_data->'cultural_considerations'->'protocols_noted'), 0);
  score := score + LEAST(cultural_awareness * 10, 20); -- Max 20 points for cultural awareness
  
  -- Ensure score is within bounds
  RETURN GREATEST(0, LEAST(100, score));
END;
$$;


ALTER FUNCTION "public"."calculate_empowerment_score"("analysis_data" "jsonb") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_empowerment_score"("analysis_data" "jsonb") IS 'Measures community empowerment vs extraction in AI analysis';



CREATE OR REPLACE FUNCTION "public"."calculate_engagement_score"("session_time" integer, "page_views" integer, "interactions" integer, "collaborations" integer) RETURNS numeric
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- Weighted engagement score calculation
    RETURN (
        (session_time * 0.3) + 
        (page_views * 0.2) + 
        (interactions * 0.3) + 
        (collaborations * 0.2)
    ) / 100.0; -- Normalize to 0-1 scale
END;
$$;


ALTER FUNCTION "public"."calculate_engagement_score"("session_time" integer, "page_views" integer, "interactions" integer, "collaborations" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_evidence_signal"("intervention_id" "uuid") RETURNS double precision
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  signal FLOAT := 0.0;
BEGIN
  SELECT
    CASE evidence_level
      WHEN 'Proven (RCT/quasi-experimental, replicated)' THEN 1.0
      WHEN 'Effective (strong evaluation, positive outcomes)' THEN 0.8
      WHEN 'Indigenous-led (culturally grounded, community authority)' THEN 0.7
      WHEN 'Promising (community-endorsed, emerging evidence)' THEN 0.5
      ELSE 0.3
    END INTO signal
  FROM alma_interventions
  WHERE id = intervention_id;

  RETURN COALESCE(signal, 0.3);
END;
$$;


ALTER FUNCTION "public"."calculate_evidence_signal"("intervention_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_funding_relevance"("opportunity_id" "uuid") RETURNS numeric
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  opp RECORD;
  score NUMERIC := 0;
BEGIN
  SELECT * INTO opp FROM alma_funding_opportunities WHERE id = opportunity_id;

  IF NOT FOUND THEN
    RETURN 0;
  END IF;

  -- Base score from category (0-40 points)
  IF opp.category IN ('youth_justice', 'indigenous_programs') THEN
    score := score + 40;
  ELSIF opp.category IN ('mental_health', 'family_services', 'community_development') THEN
    score := score + 30;
  ELSIF opp.category IN ('education', 'employment', 'housing') THEN
    score := score + 20;
  ELSE
    score := score + 10;
  END IF;

  -- Focus areas bonus (0-30 points)
  IF opp.focus_areas && ARRAY['youth', 'justice', 'indigenous', 'first_nations'] THEN
    score := score + 30;
  ELSIF opp.focus_areas && ARRAY['community', 'mental_health', 'rehabilitation'] THEN
    score := score + 20;
  ELSIF opp.focus_areas && ARRAY['education', 'employment', 'support'] THEN
    score := score + 10;
  END IF;

  -- Jurisdiction bonus (0-20 points) - National or NT/QLD prioritized
  IF opp.is_national OR 'National' = ANY(opp.jurisdictions) THEN
    score := score + 20;
  ELSIF opp.jurisdictions && ARRAY['NT', 'QLD', 'WA'] THEN
    score := score + 15;
  ELSIF array_length(opp.jurisdictions, 1) > 0 THEN
    score := score + 10;
  END IF;

  -- Amount bonus (0-10 points) - prefer larger grants
  IF opp.max_grant_amount >= 500000 THEN
    score := score + 10;
  ELSIF opp.max_grant_amount >= 100000 THEN
    score := score + 7;
  ELSIF opp.max_grant_amount >= 50000 THEN
    score := score + 5;
  ELSIF opp.max_grant_amount > 0 THEN
    score := score + 2;
  END IF;

  -- Normalize to 0-100
  RETURN LEAST(100, score);
END;
$$;


ALTER FUNCTION "public"."calculate_funding_relevance"("opportunity_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_funding_relevance"("opportunity_id" "uuid") IS 'Calculate youth justice relevance score (0-100) for funding opportunity';



CREATE OR REPLACE FUNCTION "public"."calculate_harm_risk_signal"("intervention_id" "uuid") RETURNS double precision
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  signal FLOAT := 1.0; -- Start high (low risk)
  risk_level TEXT;
  risks TEXT;
  int_type TEXT;
BEGIN
  SELECT harm_risk_level, risks, type INTO risk_level, risks, int_type
  FROM alma_interventions
  WHERE id = intervention_id;

  -- High harm risk = 0.0 (detention, incarceration)
  IF risk_level = 'High' OR 
     risks ILIKE '%detention%' OR 
     risks ILIKE '%incarceration%' OR
     int_type = 'Detention' THEN
    signal := 0.0;
  -- Medium harm risk = 0.5 (intensive supervision, tracking)
  ELSIF risk_level = 'Medium' OR 
        risks ILIKE '%surveillance%' OR
        risks ILIKE '%monitoring%' THEN
    signal := 0.5;
  -- Low harm risk = 1.0 (community-based, cultural programs)
  ELSIF risk_level = 'Low' OR
        int_type IN ('Community-Led', 'Cultural Connection', 'Diversion', 'Early Intervention') THEN
    signal := 1.0;
  END IF;

  RETURN signal;
END;
$$;


ALTER FUNCTION "public"."calculate_harm_risk_signal"("intervention_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_health_trend"("p_site_id" "uuid") RETURNS "text"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  recent_avg NUMERIC;
  older_avg NUMERIC;
BEGIN
  SELECT AVG(health_score) INTO recent_avg
  FROM (SELECT health_score FROM site_health_checks WHERE site_id = p_site_id ORDER BY checked_at DESC LIMIT 4) recent;
  SELECT AVG(health_score) INTO older_avg
  FROM (SELECT health_score FROM site_health_checks WHERE site_id = p_site_id ORDER BY checked_at DESC LIMIT 4 OFFSET 4) older;
  IF older_avg IS NULL THEN RETURN 'stable';
  ELSIF recent_avg > older_avg + 5 THEN RETURN 'up';
  ELSIF recent_avg < older_avg - 5 THEN RETURN 'down';
  ELSE RETURN 'stable';
  END IF;
END;
$$;


ALTER FUNCTION "public"."calculate_health_trend"("p_site_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_implementation_signal"("intervention_id" "uuid") RETURNS double precision
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  signal FLOAT := 0.5;
  impl_data JSONB;
  created DATE;
BEGIN
  SELECT metadata -> 'implementation', created_at::date INTO impl_data, created
  FROM alma_interventions
  WHERE id = intervention_id;

  IF impl_data IS NULL THEN
    -- If no implementation data, check if recent (within 2 years = likely active)
    IF created > CURRENT_DATE - INTERVAL '2 years' THEN
      signal := 0.7;
    END IF;
    RETURN signal;
  END IF;

  -- Currently running with stable funding = 1.0
  IF impl_data->>'status' = 'running' AND impl_data->>'funding' = 'stable' THEN
    signal := 1.0;
  -- Pilot with promising results = 0.7
  ELSIF impl_data->>'status' = 'pilot' THEN
    signal := 0.7;
  -- Design stage with community buy-in = 0.5
  ELSIF impl_data->>'status' = 'design' THEN
    signal := 0.5;
  -- Concept only = 0.3
  ELSIF impl_data->>'status' = 'concept' THEN
    signal := 0.3;
  END IF;

  RETURN signal;
END;
$$;


ALTER FUNCTION "public"."calculate_implementation_signal"("intervention_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_migration_priority"("sub_amount" numeric, "sub_metadata" "jsonb", "sub_confidence" numeric) RETURNS integer
    LANGUAGE "plpgsql" IMMUTABLE
    AS $_$
DECLARE
  amount_score NUMERIC := 0;
  recency_score NUMERIC := 0;
  confidence_score NUMERIC := 0;
  last_seen_date DATE;
  days_since_last_seen INT;
BEGIN
  -- Amount score (max 40 points) - Scale: $100 = max points
  amount_score := LEAST(40, (COALESCE(sub_amount, 0) / 100.0) * 40);

  -- Recency score (max 30 points) - More recent = higher priority
  last_seen_date := (sub_metadata->>'lastSeen')::DATE;
  IF last_seen_date IS NOT NULL THEN
    days_since_last_seen := CURRENT_DATE - last_seen_date;

    IF days_since_last_seen <= 7 THEN
      recency_score := 30;  -- Last week
    ELSIF days_since_last_seen <= 30 THEN
      recency_score := 20;  -- Last month
    ELSIF days_since_last_seen <= 90 THEN
      recency_score := 10;  -- Last quarter
    ELSE
      recency_score := 5;   -- Older than 3 months
    END IF;
  ELSE
    recency_score := 15;  -- No data, assume medium priority
  END IF;

  -- Confidence score (max 30 points)
  confidence_score := COALESCE(sub_confidence, 0) * 30;

  -- Total score (0-100)
  RETURN LEAST(100, ROUND(amount_score + recency_score + confidence_score));
END;
$_$;


ALTER FUNCTION "public"."calculate_migration_priority"("sub_amount" numeric, "sub_metadata" "jsonb", "sub_confidence" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_next_scrape"("p_update_frequency" "text", "p_priority_score" numeric) RETURNS timestamp with time zone
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  base_interval INTERVAL;
  priority_factor DECIMAL;
BEGIN
  -- Base interval from frequency
  base_interval := CASE p_update_frequency
    WHEN 'daily' THEN INTERVAL '1 day'
    WHEN 'weekly' THEN INTERVAL '7 days'
    WHEN 'monthly' THEN INTERVAL '30 days'
    WHEN 'quarterly' THEN INTERVAL '90 days'
    WHEN 'yearly' THEN INTERVAL '365 days'
    ELSE INTERVAL '30 days'
  END;

  -- Higher priority = shorter interval (multiply by 0.5 to 1.5)
  priority_factor := 1.5 - (COALESCE(p_priority_score, 5) / 10);

  RETURN NOW() + (base_interval * priority_factor);
END;
$$;


ALTER FUNCTION "public"."calculate_next_scrape"("p_update_frequency" "text", "p_priority_score" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_option_value_signal"("intervention_id" "uuid") RETURNS double precision
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  signal FLOAT := 0.5;
  metadata JSONB;
BEGIN
  SELECT metadata INTO metadata
  FROM alma_interventions
  WHERE id = intervention_id;

  IF metadata IS NULL THEN
    RETURN 0.5;
  END IF;

  -- High learning potential (innovative approach, fills gap) = 1.0
  IF metadata->>'innovation_level' = 'high' OR
     metadata->>'fills_critical_gap' = 'true' THEN
    signal := 1.0;
  -- Medium (builds on known approaches) = 0.6
  ELSIF metadata->>'innovation_level' = 'medium' THEN
    signal := 0.6;
  -- Low (well-established, little to learn) = 0.3
  ELSIF metadata->>'innovation_level' = 'low' THEN
    signal := 0.3;
  END IF;

  RETURN signal;
END;
$$;


ALTER FUNCTION "public"."calculate_option_value_signal"("intervention_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_portfolio_score"("int_id" "uuid") RETURNS TABLE("intervention_id" "uuid", "intervention_name" "text", "intervention_type" "text", "evidence_strength" double precision, "community_authority" double precision, "harm_risk" double precision, "implementation" double precision, "option_value" double precision, "composite_score" double precision, "recommendation" "text")
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    i.id,
    i.name,
    i.type,
    calculate_evidence_signal(i.id) as evidence,
    calculate_community_authority_signal(i.id) as authority,
    calculate_harm_risk_signal(i.id) as harm,
    calculate_implementation_signal(i.id) as impl,
    calculate_option_value_signal(i.id) as option_val,
    (calculate_evidence_signal(i.id) * 0.25 +
     calculate_community_authority_signal(i.id) * 0.30 +
     calculate_harm_risk_signal(i.id) * 0.20 +
     calculate_implementation_signal(i.id) * 0.15 +
     calculate_option_value_signal(i.id) * 0.10) as composite,
    CASE
      WHEN calculate_evidence_signal(i.id) > 0.7 AND
           calculate_community_authority_signal(i.id) > 0.7 AND
           calculate_harm_risk_signal(i.id) > 0.7 THEN
        'ðŸš€ Ready to Scale - High evidence + Community authority + Low harm'
      WHEN calculate_community_authority_signal(i.id) > 0.8 AND
           calculate_evidence_signal(i.id) < 0.5 THEN
        'â­ Promising but Unproven - Indigenous-led, needs evaluation support'
      WHEN calculate_evidence_signal(i.id) > 0.7 AND
           calculate_community_authority_signal(i.id) < 0.5 THEN
        'ðŸ’¡ Effective but Mainstream - Proven outcomes, needs community partnership'
      WHEN calculate_harm_risk_signal(i.id) < 0.3 THEN
        'âš ï¸  High Harm Risk - Detention/incarceration approach, redirect to community'
      ELSE
        'ðŸ“Š Needs More Data - Gather evidence and community authority'
    END as recommendation
  FROM alma_interventions i
  WHERE i.id = int_id;
END;
$$;


ALTER FUNCTION "public"."calculate_portfolio_score"("int_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_portfolio_signals"("p_intervention_id" "uuid") RETURNS TABLE("evidence_strength" numeric, "community_authority" numeric, "harm_risk" numeric, "implementation_capability" numeric, "option_value" numeric, "portfolio_score" numeric)
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_evidence_level TEXT;
  v_consent_level TEXT;
  v_cultural_authority TEXT;
  v_harm_risk_level TEXT;
  v_replication_readiness TEXT;
  v_years_operating INTEGER;
  v_evidence_count INTEGER;

  sig_evidence DECIMAL(5, 4) := 0.0;
  sig_authority DECIMAL(5, 4) := 0.0;
  sig_harm DECIMAL(5, 4) := 0.0;
  sig_capability DECIMAL(5, 4) := 0.0;
  sig_option DECIMAL(5, 4) := 0.0;
  total_score DECIMAL(5, 4);
BEGIN
  -- Get intervention data (FIXED: use p_intervention_id to avoid ambiguity)
  SELECT
    i.evidence_level,
    i.consent_level,
    i.cultural_authority,
    i.harm_risk_level,
    i.replication_readiness,
    i.years_operating,
    COUNT(ie.evidence_id)
  INTO
    v_evidence_level,
    v_consent_level,
    v_cultural_authority,
    v_harm_risk_level,
    v_replication_readiness,
    v_years_operating,
    v_evidence_count
  FROM alma_interventions i
  LEFT JOIN alma_intervention_evidence ie ON i.id = ie.intervention_id
  WHERE i.id = p_intervention_id
  GROUP BY i.id, i.evidence_level, i.consent_level, i.cultural_authority, i.harm_risk_level, i.replication_readiness, i.years_operating;

  -- Calculate evidence strength signal (0-1)
  sig_evidence := CASE v_evidence_level
    WHEN 'Proven (RCT/quasi-experimental, replicated)' THEN 1.0
    WHEN 'Effective (strong evaluation, positive outcomes)' THEN 0.8
    WHEN 'Indigenous-led (culturally grounded, community authority)' THEN 0.7
    WHEN 'Promising (community-endorsed, emerging evidence)' THEN 0.5
    WHEN 'Untested (theory/pilot stage)' THEN 0.2
    ELSE 0.3
  END;

  -- Boost by number of evidence records
  sig_evidence := LEAST(1.0, sig_evidence + (v_evidence_count * 0.05));

  -- Calculate community authority signal (0-1)
  -- Higher for Indigenous-led, community-controlled, culturally grounded
  sig_authority := CASE
    WHEN v_evidence_level = 'Indigenous-led (culturally grounded, community authority)' THEN 1.0
    WHEN v_consent_level = 'Community Controlled' AND v_cultural_authority IS NOT NULL THEN 0.8
    WHEN v_cultural_authority IS NOT NULL THEN 0.6
    ELSE 0.3
  END;

  -- Calculate harm risk signal (0-1, inverse - high risk = lower score)
  sig_harm := CASE v_harm_risk_level
    WHEN 'Low' THEN 1.0
    WHEN 'Medium' THEN 0.6
    WHEN 'High' THEN 0.2
    WHEN 'Requires cultural review' THEN 0.5
    ELSE 0.7
  END;

  -- Calculate implementation capability signal (0-1)
  sig_capability := CASE v_replication_readiness
    WHEN 'Ready (playbook available)' THEN 1.0
    WHEN 'Ready with support (requires adaptation guidance)' THEN 0.7
    WHEN 'Community authority required' THEN 0.6
    WHEN 'Not ready (needs more development)' THEN 0.3
    ELSE 0.5
  END;

  -- Boost by years operating
  IF v_years_operating IS NOT NULL AND v_years_operating > 0 THEN
    sig_capability := LEAST(1.0, sig_capability + (v_years_operating * 0.02));
  END IF;

  -- Calculate option value signal (0-1)
  -- Higher for promising but unproven (learning potential)
  sig_option := CASE v_evidence_level
    WHEN 'Untested (theory/pilot stage)' THEN 0.8
    WHEN 'Promising (community-endorsed, emerging evidence)' THEN 1.0
    WHEN 'Effective (strong evaluation, positive outcomes)' THEN 0.4
    WHEN 'Proven (RCT/quasi-experimental, replicated)' THEN 0.2
    ELSE 0.5
  END;

  -- Calculate weighted portfolio score
  -- Weights from ALMA Charter (prioritizes community authority)
  total_score := (
    (sig_evidence * 0.25) +       -- 25% Evidence Strength
    (sig_authority * 0.30) +      -- 30% Community Authority (highest weight)
    (sig_harm * 0.20) +           -- 20% Harm Risk
    (sig_capability * 0.15) +     -- 15% Implementation Capability
    (sig_option * 0.10)           -- 10% Option Value
  );

  -- Return signals
  RETURN QUERY SELECT sig_evidence, sig_authority, sig_harm, sig_capability, sig_option, total_score;
END;
$$;


ALTER FUNCTION "public"."calculate_portfolio_signals"("p_intervention_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_potential_savings"("p_young_people_diverted" integer, "p_detention_cost_per_day" numeric DEFAULT 3320, "p_community_cost_per_day" numeric DEFAULT 150, "p_avg_detention_days" integer DEFAULT 180) RETURNS TABLE("young_people_diverted" integer, "detention_cost_avoided" numeric, "community_program_cost" numeric, "net_savings" numeric, "savings_per_person" numeric, "generational_multiplier" numeric, "total_generational_impact" numeric)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    p_young_people_diverted,
    (p_detention_cost_per_day * p_avg_detention_days * p_young_people_diverted)::DECIMAL as det_cost,
    (p_community_cost_per_day * p_avg_detention_days * p_young_people_diverted)::DECIMAL as comm_cost,
    ((p_detention_cost_per_day - p_community_cost_per_day) * p_avg_detention_days * p_young_people_diverted)::DECIMAL as net,
    ((p_detention_cost_per_day - p_community_cost_per_day) * p_avg_detention_days)::DECIMAL as per_person,
    3.0::DECIMAL as gen_mult, -- Conservative multiplier for generational impact
    ((p_detention_cost_per_day - p_community_cost_per_day) * p_avg_detention_days * p_young_people_diverted * 3)::DECIMAL as total_gen;
END;
$$;


ALTER FUNCTION "public"."calculate_potential_savings"("p_young_people_diverted" integer, "p_detention_cost_per_day" numeric, "p_community_cost_per_day" numeric, "p_avg_detention_days" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_potential_savings"("p_young_people_diverted" integer, "p_detention_cost_per_day" numeric, "p_community_cost_per_day" numeric, "p_avg_detention_days" integer) IS 'Calculates potential savings from diverting young people from detention';



CREATE OR REPLACE FUNCTION "public"."calculate_project_sovereignty_score"("target_project_id" "uuid") RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  compliance_score INTEGER := 100;
  total_stories INTEGER;
  stories_with_consent INTEGER;
  stories_with_cultural_protocols INTEGER;
  active_storytellers INTEGER;
BEGIN
  -- Get project statistics
  SELECT COUNT(*) INTO total_stories 
  FROM stories WHERE project_id = target_project_id;
  
  SELECT COUNT(*) INTO stories_with_consent
  FROM stories 
  WHERE project_id = target_project_id 
  AND consent_settings != '{}';
  
  SELECT COUNT(*) INTO stories_with_cultural_protocols
  FROM stories 
  WHERE project_id = target_project_id 
  AND cultural_protocols != '{}';
  
  SELECT COUNT(DISTINCT storyteller_id) INTO active_storytellers
  FROM stories 
  WHERE project_id = target_project_id 
  AND submitted_at > NOW() - INTERVAL '30 days';
  
  -- Calculate compliance deductions
  IF total_stories > 0 THEN
    -- Deduct for stories without proper consent
    IF stories_with_consent::FLOAT / total_stories < 0.9 THEN
      compliance_score := compliance_score - 20;
    END IF;
    
    -- Deduct for stories without cultural protocol consideration
    IF stories_with_cultural_protocols::FLOAT / total_stories < 0.7 THEN
      compliance_score := compliance_score - 15;
    END IF;
  END IF;
  
  -- Deduct for inactive projects
  IF active_storytellers = 0 AND total_stories > 0 THEN
    compliance_score := compliance_score - 10;
  END IF;
  
  -- Update project compliance score
  UPDATE projects 
  SET sovereignty_compliance_score = compliance_score,
      last_compliance_check = NOW()
  WHERE id = target_project_id;
  
  RETURN compliance_score;
END;
$$;


ALTER FUNCTION "public"."calculate_project_sovereignty_score"("target_project_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_reading_time"("content_text" "text") RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  word_count INTEGER;
  words_per_minute INTEGER := 200;
BEGIN
  word_count := array_length(regexp_split_to_array(content_text, '\s+'), 1);
  RETURN GREATEST(1, CEIL(word_count::DECIMAL / words_per_minute));
END;
$$;


ALTER FUNCTION "public"."calculate_reading_time"("content_text" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_relationship_score"("contact_id" "uuid") RETURNS numeric
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  score DECIMAL := 0.5;
  contact_record RECORD;
  interaction_count INTEGER;
BEGIN
  SELECT * INTO contact_record FROM linkedin_contacts WHERE id = contact_id;
  SELECT COUNT(*) INTO interaction_count FROM linkedin_interactions WHERE linkedin_interactions.contact_id = contact_id;

  -- Base scoring
  IF contact_record.email_address IS NOT NULL THEN score := score + 0.1; END IF;
  IF contact_record.current_company IS NOT NULL THEN score := score + 0.05; END IF;
  IF contact_record.current_position IS NOT NULL THEN score := score + 0.05; END IF;

  -- Interaction scoring
  IF interaction_count > 10 THEN score := score + 0.3;
  ELSIF interaction_count > 5 THEN score := score + 0.2;
  ELSIF interaction_count > 0 THEN score := score + 0.1;
  END IF;

  -- Strategic value bonus
  IF contact_record.strategic_value = 'high' THEN score := score + 0.2;
  ELSIF contact_record.strategic_value = 'medium' THEN score := score + 0.1;
  END IF;

  RETURN LEAST(score, 1.0);
END;
$$;


ALTER FUNCTION "public"."calculate_relationship_score"("contact_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_relationship_temperature"("p_days_since_contact" integer, "p_total_touchpoints" integer, "p_inbound_count" integer, "p_outbound_count" integer) RETURNS integer
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
DECLARE
    v_recency_score INT;
    v_frequency_score INT;
    v_engagement_score INT;
    v_reciprocity_score INT;
    v_temperature INT;
BEGIN
    -- Recency score (35% weight) - based on days since contact
    v_recency_score := CASE
        WHEN p_days_since_contact IS NULL THEN 0
        WHEN p_days_since_contact <= 7 THEN 100
        WHEN p_days_since_contact <= 14 THEN 90
        WHEN p_days_since_contact <= 30 THEN 75
        WHEN p_days_since_contact <= 60 THEN 50
        WHEN p_days_since_contact <= 90 THEN 30
        WHEN p_days_since_contact <= 180 THEN 15
        ELSE 5
    END;
    
    -- Frequency score (25% weight) - based on total touchpoints
    v_frequency_score := CASE
        WHEN COALESCE(p_total_touchpoints, 0) >= 20 THEN 100
        WHEN p_total_touchpoints >= 10 THEN 80
        WHEN p_total_touchpoints >= 5 THEN 60
        WHEN p_total_touchpoints >= 2 THEN 40
        WHEN p_total_touchpoints >= 1 THEN 20
        ELSE 0
    END;
    
    -- Engagement score (20% weight) - based on two-way communication
    v_engagement_score := CASE
        WHEN COALESCE(p_inbound_count, 0) > 0 AND COALESCE(p_outbound_count, 0) > 0 THEN 100
        WHEN p_inbound_count > 0 OR p_outbound_count > 0 THEN 50
        ELSE 0
    END;
    
    -- Reciprocity score (20% weight) - balance of in/out
    IF COALESCE(p_inbound_count, 0) + COALESCE(p_outbound_count, 0) > 0 THEN
        v_reciprocity_score := 100 - ABS(
            (COALESCE(p_inbound_count, 0)::FLOAT / GREATEST(p_inbound_count + p_outbound_count, 1)) - 0.5
        ) * 200;
        v_reciprocity_score := GREATEST(0, LEAST(100, v_reciprocity_score));
    ELSE
        v_reciprocity_score := 0;
    END IF;
    
    -- Calculate weighted temperature (0-100 scale)
    v_temperature := (
        (v_recency_score * 0.35) +
        (v_frequency_score * 0.25) +
        (v_engagement_score * 0.20) +
        (v_reciprocity_score * 0.20)
    )::INT;
    
    RETURN GREATEST(0, LEAST(100, v_temperature));
END;
$$;


ALTER FUNCTION "public"."calculate_relationship_temperature"("p_days_since_contact" integer, "p_total_touchpoints" integer, "p_inbound_count" integer, "p_outbound_count" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_relationship_temperature"("p_days_since_contact" integer, "p_total_touchpoints" integer, "p_inbound_count" integer, "p_outbound_count" integer) IS 'Calculates relationship temperature (0-100) based on recency, frequency, engagement, and reciprocity';



CREATE OR REPLACE FUNCTION "public"."calculate_service_completeness"("service_id_param" "uuid") RETURNS numeric
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  completeness_score DECIMAL := 0;
  total_fields INTEGER := 15;
  filled_fields INTEGER := 0;
BEGIN
  SELECT COUNT(*) INTO filled_fields
  FROM (
    SELECT
      CASE WHEN name IS NOT NULL AND name != '' THEN 1 END,
      CASE WHEN description IS NOT NULL AND description != '' THEN 1 END,
      CASE WHEN categories IS NOT NULL AND array_length(categories, 1) > 0 THEN 1 END,
      CASE WHEN organization_id IS NOT NULL THEN 1 END,
      CASE WHEN contact_phone IS NOT NULL AND contact_phone != '' THEN 1 END,
      CASE WHEN contact_email IS NOT NULL AND contact_email != '' THEN 1 END,
      CASE WHEN website_url IS NOT NULL AND website_url != '' THEN 1 END,
      CASE WHEN location_address IS NOT NULL AND location_address != '' THEN 1 END,
      CASE WHEN location_city IS NOT NULL AND location_city != '' THEN 1 END,
      CASE WHEN location_state IS NOT NULL AND location_state != '' THEN 1 END,
      CASE WHEN target_age_min IS NOT NULL THEN 1 END,
      CASE WHEN target_age_max IS NOT NULL THEN 1 END,
      CASE WHEN operating_hours IS NOT NULL THEN 1 END,
      CASE WHEN eligibility_criteria IS NOT NULL AND array_length(eligibility_criteria, 1) > 0 THEN 1 END,
      CASE WHEN cost IS NOT NULL AND cost != '' THEN 1 END
    FROM services
    WHERE id = service_id_param
  ) AS field_check;

  completeness_score := (filled_fields::DECIMAL / total_fields::DECIMAL) * 100;
  RETURN ROUND(completeness_score, 2);
END;
$$;


ALTER FUNCTION "public"."calculate_service_completeness"("service_id_param" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_trust_score"("interaction_dates" timestamp with time zone[], "quality_scores" numeric[], "base_score" numeric DEFAULT 0.5, "decay_days" numeric DEFAULT 90) RETURNS numeric
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
DECLARE
    total_weighted_score numeric := 0;
    total_weight numeric := 0;
    i integer;
    days_since numeric;
    time_weight numeric;
    quality_weight numeric;
BEGIN
    -- If no interactions, return base score
    IF array_length(interaction_dates, 1) IS NULL THEN
        RETURN base_score;
    END IF;
    
    -- Calculate weighted average with time decay
    FOR i IN 1..array_length(interaction_dates, 1) LOOP
        -- Calculate days since interaction
        days_since := EXTRACT(EPOCH FROM (now() - interaction_dates[i])) / 86400;
        
        -- Calculate time decay weight using exponential decay
        time_weight := exp(-days_since / decay_days);
        
        -- Use quality score if available, otherwise use neutral score of 3.0
        quality_weight := COALESCE(quality_scores[i], 3.0);
        
        -- Accumulate weighted scores
        total_weighted_score := total_weighted_score + (quality_weight * time_weight);
        total_weight := total_weight + time_weight;
    END LOOP;
    
    -- Calculate final score (normalize to 0-1 range, quality scores are 1-5)
    IF total_weight > 0 THEN
        RETURN LEAST(1.0, GREATEST(0.0, (total_weighted_score / total_weight) / 5.0));
    ELSE
        RETURN base_score;
    END IF;
END;
$$;


ALTER FUNCTION "public"."calculate_trust_score"("interaction_dates" timestamp with time zone[], "quality_scores" numeric[], "base_score" numeric, "decay_days" numeric) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_trust_score"("interaction_dates" timestamp with time zone[], "quality_scores" numeric[], "base_score" numeric, "decay_days" numeric) IS 'Calculates time-decayed trust score from interaction arrays';



CREATE OR REPLACE FUNCTION "public"."can_access_story"("story_id" "uuid", "user_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  story_privacy TEXT;
  story_storyteller_id UUID;
  user_community TEXT;
  storyteller_community TEXT;
BEGIN
  -- Get story details
  SELECT privacy_level, storyteller_id INTO story_privacy, story_storyteller_id
  FROM stories WHERE id = story_id;
  
  -- If story doesn't exist, no access
  IF story_privacy IS NULL THEN
    RETURN FALSE;
  END IF;
  
  -- Storyteller always has access to their own stories
  IF story_storyteller_id = user_id THEN
    RETURN TRUE;
  END IF;
  
  -- Public stories are accessible to everyone
  IF story_privacy = 'public' THEN
    RETURN TRUE;
  END IF;
  
  -- Community stories are accessible to same community members
  IF story_privacy = 'community' THEN
    SELECT community_affiliation INTO user_community
    FROM users WHERE id = user_id;
    
    SELECT community_affiliation INTO storyteller_community
    FROM users WHERE id = story_storyteller_id;
    
    RETURN user_community IS NOT NULL 
           AND storyteller_community IS NOT NULL 
           AND user_community = storyteller_community;
  END IF;
  
  -- Private stories are only accessible to storyteller
  RETURN FALSE;
END;
$$;


ALTER FUNCTION "public"."can_access_story"("story_id" "uuid", "user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."can_access_story"("story_id" "uuid", "user_id" "uuid") IS 'Enforces community sovereignty and privacy preferences for story access';



CREATE OR REPLACE FUNCTION "public"."can_read_storyteller_data"() RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  -- Allow public read access to published storyteller profiles
  -- This bypasses RLS infinite recursion
  SELECT true;
$$;


ALTER FUNCTION "public"."can_read_storyteller_data"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_action_bounds"("p_action_name" "text", "p_params" "jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_action agent_actions%ROWTYPE;
  v_bounds JSONB;
  v_violations JSONB := '[]'::JSONB;
BEGIN
  SELECT * INTO v_action FROM agent_actions WHERE action_name = p_action_name;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('within_bounds', FALSE, 'error', 'Action not found');
  END IF;

  v_bounds := v_action.bounds;

  -- Check max_records bound
  IF v_bounds ? 'max_records' AND p_params ? 'record_count' THEN
    IF (p_params->>'record_count')::INT > (v_bounds->>'max_records')::INT THEN
      v_violations := v_violations || jsonb_build_object(
        'bound', 'max_records',
        'limit', v_bounds->>'max_records',
        'requested', p_params->>'record_count'
      );
    END IF;
  END IF;

  RETURN jsonb_build_object(
    'within_bounds', jsonb_array_length(v_violations) = 0,
    'violations', v_violations,
    'autonomy_level', v_action.autonomy_level
  );
END;
$$;


ALTER FUNCTION "public"."check_action_bounds"("p_action_name" "text", "p_params" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_consent_compliance"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text") RETURNS TABLE("allowed" boolean, "reason" "text")
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_consent_level TEXT;
  v_permitted_uses TEXT[];
  v_consent_revoked BOOLEAN;
BEGIN
  -- Get consent details
  SELECT
    cl.consent_level,
    cl.permitted_uses,
    cl.consent_revoked
  INTO
    v_consent_level,
    v_permitted_uses,
    v_consent_revoked
  FROM alma_consent_ledger cl
  WHERE cl.entity_type = p_entity_type
    AND cl.entity_id = p_entity_id
  LIMIT 1;

  -- Check if consent exists
  IF v_consent_level IS NULL THEN
    RETURN QUERY SELECT false, 'No consent record found';
    RETURN;
  END IF;

  -- Check if consent revoked
  IF v_consent_revoked THEN
    RETURN QUERY SELECT false, 'Consent has been revoked';
    RETURN;
  END IF;

  -- Check if action is permitted
  IF NOT (p_action = ANY(v_permitted_uses)) THEN
    RETURN QUERY SELECT false, FORMAT('Action "%s" not in permitted uses', p_action);
    RETURN;
  END IF;

  -- Check consent level restrictions
  IF v_consent_level = 'Strictly Private' AND p_action NOT IN ('Query (internal)') THEN
    RETURN QUERY SELECT false, 'Strictly Private entities can only be queried internally';
    RETURN;
  END IF;

  -- All checks passed
  RETURN QUERY SELECT true, 'Action allowed';
END;
$$;


ALTER FUNCTION "public"."check_consent_compliance"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_coordination_complete"("p_parent_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_total INT;
  v_completed INT;
  v_failed INT;
  v_pending INT;
BEGIN
  SELECT
    COUNT(*),
    COUNT(*) FILTER (WHERE status = 'completed'),
    COUNT(*) FILTER (WHERE status = 'failed'),
    COUNT(*) FILTER (WHERE status IN ('pending', 'approved', 'executing'))
  INTO v_total, v_completed, v_failed, v_pending
  FROM agent_proposals
  WHERE parent_proposal_id = p_parent_id;

  RETURN jsonb_build_object(
    'total', v_total,
    'completed', v_completed,
    'failed', v_failed,
    'pending', v_pending,
    'all_complete', (v_pending = 0),
    'any_failed', (v_failed > 0)
  );
END;
$$;


ALTER FUNCTION "public"."check_coordination_complete"("p_parent_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_cultural_content"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    elder_keywords TEXT[] := ARRAY['elder', 'aunty', 'auntie', 'uncle', 'traditional owner', 'first nations', 'aboriginal', 'indigenous', 'sacred', 'ceremony', 'dreaming', 'country'];
    keyword TEXT;
BEGIN
    -- Check transcript for cultural keywords
    IF NEW.transcript IS NOT NULL THEN
        FOREACH keyword IN ARRAY elder_keywords LOOP
            IF LOWER(NEW.transcript) LIKE '%' || keyword || '%' THEN
                NEW.mentions_elders := TRUE;
                NEW.requires_cultural_review := TRUE;
                NEW.cultural_review_status := 'pending';
                EXIT;
            END IF;
        END LOOP;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."check_cultural_content"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_cultural_restrictions"("p_entity_type" "text", "p_entity_id" "text") RETURNS TABLE("has_restrictions" boolean, "sensitivity_level" "text", "permitted_uses" "text"[], "restrictions" "text"[], "requires_attribution" boolean, "cultural_liaison_id" "text")
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        TRUE as has_restrictions,
        cp.sensitivity_level,
        cp.permitted_uses,
        cp.restrictions,
        cp.requires_attribution,
        cp.cultural_liaison_id
    FROM cultural_protocols cp
    WHERE cp.entity_type = p_entity_type
      AND (cp.entity_id = p_entity_id OR cp.entity_id IS NULL)
      AND (cp.consent_expires IS NULL OR cp.consent_expires > CURRENT_DATE)
    ORDER BY
        CASE WHEN cp.entity_id IS NOT NULL THEN 0 ELSE 1 END,  -- Specific rules first
        cp.sensitivity_level DESC
    LIMIT 1;

    -- If no restrictions found, return default
    IF NOT FOUND THEN
        RETURN QUERY SELECT
            FALSE as has_restrictions,
            'standard'::TEXT as sensitivity_level,
            ARRAY['internal', 'external']::TEXT[] as permitted_uses,
            NULL::TEXT[] as restrictions,
            FALSE as requires_attribution,
            NULL::TEXT as cultural_liaison_id;
    END IF;
END;
$$;


ALTER FUNCTION "public"."check_cultural_restrictions"("p_entity_type" "text", "p_entity_id" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."check_cultural_restrictions"("p_entity_type" "text", "p_entity_id" "text") IS 'Check if an entity has cultural restrictions before accessing/syncing';



CREATE OR REPLACE FUNCTION "public"."check_daily_spend_alert"("p_threshold_usd" numeric DEFAULT 10.00) RETURNS TABLE("alert_date" "date", "total_spend" numeric, "threshold" numeric, "top_model" "text", "top_model_cost" numeric)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    WITH daily AS (
        SELECT
            DATE(timestamp) as dt,
            SUM(estimated_cost) as total,
            MAX(model) FILTER (WHERE estimated_cost = (SELECT MAX(estimated_cost) FROM api_usage u2 WHERE DATE(u2.timestamp) = DATE(api_usage.timestamp))) as top_model
        FROM api_usage
        WHERE DATE(timestamp) = CURRENT_DATE
        GROUP BY DATE(timestamp)
    )
    SELECT
        d.dt as alert_date,
        ROUND(d.total::DECIMAL, 2) as total_spend,
        p_threshold_usd as threshold,
        d.top_model,
        ROUND((SELECT SUM(estimated_cost) FROM api_usage WHERE DATE(timestamp) = d.dt AND model = d.top_model)::DECIMAL, 2) as top_model_cost
    FROM daily d
    WHERE d.total > p_threshold_usd;
END;
$$;


ALTER FUNCTION "public"."check_daily_spend_alert"("p_threshold_usd" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cleanup_expired_conversations"() RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM conversation_context
  WHERE expires_at < NOW();

  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$;


ALTER FUNCTION "public"."cleanup_expired_conversations"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."cleanup_expired_conversations"() IS 'Removes expired chatbot sessions (called by cron)';



CREATE OR REPLACE FUNCTION "public"."cleanup_expired_proposals"() RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  UPDATE agent_proposals
  SET status = 'expired', updated_at = NOW()
  WHERE status = 'pending'
    AND deadline IS NOT NULL
    AND deadline < NOW();
END;
$$;


ALTER FUNCTION "public"."cleanup_expired_proposals"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cleanup_old_audit_logs"("retention_days" integer DEFAULT 365) RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    deleted_count INT;
BEGIN
    DELETE FROM agent_audit_log
    WHERE timestamp < NOW() - (retention_days || ' days')::INTERVAL;

    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$;


ALTER FUNCTION "public"."cleanup_old_audit_logs"("retention_days" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cleanup_old_sync_events"("retention_days" integer DEFAULT 30) RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM sync_events
    WHERE 
        sync_status IN ('completed', 'skipped')
        AND processed_at < NOW() - (retention_days || ' days')::INTERVAL;

    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    -- Also clean up old failed events that exceeded max retries
    DELETE FROM sync_events
    WHERE 
        sync_status = 'failed'
        AND retry_count >= max_retries
        AND created_at < NOW() - (retention_days || ' days')::INTERVAL;

    RETURN deleted_count;
END;
$$;


ALTER FUNCTION "public"."cleanup_old_sync_events"("retention_days" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."compare_interventions"("p_intervention_ids" "uuid"[]) RETURNS TABLE("intervention_id" "uuid", "name" "text", "type" "text", "geography" "text", "evidence_level" "text", "evidence_count" bigint, "outcome_count" bigint, "consent_level" "text", "cost_per_day" numeric, "outcome_types" "text"[])
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    i.id as intervention_id,
    i.name,
    i.type,
    i.geography,
    i.evidence_level,
    (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) as evidence_count,
    (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) as outcome_count,
    i.consent_level,
    i.cost_per_participant_per_day as cost_per_day,
    (SELECT array_agg(DISTINCT o.outcome_type)
     FROM alma_intervention_outcomes io
     JOIN alma_outcomes o ON o.id = io.outcome_id
     WHERE io.intervention_id = i.id) as outcome_types
  FROM alma_interventions i
  WHERE i.id = ANY(p_intervention_ids)
  ORDER BY array_position(p_intervention_ids, i.id);
END;
$$;


ALTER FUNCTION "public"."compare_interventions"("p_intervention_ids" "uuid"[]) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."complete_task"("p_task_id" "uuid", "p_output" "jsonb", "p_reasoning" "text" DEFAULT NULL::"text", "p_confidence" numeric DEFAULT NULL::numeric) RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_agent_id TEXT;
  v_started_at TIMESTAMPTZ;
BEGIN
  -- Get task info
  SELECT assigned_agent, started_at INTO v_agent_id, v_started_at
  FROM agent_task_queue WHERE id = p_task_id;

  -- Update task
  UPDATE agent_task_queue
  SET status = 'done',
      output = p_output,
      reasoning = p_reasoning,
      confidence = p_confidence,
      completed_at = NOW(),
      duration_ms = EXTRACT(EPOCH FROM (NOW() - v_started_at))::INT * 1000,
      updated_at = NOW()
  WHERE id = p_task_id;

  -- Clear agent's current task
  UPDATE agents
  SET current_task_id = NULL,
      last_heartbeat = NOW()
  WHERE id = v_agent_id;
END;
$$;


ALTER FUNCTION "public"."complete_task"("p_task_id" "uuid", "p_output" "jsonb", "p_reasoning" "text", "p_confidence" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."contact_matches_region"("contact_location" "text", "region_tags" "text"[]) RETURNS boolean
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
BEGIN
    IF region_tags IS NULL OR array_length(region_tags, 1) IS NULL THEN
        RETURN false;
    END IF;
    
    IF contact_location IS NULL OR contact_location = '' THEN
        RETURN false;
    END IF;
    
    RETURN EXISTS (
        SELECT 1 FROM unnest(region_tags) AS tag
        WHERE LOWER(contact_location) LIKE '%' || LOWER(tag) || '%'
    );
END;
$$;


ALTER FUNCTION "public"."contact_matches_region"("contact_location" "text", "region_tags" "text"[]) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."contact_matches_region"("contact_location" "text", "region_tags" "text"[]) IS 'Checks if contact location matches any of the opportunity region tags';



CREATE OR REPLACE FUNCTION "public"."contact_matches_role"("contact_position" "text", "contact_company" "text", "contact_industry" "text", "contact_skills" "text"[], "contact_alignment_tags" "text"[], "role_tags" "text"[]) RETURNS boolean
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
BEGIN
    IF role_tags IS NULL OR array_length(role_tags, 1) IS NULL THEN
        RETURN false;
    END IF;
    
    RETURN EXISTS (
        SELECT 1 FROM unnest(role_tags) AS tag
        WHERE 
            (contact_position IS NOT NULL AND LOWER(contact_position) LIKE '%' || LOWER(tag) || '%')
            OR (contact_company IS NOT NULL AND LOWER(contact_company) LIKE '%' || LOWER(tag) || '%')
            OR (contact_industry IS NOT NULL AND LOWER(contact_industry) LIKE '%' || LOWER(tag) || '%')
            OR (contact_skills IS NOT NULL AND EXISTS (
                SELECT 1 FROM unnest(contact_skills) AS skill
                WHERE LOWER(skill) LIKE '%' || LOWER(tag) || '%'
            ))
            OR (contact_alignment_tags IS NOT NULL AND EXISTS (
                SELECT 1 FROM unnest(contact_alignment_tags) AS align_tag
                WHERE LOWER(align_tag) LIKE '%' || LOWER(tag) || '%'
            ))
    );
END;
$$;


ALTER FUNCTION "public"."contact_matches_role"("contact_position" "text", "contact_company" "text", "contact_industry" "text", "contact_skills" "text"[], "contact_alignment_tags" "text"[], "role_tags" "text"[]) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."contact_matches_role"("contact_position" "text", "contact_company" "text", "contact_industry" "text", "contact_skills" "text"[], "contact_alignment_tags" "text"[], "role_tags" "text"[]) IS 'Checks if contact professional info matches any of the opportunity role tags';



CREATE OR REPLACE FUNCTION "public"."cosine_similarity"("a" "public"."vector", "b" "public"."vector") RETURNS double precision
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
BEGIN
  -- Cosine similarity = 1 - cosine distance
  RETURN 1 - (a <=> b);
END;
$$;


ALTER FUNCTION "public"."cosine_similarity"("a" "public"."vector", "b" "public"."vector") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_decision_outcomes_table"() RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- This function ensures the table exists
    -- Table creation is handled above, this is just for API compatibility
    RETURN;
END;
$$;


ALTER FUNCTION "public"."create_decision_outcomes_table"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_decisions_table"() RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- This function ensures the table exists
    -- Table creation is handled above, this is just for API compatibility
    RETURN;
END;
$$;


ALTER FUNCTION "public"."create_decisions_table"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_empathy_project"("project_name" "text", "organization_name" "text", "organization_email" "text", "creator_user_id" "uuid", "template_id" "uuid" DEFAULT NULL::"uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  new_project_id UUID;
  project_slug TEXT;
  template_config RECORD;
BEGIN
  -- Generate unique slug
  project_slug := lower(regexp_replace(project_name, '[^a-zA-Z0-9]+', '-', 'g'));
  project_slug := trim(project_slug, '-');
  
  -- Make slug unique if needed
  WHILE EXISTS (SELECT 1 FROM projects WHERE slug = project_slug) LOOP
    project_slug := project_slug || '-' || substr(encode(gen_random_bytes(4), 'hex'), 1, 8);
  END LOOP;
  
  -- Get template configuration if provided
  IF template_id IS NOT NULL THEN
    SELECT * INTO template_config FROM project_templates WHERE id = template_id;
  END IF;
  
  -- Create the project
  INSERT INTO projects (
    name,
    slug,
    organization_name,
    organization_email,
    sovereignty_framework,
    cultural_protocols,
    settings,
    branding_config
  ) VALUES (
    project_name,
    project_slug,
    organization_name,
    organization_email,
    COALESCE(template_config.default_sovereignty_framework, '{
      "cultural_protocols_required": true,
      "consent_granularity": "story_level",
      "community_ownership": true,
      "value_sharing": true,
      "indigenous_data_sovereignty": true
    }'::jsonb),
    COALESCE(template_config.default_cultural_protocols, '{}'::jsonb),
    COALESCE(template_config.default_settings, '{
      "story_submission_enabled": true,
      "public_story_display": true,
      "community_insights_enabled": true,
      "cross_project_collaboration": false,
      "analytics_sharing": "project_only"
    }'::jsonb),
    COALESCE(template_config.default_branding, '{
      "primary_color": "#B85C38",
      "secondary_color": "#7A9B76",
      "logo_url": null,
      "font_family": "Inter",
      "custom_css": null
    }'::jsonb)
  ) RETURNING id INTO new_project_id;
  
  -- Add creator as project owner
  INSERT INTO project_members (
    project_id,
    user_id,
    role,
    permissions,
    status,
    joined_at
  ) VALUES (
    new_project_id,
    creator_user_id,
    'owner',
    '{
      "can_submit_stories": true,
      "can_edit_own_stories": true,
      "can_view_analytics": true,
      "can_manage_settings": true,
      "can_invite_members": true,
      "can_export_data": true
    }'::jsonb,
    'active',
    NOW()
  );
  
  RETURN new_project_id;
END;
$$;


ALTER FUNCTION "public"."create_empathy_project"("project_name" "text", "organization_name" "text", "organization_email" "text", "creator_user_id" "uuid", "template_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_extraction_notifications"() RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  high_confidence_items CURSOR FOR
    SELECT id, raw_title, confidence_score, suggested_type
    FROM knowledge_extraction_queue
    WHERE status = 'pending'
    AND confidence_score >= 0.8
    AND NOT EXISTS (
      SELECT 1 FROM wiki_notifications
      WHERE queue_item_id = knowledge_extraction_queue.id
      AND type = 'high_confidence'
    );

  item_record RECORD;
  notification_count INTEGER := 0;
BEGIN
  FOR item_record IN high_confidence_items LOOP
    INSERT INTO wiki_notifications (
      type,
      title,
      message,
      link,
      priority,
      queue_item_id,
      metadata
    ) VALUES (
      'high_confidence',
      'High-Confidence Knowledge Extracted',
      item_record.raw_title || ' (' || ROUND(item_record.confidence_score * 100) || '% confidence)',
      '/admin/queue',
      'normal',
      item_record.id,
      jsonb_build_object(
        'confidence_score', item_record.confidence_score,
        'suggested_type', item_record.suggested_type
      )
    );

    notification_count := notification_count + 1;
  END LOOP;

  RETURN notification_count;
END;
$$;


ALTER FUNCTION "public"."create_extraction_notifications"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."create_extraction_notifications"() IS 'Creates notifications for high-confidence extractions (run after scans)';



CREATE OR REPLACE FUNCTION "public"."create_health_alert"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  prev_score INTEGER;
  site_name TEXT;
BEGIN
  SELECT health_score INTO prev_score
  FROM site_health_checks
  WHERE site_id = NEW.site_id AND id != NEW.id
  ORDER BY checked_at DESC
  LIMIT 1;

  SELECT name INTO site_name FROM ecosystem_sites WHERE id = NEW.site_id;

  IF prev_score IS NOT NULL AND (prev_score - NEW.health_score) >= 20 THEN
    INSERT INTO health_alerts (site_id, alert_type, severity, message, previous_score, current_score)
    VALUES (
      NEW.site_id, 'degraded',
      CASE WHEN NEW.health_score < 50 THEN 'critical' ELSE 'warning' END,
      site_name || ' health dropped from ' || prev_score || ' to ' || NEW.health_score,
      prev_score, NEW.health_score
    );
  END IF;

  IF NEW.health_status IN ('critical', 'offline') THEN
    INSERT INTO health_alerts (site_id, alert_type, severity, message, current_score)
    VALUES (NEW.site_id, NEW.health_status, 'critical',
      site_name || ' is ' || NEW.health_status || ' (score: ' || NEW.health_score || ')',
      NEW.health_score);
  END IF;

  IF prev_score IS NOT NULL AND prev_score < 70 AND NEW.health_score >= 70 THEN
    INSERT INTO health_alerts (site_id, alert_type, severity, message, previous_score, current_score)
    VALUES (NEW.site_id, 'recovered', 'info',
      site_name || ' recovered from ' || prev_score || ' to ' || NEW.health_score,
      prev_score, NEW.health_score);
    UPDATE health_alerts SET resolved = true, resolved_at = now()
    WHERE site_id = NEW.site_id AND resolved = false AND alert_type != 'recovered';
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."create_health_alert"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_research_session"("p_query" "text", "p_depth" "text" DEFAULT 'quick'::"text", "p_max_consent_level" "text" DEFAULT 'Public Knowledge Commons'::"text", "p_user_id" "uuid" DEFAULT NULL::"uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_session_id UUID;
BEGIN
  INSERT INTO alma_research_sessions (query, depth, max_consent_level, user_id, status)
  VALUES (p_query, p_depth, p_max_consent_level, p_user_id, 'pending')
  RETURNING id INTO v_session_id;

  RETURN v_session_id;
END;
$$;


ALTER FUNCTION "public"."create_research_session"("p_query" "text", "p_depth" "text", "p_max_consent_level" "text", "p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_review_reminders"() RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  pages_due CURSOR FOR
    SELECT id, title, slug, next_review_due, last_reviewed_at
    FROM wiki_pages
    WHERE status = 'active'
    AND next_review_due < NOW()
    AND NOT EXISTS (
      -- Don't create duplicate notifications
      SELECT 1 FROM wiki_notifications
      WHERE wiki_page_id = wiki_pages.id
      AND type = 'review_due'
      AND is_read = false
      AND created_at > NOW() - INTERVAL '7 days'
    );

  page_record RECORD;
  days_overdue INTEGER;
  notification_count INTEGER := 0;
BEGIN
  FOR page_record IN pages_due LOOP
    days_overdue := EXTRACT(DAY FROM NOW() - page_record.next_review_due)::INTEGER;

    INSERT INTO wiki_notifications (
      type,
      title,
      message,
      link,
      priority,
      wiki_page_id,
      metadata
    ) VALUES (
      'review_due',
      'Page Due for Review',
      page_record.title || ' is ' || days_overdue || ' days overdue for review',
      '/wiki/' || page_record.slug || '/edit',
      CASE
        WHEN days_overdue > 30 THEN 'urgent'
        WHEN days_overdue > 14 THEN 'high'
        WHEN days_overdue > 7 THEN 'normal'
        ELSE 'low'
      END,
      page_record.id,
      jsonb_build_object(
        'days_overdue', days_overdue,
        'last_reviewed_at', page_record.last_reviewed_at,
        'next_review_due', page_record.next_review_due
      )
    );

    notification_count := notification_count + 1;
  END LOOP;

  RETURN notification_count;
END;
$$;


ALTER FUNCTION "public"."create_review_reminders"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."create_review_reminders"() IS 'Creates notifications for pages due for review (run daily)';



CREATE OR REPLACE FUNCTION "public"."decrement_communities_joined"("p_user_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  -- Placeholder function - could update communities count if needed  
  NULL;
END;
$$;


ALTER FUNCTION "public"."decrement_communities_joined"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."decrement_stories_contributed"("p_user_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  -- Update the user's contribution count in storytellers table
  UPDATE storytellers
  SET stories_created_count = GREATEST(COALESCE(stories_created_count, 0) - 1, 0)
  WHERE user_id = p_user_id;
END;
$$;


ALTER FUNCTION "public"."decrement_stories_contributed"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."delete_old_pulse_events"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  delete from pulse_events where created_at < now() - interval '7 days';
  return new;
end;
$$;


ALTER FUNCTION "public"."delete_old_pulse_events"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."detect_cultural_content"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    -- Expanded keyword list for Australian First Nations context
    sacred_keywords TEXT[] := ARRAY[
        'sacred', 'ceremony', 'dreaming', 'songline', 'initiation',
        'men''s business', 'women''s business', 'secret', 'restricted'
    ];
    elder_keywords TEXT[] := ARRAY[
        'elder', 'aunty', 'auntie', 'uncle', 'traditional owner',
        'custodian', 'knowledge keeper', 'lawman', 'lawwoman'
    ];
    cultural_keywords TEXT[] := ARRAY[
        'first nations', 'aboriginal', 'indigenous', 'torres strait',
        'country', 'on country', 'welcome to country', 'acknowledgement',
        'traditional lands', 'sovereignty', 'treaty', 'land rights'
    ];
    keyword TEXT;
    transcript_lower TEXT;
BEGIN
    -- Only check if there's content to check
    IF NEW.transcript IS NULL THEN
        RETURN NEW;
    END IF;

    transcript_lower := LOWER(NEW.transcript);

    -- Check for sacred content (highest restriction)
    FOREACH keyword IN ARRAY sacred_keywords LOOP
        IF transcript_lower LIKE '%' || keyword || '%' THEN
            NEW.requires_cultural_review := TRUE;
            NEW.cultural_review_status := 'pending';
            NEW.mentions_elders := TRUE;

            -- Create cultural protocol entry
            INSERT INTO cultural_protocols (
                entity_type, entity_id, sensitivity_level,
                permitted_uses, restrictions
            ) VALUES (
                'voice_note', NEW.id::TEXT, 'sacred',
                ARRAY['internal'], ARRAY['no_external_sharing', 'elder_review_required']
            ) ON CONFLICT DO NOTHING;

            RETURN NEW;
        END IF;
    END LOOP;

    -- Check for elder mentions
    FOREACH keyword IN ARRAY elder_keywords LOOP
        IF transcript_lower LIKE '%' || keyword || '%' THEN
            NEW.mentions_elders := TRUE;
            NEW.requires_cultural_review := TRUE;
            NEW.cultural_review_status := 'pending';
            RETURN NEW;
        END IF;
    END LOOP;

    -- Check for general cultural content
    FOREACH keyword IN ARRAY cultural_keywords LOOP
        IF transcript_lower LIKE '%' || keyword || '%' THEN
            -- Flag but don't require review for general cultural mentions
            NEW.requires_cultural_review := FALSE;
            -- Could add metadata for cultural context tracking
            RETURN NEW;
        END IF;
    END LOOP;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."detect_cultural_content"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."detect_cultural_content"() IS 'Enhanced detection of cultural content in text (voice notes, etc.)';



CREATE OR REPLACE FUNCTION "public"."determine_lcaa_stage"("p_temperature" integer, "p_inbound_count" integer, "p_outbound_count" integer, "p_total_touchpoints" integer) RETURNS "text"
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
BEGIN
    -- LCAA: Listen, Connect, Act, Amplify
    IF p_temperature >= 80 AND COALESCE(p_total_touchpoints, 0) >= 10 THEN
        RETURN 'amplify';  -- Active promoters
    ELSIF p_temperature >= 60 AND COALESCE(p_inbound_count, 0) > 0 AND COALESCE(p_outbound_count, 0) > 0 THEN
        RETURN 'act';      -- Active collaboration
    ELSIF p_temperature >= 40 OR COALESCE(p_total_touchpoints, 0) >= 3 THEN
        RETURN 'connect';  -- Building relationship
    ELSE
        RETURN 'listen';   -- Learning about them
    END IF;
END;
$$;


ALTER FUNCTION "public"."determine_lcaa_stage"("p_temperature" integer, "p_inbound_count" integer, "p_outbound_count" integer, "p_total_touchpoints" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."determine_lcaa_stage"("p_temperature" integer, "p_inbound_count" integer, "p_outbound_count" integer, "p_total_touchpoints" integer) IS 'Determines LCAA stage (listen/connect/act/amplify) based on relationship metrics';



CREATE OR REPLACE FUNCTION "public"."exec"("sql" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  EXECUTE sql;
  RETURN json_build_object('success', true);
EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object(
    'success', false,
    'error', SQLERRM,
    'detail', SQLSTATE
  );
END;
$$;


ALTER FUNCTION "public"."exec"("sql" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."exec"("sql" "text") IS 'Execute arbitrary SQL - service role only';



CREATE OR REPLACE FUNCTION "public"."exec_sql"("query" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  EXECUTE query;
END;
$$;


ALTER FUNCTION "public"."exec_sql"("query" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."execute_sql"("sql_query" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    result json;
    rec record;
    results json[] := '{}';
BEGIN
    -- Security: Only allow SELECT statements
    IF NOT (TRIM(UPPER(sql_query)) LIKE 'SELECT%') THEN
        RAISE EXCEPTION 'Only SELECT statements are allowed';
    END IF;
    
    -- Execute the query and collect results
    FOR rec IN EXECUTE sql_query LOOP
        results := results || row_to_json(rec);
    END LOOP;
    
    -- Return as JSON array
    RETURN array_to_json(results);
    
EXCEPTION
    WHEN OTHERS THEN
        -- Return error information
        RETURN json_build_object(
            'error', true,
            'message', SQLERRM,
            'code', SQLSTATE
        );
END;
$$;


ALTER FUNCTION "public"."execute_sql"("sql_query" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."expire_old_proposals"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  UPDATE agent_proposals
  SET status = 'expired', updated_at = NOW()
  WHERE status = 'pending'
    AND deadline IS NOT NULL
    AND deadline < NOW();
  RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."expire_old_proposals"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."find_evidence_gaps"("p_jurisdiction" "text" DEFAULT NULL::"text", "p_intervention_type" "text" DEFAULT NULL::"text", "p_limit" integer DEFAULT 20) RETURNS TABLE("intervention_id" "uuid", "intervention_name" "text", "intervention_type" "text", "geography" "text", "current_evidence_level" "text", "evidence_count" bigint, "outcome_count" bigint, "gap_severity" "text", "gap_description" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    i.id as intervention_id,
    i.name as intervention_name,
    i.type as intervention_type,
    i.geography,
    i.evidence_level as current_evidence_level,
    (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) as evidence_count,
    (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) as outcome_count,
    CASE
      WHEN (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) = 0
           AND (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) = 0
        THEN 'critical'
      WHEN (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) = 0
        THEN 'high'
      WHEN (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) = 0
        THEN 'medium'
      ELSE 'low'
    END as gap_severity,
    CASE
      WHEN (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) = 0
           AND (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) = 0
        THEN 'No evidence or outcome data linked'
      WHEN (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) = 0
        THEN 'No evidence research linked'
      WHEN (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) = 0
        THEN 'No outcome measures linked'
      ELSE 'Has basic data, may need verification'
    END as gap_description
  FROM alma_interventions i
  WHERE
    i.consent_level = 'Public Knowledge Commons'
    AND (p_jurisdiction IS NULL OR i.geography = p_jurisdiction)
    AND (p_intervention_type IS NULL OR i.type = p_intervention_type)
  ORDER BY
    CASE
      WHEN (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) = 0
           AND (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) = 0 THEN 1
      WHEN (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) = 0 THEN 2
      WHEN (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) = 0 THEN 3
      ELSE 4
    END,
    i.name
  LIMIT p_limit;
END;
$$;


ALTER FUNCTION "public"."find_evidence_gaps"("p_jurisdiction" "text", "p_intervention_type" "text", "p_limit" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."find_potential_duplicates"("p_entity_id" "uuid", "p_threshold" numeric DEFAULT 0.7) RETURNS TABLE("candidate_id" "uuid", "match_score" numeric, "match_reasons" "jsonb")
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_entity RECORD;
    v_email_domain TEXT;
BEGIN
    SELECT * INTO v_entity FROM canonical_entities WHERE id = p_entity_id;

    IF v_entity IS NULL THEN RETURN; END IF;

    -- Extract email domain for partial matching
    IF v_entity.canonical_email IS NOT NULL THEN
        v_email_domain := SPLIT_PART(v_entity.canonical_email, '@', 2);
    END IF;

    RETURN QUERY
    WITH scores AS (
        SELECT
            ce.id as candidate_id,
            -- Name similarity
            name_similarity(v_entity.canonical_name, ce.canonical_name) as name_score,
            -- Email domain match
            CASE
                WHEN v_email_domain IS NOT NULL
                     AND ce.canonical_email LIKE '%@' || v_email_domain
                THEN 0.3
                ELSE 0
            END as email_domain_score,
            -- Same company
            CASE
                WHEN v_entity.canonical_company IS NOT NULL
                     AND LOWER(ce.canonical_company) = LOWER(v_entity.canonical_company)
                THEN 0.4
                ELSE 0
            END as company_score
        FROM canonical_entities ce
        WHERE ce.id != p_entity_id
          AND ce.entity_type = v_entity.entity_type
    )
    SELECT
        s.candidate_id,
        (s.name_score * 0.5 + s.email_domain_score + s.company_score)::DECIMAL(3,2) as match_score,
        jsonb_build_object(
            'name_similarity', s.name_score,
            'email_domain', s.email_domain_score,
            'same_company', s.company_score
        ) as match_reasons
    FROM scores s
    WHERE (s.name_score * 0.5 + s.email_domain_score + s.company_score) >= p_threshold
    ORDER BY match_score DESC;
END;
$$;


ALTER FUNCTION "public"."find_potential_duplicates"("p_entity_id" "uuid", "p_threshold" numeric) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."find_potential_duplicates"("p_entity_id" "uuid", "p_threshold" numeric) IS 'Find entities that may be duplicates based on similarity';



CREATE OR REPLACE FUNCTION "public"."find_similar_decisions"("p_input_context" "jsonb", "p_decision_type" "text", "p_limit" integer DEFAULT 5) RETURNS TABLE("decision_id" "uuid", "input_context" "jsonb", "decision" "jsonb", "reasoning" "text", "human_feedback" "text", "confidence" numeric, "similarity_score" numeric)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- Simple key-overlap similarity (could be enhanced with embeddings)
    RETURN QUERY
    SELECT
        dt.id as decision_id,
        dt.input_context,
        dt.decision,
        dt.reasoning,
        dt.human_feedback,
        dt.confidence,
        -- Calculate simple key overlap similarity
        (
            SELECT COUNT(*)::DECIMAL / GREATEST(
                jsonb_object_keys_count(p_input_context),
                jsonb_object_keys_count(dt.input_context)
            )
            FROM (
                SELECT key FROM jsonb_object_keys(p_input_context) key
                INTERSECT
                SELECT key FROM jsonb_object_keys(dt.input_context) key
            ) overlap
        )::DECIMAL(3,2) as similarity_score
    FROM decision_traces dt
    WHERE dt.decision_type = p_decision_type
      AND dt.human_feedback IS NOT NULL  -- Only consider reviewed decisions
    ORDER BY similarity_score DESC
    LIMIT p_limit;
END;
$$;


ALTER FUNCTION "public"."find_similar_decisions"("p_input_context" "jsonb", "p_decision_type" "text", "p_limit" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."find_similar_knowledge"("query_embedding" "public"."vector", "match_threshold" double precision DEFAULT 0.7, "match_count" integer DEFAULT 10) RETURNS TABLE("id" "uuid", "title" "text", "content" "text", "similarity" double precision)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    wiki_pages.id,
    wiki_pages.title,
    wiki_pages.content,
    1 - (wiki_pages.content_embedding <=> query_embedding) as similarity
  FROM wiki_pages
  WHERE
    wiki_pages.content_embedding IS NOT NULL
    AND 1 - (wiki_pages.content_embedding <=> query_embedding) > match_threshold
  ORDER BY wiki_pages.content_embedding <=> query_embedding
  LIMIT match_count;
END;
$$;


ALTER FUNCTION "public"."find_similar_knowledge"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."find_similar_knowledge"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer) IS 'Find wiki pages similar to a query embedding using cosine similarity';



CREATE OR REPLACE FUNCTION "public"."flag_low_confidence_executions"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF NEW.confidence < 0.7 OR NEW.within_bounds = FALSE THEN
    NEW.flagged_for_review := TRUE;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."flag_low_confidence_executions"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_album_slug"("title_text" "text") RETURNS "text"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    base_slug TEXT;
    final_slug TEXT;
    counter INTEGER := 0;
BEGIN
    -- Create base slug from title
    base_slug := lower(regexp_replace(title_text, '[^a-zA-Z0-9]+', '-', 'g'));
    base_slug := trim(both '-' from base_slug);
    final_slug := base_slug;
    
    -- Check if slug exists, if so add number
    WHILE EXISTS (SELECT 1 FROM photo_albums WHERE slug = final_slug) LOOP
        counter := counter + 1;
        final_slug := base_slug || '-' || counter;
    END LOOP;
    
    RETURN final_slug;
END;
$$;


ALTER FUNCTION "public"."generate_album_slug"("title_text" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_event_slug"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF NEW.slug IS NULL THEN
    NEW.slug := LOWER(REGEXP_REPLACE(NEW.title, '[^a-zA-Z0-9]+', '-', 'g')) || '-' || SUBSTRING(NEW.id::text, 1, 8);
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."generate_event_slug"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_input_hash"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.input_hash := md5(NEW.input_context::TEXT);
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."generate_input_hash"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_public_profile_slug"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF NEW.slug IS NULL OR NEW.slug = '' THEN
    NEW.slug = lower(regexp_replace(regexp_replace(NEW.full_name, '[^a-zA-Z0-9\s]', '', 'g'), '\s+', '-', 'g'));
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."generate_public_profile_slug"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_short_id"("length" integer DEFAULT 8) RETURNS "text"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN substr(replace(gen_random_uuid()::text, '-', ''), 1, length);
END;
$$;


ALTER FUNCTION "public"."generate_short_id"("length" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_storage_prefix"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- Generate unique storage prefix: slug + short random ID
    NEW.storage_prefix = NEW.slug || '-' || generate_short_id(8);
    
    -- Ensure uniqueness (very unlikely to collide, but safety first)
    WHILE EXISTS (SELECT 1 FROM platform_organizations WHERE storage_prefix = NEW.storage_prefix) LOOP
        NEW.storage_prefix = NEW.slug || '-' || generate_short_id(8);
    END LOOP;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."generate_storage_prefix"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_weekly_report_data"("p_week_start" "date", "p_organization_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  result JSONB;
  funding_data JSONB;
  research_data JSONB;
  stats_data JSONB;
BEGIN
  -- Funding section
  SELECT jsonb_build_object(
    'new_opportunities', (
      SELECT COALESCE(jsonb_agg(jsonb_build_object(
        'id', id,
        'name', name,
        'funder', funder_name,
        'amount', max_grant_amount,
        'deadline', deadline,
        'relevance', relevance_score
      )), '[]'::jsonb)
      FROM alma_funding_opportunities
      WHERE created_at >= p_week_start
        AND created_at < p_week_start + INTERVAL '7 days'
        AND status IN ('open', 'closing_soon')
    ),
    'closing_soon', (
      SELECT COALESCE(jsonb_agg(jsonb_build_object(
        'id', id,
        'name', name,
        'funder', funder_name,
        'deadline', deadline,
        'days_left', EXTRACT(DAY FROM deadline - NOW())::INTEGER
      )), '[]'::jsonb)
      FROM alma_funding_opportunities
      WHERE deadline > NOW()
        AND deadline <= NOW() + INTERVAL '14 days'
        AND status IN ('open', 'closing_soon')
      ORDER BY deadline ASC
    ),
    'total_available', (
      SELECT COALESCE(SUM(total_pool_amount), 0)
      FROM alma_funding_opportunities
      WHERE status IN ('open', 'closing_soon')
    ),
    'count_open', (
      SELECT COUNT(*)
      FROM alma_funding_opportunities
      WHERE status IN ('open', 'closing_soon')
    )
  ) INTO funding_data;

  -- Research section
  SELECT jsonb_build_object(
    'new_evidence', (
      SELECT COALESCE(jsonb_agg(jsonb_build_object(
        'id', id,
        'title', title,
        'type', evidence_type,
        'quality', evidence_quality
      )), '[]'::jsonb)
      FROM alma_evidence
      WHERE created_at >= p_week_start
        AND created_at < p_week_start + INTERVAL '7 days'
      LIMIT 10
    ),
    'total_evidence', (SELECT COUNT(*) FROM alma_evidence)
  ) INTO research_data;

  -- Stats snapshot
  SELECT jsonb_build_object(
    'total_services', (SELECT COUNT(*) FROM services WHERE status = 'active'),
    'total_interventions', (SELECT COUNT(*) FROM alma_interventions WHERE status = 'active'),
    'total_evidence', (SELECT COUNT(*) FROM alma_evidence),
    'total_organizations', (SELECT COUNT(*) FROM organizations),
    'coverage_by_state', (
      SELECT COALESCE(jsonb_object_agg(state, cnt), '{}'::jsonb)
      FROM (
        SELECT state, COUNT(*) as cnt
        FROM services
        WHERE status = 'active' AND state IS NOT NULL
        GROUP BY state
      ) s
    )
  ) INTO stats_data;

  -- Combine all sections
  result := jsonb_build_object(
    'week_start', p_week_start,
    'week_end', p_week_start + INTERVAL '6 days',
    'generated_at', NOW(),
    'funding', funding_data,
    'research', research_data,
    'stats', stats_data
  );

  RETURN result;
END;
$$;


ALTER FUNCTION "public"."generate_weekly_report_data"("p_week_start" "date", "p_organization_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."generate_weekly_report_data"("p_week_start" "date", "p_organization_id" "uuid") IS 'Generate report data for a given week';



CREATE OR REPLACE FUNCTION "public"."get_agent_health"("p_hours" integer DEFAULT 24) RETURNS TABLE("agent_id" "text", "total_actions" bigint, "successful_actions" bigint, "failed_actions" bigint, "success_rate" numeric, "avg_duration_ms" integer, "last_success" timestamp with time zone, "last_failure" timestamp with time zone)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        a.agent_id,
        COUNT(*) as total_actions,
        SUM(CASE WHEN a.success THEN 1 ELSE 0 END) as successful_actions,
        SUM(CASE WHEN NOT a.success THEN 1 ELSE 0 END) as failed_actions,
        ROUND(100.0 * SUM(CASE WHEN a.success THEN 1 ELSE 0 END) / NULLIF(COUNT(*), 0), 2) as success_rate,
        AVG(a.duration_ms)::INT as avg_duration_ms,
        MAX(CASE WHEN a.success THEN a.timestamp END) as last_success,
        MAX(CASE WHEN NOT a.success THEN a.timestamp END) as last_failure
    FROM agent_audit_log a
    WHERE a.timestamp > NOW() - (p_hours || ' hours')::INTERVAL
    GROUP BY a.agent_id
    ORDER BY failed_actions DESC, total_actions DESC;
END;
$$;


ALTER FUNCTION "public"."get_agent_health"("p_hours" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_agent_health"("p_hours" integer) IS 'Get health metrics for all agents over specified hours';



CREATE OR REPLACE FUNCTION "public"."get_auto_approval_stats"() RETURNS TABLE("total_auto_approved" bigint, "avg_confidence" numeric, "by_type_principle" bigint, "by_type_method" bigint, "by_type_practice" bigint, "by_type_procedure" bigint, "last_7_days" bigint, "last_30_days" bigint)
    LANGUAGE "sql"
    AS $$
  SELECT
    COUNT(*) FILTER (WHERE auto_approved = true) as total_auto_approved,
    ROUND((AVG(approval_confidence) FILTER (WHERE auto_approved = true))::numeric, 3) as avg_confidence,
    COUNT(*) FILTER (WHERE auto_approved = true AND page_type = 'principle') as by_type_principle,
    COUNT(*) FILTER (WHERE auto_approved = true AND page_type = 'method') as by_type_method,
    COUNT(*) FILTER (WHERE auto_approved = true AND page_type = 'practice') as by_type_practice,
    COUNT(*) FILTER (WHERE auto_approved = true AND page_type = 'procedure') as by_type_procedure,
    COUNT(*) FILTER (WHERE auto_approved = true AND created_at > NOW() - INTERVAL '7 days') as last_7_days,
    COUNT(*) FILTER (WHERE auto_approved = true AND created_at > NOW() - INTERVAL '30 days') as last_30_days
  FROM wiki_pages;
$$;


ALTER FUNCTION "public"."get_auto_approval_stats"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_auto_approval_stats"() IS 'Returns statistics on auto-approved pages';



CREATE OR REPLACE FUNCTION "public"."get_business_state_summary"() RETURNS "jsonb"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    result JSONB;
BEGIN
    SELECT jsonb_build_object(
        'total_decisions', (SELECT COUNT(*) FROM decisions),
        'pending_decisions', (SELECT COUNT(*) FROM decisions WHERE status = 'pending'),
        'in_progress_decisions', (SELECT COUNT(*) FROM decisions WHERE status = 'in_progress'),
        'completed_decisions', (SELECT COUNT(*) FROM decisions WHERE status = 'completed'),
        'avg_confidence', (SELECT ROUND(AVG(confidence_score)::numeric, 2) FROM decisions WHERE status = 'pending'),
        'high_priority_pending', (SELECT COUNT(*) FROM decisions WHERE status = 'pending' AND priority = 'high'),
        'categories', (
            SELECT jsonb_object_agg(category, count)
            FROM (
                SELECT category, COUNT(*) as count
                FROM decisions
                WHERE status IN ('pending', 'in_progress')
                GROUP BY category
            ) cat_counts
        ),
        'last_updated', NOW()
    ) INTO result;
    
    RETURN result;
END;
$$;


ALTER FUNCTION "public"."get_business_state_summary"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_business_state_summary"() IS 'Returns current business decision state summary';



CREATE OR REPLACE FUNCTION "public"."get_calendar_events"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_project_code" "text" DEFAULT NULL::"text", "p_calendar_id" "text" DEFAULT NULL::"text", "p_limit" integer DEFAULT 100) RETURNS TABLE("id" "uuid", "google_event_id" "text", "title" "text", "description" "text", "start_time" timestamp with time zone, "end_time" timestamp with time zone, "location" "text", "event_type" "text", "project_code" "text", "attendee_count" integer, "calendar_name" "text", "calendar_color" "text")
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    ce.id,
    ce.google_event_id,
    ce.title,
    ce.description,
    ce.start_time,
    ce.end_time,
    ce.location,
    ce.event_type,
    ce.project_code,
    jsonb_array_length(ce.attendees)::INTEGER as attendee_count,
    ce.calendar_name,
    ce.calendar_color
  FROM calendar_events ce
  WHERE ce.status != 'cancelled'
    AND ce.start_time >= p_start_date
    AND ce.start_time < p_end_date
    AND (p_project_code IS NULL OR ce.project_code = p_project_code)
    AND (p_calendar_id IS NULL OR ce.google_calendar_id = p_calendar_id)
  ORDER BY ce.start_time ASC
  LIMIT p_limit;
END;
$$;


ALTER FUNCTION "public"."get_calendar_events"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_project_code" "text", "p_calendar_id" "text", "p_limit" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_calendar_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) RETURNS TABLE("total_events" integer, "total_hours" numeric, "events_by_type" "jsonb", "events_by_project" "jsonb", "top_attendees" "jsonb")
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  WITH event_data AS (
    SELECT
      ce.*,
      EXTRACT(EPOCH FROM (ce.end_time - ce.start_time))/3600 as duration_hours
    FROM calendar_events ce
    WHERE ce.status != 'cancelled'
      AND ce.start_time >= p_start_date
      AND ce.start_time < p_end_date
  ),
  type_stats AS (
    SELECT jsonb_object_agg(
      COALESCE(event_type, 'unknown'),
      cnt
    ) as stats
    FROM (
      SELECT event_type, COUNT(*) as cnt
      FROM event_data
      GROUP BY event_type
    ) t
  ),
  project_stats AS (
    SELECT jsonb_object_agg(
      COALESCE(project_code, 'unlinked'),
      cnt
    ) as stats
    FROM (
      SELECT project_code, COUNT(*) as cnt
      FROM event_data
      WHERE project_code IS NOT NULL
      GROUP BY project_code
    ) t
  ),
  attendee_stats AS (
    SELECT jsonb_agg(jsonb_build_object(
      'email', att->>'email',
      'count', att_count
    ) ORDER BY att_count DESC) as stats
    FROM (
      SELECT att, COUNT(*) as att_count
      FROM event_data, jsonb_array_elements(attendees) att
      GROUP BY att
      ORDER BY att_count DESC
      LIMIT 10
    ) t
  )
  SELECT
    COUNT(*)::INTEGER as total_events,
    COALESCE(SUM(duration_hours), 0)::NUMERIC as total_hours,
    COALESCE((SELECT stats FROM type_stats), '{}'::JSONB) as events_by_type,
    COALESCE((SELECT stats FROM project_stats), '{}'::JSONB) as events_by_project,
    COALESCE((SELECT stats FROM attendee_stats), '[]'::JSONB) as top_attendees
  FROM event_data;
END;
$$;


ALTER FUNCTION "public"."get_calendar_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_contacts_needing_attention"("days_threshold" integer DEFAULT 14) RETURNS TABLE("ghl_contact_id" "text", "last_communication" timestamp with time zone, "days_since_contact" integer, "total_communications" bigint, "last_direction" "text")
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  WITH last_comms AS (
    SELECT
      cc.ghl_contact_id,
      MAX(cc.occurred_at) AS last_communication,
      COUNT(*)::BIGINT AS total_communications,
      (SELECT direction FROM contact_communications cc2
       WHERE cc2.ghl_contact_id = cc.ghl_contact_id
       ORDER BY cc2.occurred_at DESC LIMIT 1) AS last_direction
    FROM contact_communications cc
    GROUP BY cc.ghl_contact_id
  )
  SELECT
    lc.ghl_contact_id,
    lc.last_communication,
    EXTRACT(DAY FROM NOW() - lc.last_communication)::INT AS days_since_contact,
    lc.total_communications,
    lc.last_direction
  FROM last_comms lc
  WHERE lc.last_communication < NOW() - (days_threshold || ' days')::INTERVAL
  ORDER BY lc.last_communication ASC;
END;
$$;


ALTER FUNCTION "public"."get_contacts_needing_attention"("days_threshold" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_contacts_needing_attention"("days_threshold" integer) IS 'Returns contacts who have not been contacted within the threshold days';



CREATE OR REPLACE FUNCTION "public"."get_cost_summary"("p_start_date" "date" DEFAULT (CURRENT_DATE - '30 days'::interval), "p_end_date" "date" DEFAULT CURRENT_DATE) RETURNS TABLE("provider" "text", "model" "text", "total_calls" bigint, "total_tokens" bigint, "cache_hits" bigint, "cache_hit_rate" numeric, "total_cost" numeric, "avg_latency_ms" integer)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        u.provider,
        u.model,
        COUNT(*) as total_calls,
        SUM(u.total_tokens)::BIGINT as total_tokens,
        SUM(CASE WHEN u.cache_hit THEN 1 ELSE 0 END)::BIGINT as cache_hits,
        ROUND(100.0 * SUM(CASE WHEN u.cache_hit THEN 1 ELSE 0 END) / NULLIF(COUNT(*), 0), 2) as cache_hit_rate,
        ROUND(SUM(COALESCE(u.estimated_cost, 0))::DECIMAL, 2) as total_cost,
        AVG(u.latency_ms)::INT as avg_latency_ms
    FROM api_usage u
    WHERE u.timestamp::DATE BETWEEN p_start_date AND p_end_date
    GROUP BY u.provider, u.model
    ORDER BY total_cost DESC;
END;
$$;


ALTER FUNCTION "public"."get_cost_summary"("p_start_date" "date", "p_end_date" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_cost_summary"("p_start_date" "date", "p_end_date" "date") IS 'Get cost summary by provider and model for a date range';



CREATE OR REPLACE FUNCTION "public"."get_current_platform_organization_id"() RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN COALESCE(
        current_setting('app.current_platform_organization_id', true)::UUID,
        -- Fallback to ACT for development/trial
        (SELECT id FROM platform_organizations WHERE slug = 'act' LIMIT 1)
    );
END;
$$;


ALTER FUNCTION "public"."get_current_platform_organization_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_decision_quality_metrics"("p_agent_id" "text" DEFAULT NULL::"text", "p_decision_type" "text" DEFAULT NULL::"text", "p_days" integer DEFAULT 30) RETURNS TABLE("agent_id" "text", "decision_type" "text", "total_decisions" bigint, "with_feedback" bigint, "correct_decisions" bigint, "incorrect_decisions" bigint, "accuracy_rate" numeric, "avg_confidence" numeric, "confidence_calibration" numeric)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        dt.agent_id,
        dt.decision_type,
        COUNT(*) as total_decisions,
        COUNT(*) FILTER (WHERE dt.human_feedback IS NOT NULL) as with_feedback,
        COUNT(*) FILTER (WHERE dt.human_feedback = 'correct') as correct_decisions,
        COUNT(*) FILTER (WHERE dt.human_feedback = 'incorrect') as incorrect_decisions,
        ROUND(
            100.0 * COUNT(*) FILTER (WHERE dt.human_feedback = 'correct') /
            NULLIF(COUNT(*) FILTER (WHERE dt.human_feedback IS NOT NULL), 0),
            2
        ) as accuracy_rate,
        AVG(dt.confidence)::DECIMAL(3,2) as avg_confidence,
        -- Calibration: difference between confidence and actual accuracy
        ABS(
            AVG(dt.confidence) -
            (COUNT(*) FILTER (WHERE dt.human_feedback = 'correct')::DECIMAL /
             NULLIF(COUNT(*) FILTER (WHERE dt.human_feedback IS NOT NULL), 0))
        )::DECIMAL(5,2) as confidence_calibration
    FROM decision_traces dt
    WHERE dt.timestamp > NOW() - (p_days || ' days')::INTERVAL
      AND (p_agent_id IS NULL OR dt.agent_id = p_agent_id)
      AND (p_decision_type IS NULL OR dt.decision_type = p_decision_type)
    GROUP BY dt.agent_id, dt.decision_type
    ORDER BY total_decisions DESC;
END;
$$;


ALTER FUNCTION "public"."get_decision_quality_metrics"("p_agent_id" "text", "p_decision_type" "text", "p_days" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_decision_quality_metrics"("p_agent_id" "text", "p_decision_type" "text", "p_days" integer) IS 'Get accuracy and calibration metrics for decisions';



CREATE OR REPLACE FUNCTION "public"."get_decision_recommendations"("limit_count" integer DEFAULT 5) RETURNS TABLE("decision_id" "uuid", "title" "text", "priority" "text", "confidence_score" numeric, "ai_recommendation" "text", "days_pending" integer)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        d.id,
        d.title,
        d.priority,
        d.confidence_score,
        d.ai_recommendation,
        EXTRACT(DAYS FROM NOW() - d.created_at)::INTEGER as days_pending
    FROM decisions d
    WHERE d.status = 'pending'
    AND d.ai_recommendation IS NOT NULL
    ORDER BY 
        CASE d.priority 
            WHEN 'urgent' THEN 1
            WHEN 'high' THEN 2
            WHEN 'medium' THEN 3
            WHEN 'low' THEN 4
        END,
        d.created_at
    LIMIT limit_count;
END;
$$;


ALTER FUNCTION "public"."get_decision_recommendations"("limit_count" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_decision_recommendations"("limit_count" integer) IS 'Returns prioritized decision recommendations';



CREATE OR REPLACE FUNCTION "public"."get_entity_by_identifier"("identifier" "text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  entity_uuid UUID;
BEGIN
  -- Try email first
  SELECT id INTO entity_uuid FROM entities WHERE primary_email = lower(identifier);
  IF entity_uuid IS NOT NULL THEN
    RETURN entity_uuid;
  END IF;

  -- Try source mappings
  SELECT entity_id INTO entity_uuid FROM entity_mappings WHERE source_id = identifier;
  RETURN entity_uuid;
END;
$$;


ALTER FUNCTION "public"."get_entity_by_identifier"("identifier" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_entity_by_identifier"("identifier" "text") IS 'Lookup entity by email or source system ID';



CREATE OR REPLACE FUNCTION "public"."get_gmail_accounts_for_sync"() RETURNS TABLE("account_id" "uuid", "user_email" "text", "last_sync_at" timestamp with time zone, "last_history_id" "text")
    LANGUAGE "sql"
    AS $$
  SELECT
    t.id as account_id,
    t.user_email,
    s.last_sync_at,
    s.last_history_id
  FROM gmail_auth_tokens t
  LEFT JOIN gmail_sync_state s ON s.account_id = t.id
  WHERE t.refresh_token IS NOT NULL  -- Has valid refresh token
  ORDER BY COALESCE(s.last_sync_at, '1970-01-01'::timestamptz) ASC;
$$;


ALTER FUNCTION "public"."get_gmail_accounts_for_sync"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_gmail_accounts_for_sync"() IS 'Returns Gmail accounts ready for sync';



CREATE OR REPLACE FUNCTION "public"."get_hero_image"("p_link_type" "text", "p_link_id" "text") RETURNS TABLE("id" "uuid", "file_url" "text", "thumbnail_url" "text", "title" "text", "alt_text" "text", "blurhash" "text")
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    m.id,
    m.file_url,
    COALESCE(m.thumbnail_url, '') as thumbnail_url,
    COALESCE(m.title, '') as title,
    COALESCE(pml.alt_text, m.alt_text, '') as alt_text,
    COALESCE(m.blurhash, '') as blurhash
  FROM media_items m
  INNER JOIN project_media_links pml ON m.id = pml.media_id
  WHERE pml.link_type = p_link_type
    AND pml.link_id = p_link_id
    AND pml.is_hero = true
  ORDER BY m.created_at DESC
  LIMIT 1;
END;
$$;


ALTER FUNCTION "public"."get_hero_image"("p_link_type" "text", "p_link_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_intervention_comprehensive"("p_intervention_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  result JSONB;
BEGIN
  SELECT jsonb_build_object(
    'intervention', row_to_json(i),
    'evidence', COALESCE((
      SELECT jsonb_agg(row_to_json(e))
      FROM alma_intervention_evidence ie
      JOIN alma_evidence e ON e.id = ie.evidence_id
      WHERE ie.intervention_id = p_intervention_id
    ), '[]'::JSONB),
    'outcomes', COALESCE((
      SELECT jsonb_agg(row_to_json(o))
      FROM alma_intervention_outcomes io
      JOIN alma_outcomes o ON o.id = io.outcome_id
      WHERE io.intervention_id = p_intervention_id
    ), '[]'::JSONB),
    'contexts', COALESCE((
      SELECT jsonb_agg(row_to_json(c))
      FROM alma_intervention_contexts ic
      JOIN alma_contexts c ON c.id = ic.context_id
      WHERE ic.intervention_id = p_intervention_id
    ), '[]'::JSONB),
    'related_articles', COALESCE((
      SELECT jsonb_agg(jsonb_build_object(
        'title', a.title,
        'content_type', a.content_type,
        'slug', a.slug
      ))
      FROM article_related_interventions ari
      JOIN articles a ON a.id = ari.article_id
      WHERE ari.intervention_id = p_intervention_id
    ), '[]'::JSONB)
  ) INTO result
  FROM alma_interventions i
  WHERE i.id = p_intervention_id;

  RETURN result;
END;
$$;


ALTER FUNCTION "public"."get_intervention_comprehensive"("p_intervention_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_jurisdiction_stats"("p_jurisdiction" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  result JSONB;
BEGIN
  SELECT jsonb_build_object(
    'jurisdiction', p_jurisdiction,
    'intervention_count', (
      SELECT COUNT(*) FROM alma_interventions
      WHERE geography = p_jurisdiction AND consent_level = 'Public Knowledge Commons'
    ),
    'intervention_types', (
      SELECT jsonb_object_agg(type, cnt)
      FROM (
        SELECT type, COUNT(*) as cnt
        FROM alma_interventions
        WHERE geography = p_jurisdiction AND consent_level = 'Public Knowledge Commons'
        GROUP BY type
      ) sub
    ),
    'evidence_levels', (
      SELECT jsonb_object_agg(COALESCE(evidence_level, 'Unknown'), cnt)
      FROM (
        SELECT evidence_level, COUNT(*) as cnt
        FROM alma_interventions
        WHERE geography = p_jurisdiction AND consent_level = 'Public Knowledge Commons'
        GROUP BY evidence_level
      ) sub
    ),
    'total_evidence_links', (
      SELECT COUNT(*)
      FROM alma_intervention_evidence ie
      JOIN alma_interventions i ON i.id = ie.intervention_id
      WHERE i.geography = p_jurisdiction
    ),
    'total_outcome_links', (
      SELECT COUNT(*)
      FROM alma_intervention_outcomes io
      JOIN alma_interventions i ON i.id = io.intervention_id
      WHERE i.geography = p_jurisdiction
    )
  ) INTO result;

  RETURN result;
END;
$$;


ALTER FUNCTION "public"."get_jurisdiction_stats"("p_jurisdiction" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_location_id_by_name"("location_name" "text") RETURNS "uuid"
    LANGUAGE "sql" STABLE
    AS $$
  SELECT id FROM locations WHERE name = location_name LIMIT 1;
$$;


ALTER FUNCTION "public"."get_location_id_by_name"("location_name" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_next_exa_batch"("p_batch_size" integer DEFAULT 10, "p_campaign_type" "text" DEFAULT NULL::"text") RETURNS TABLE("queue_id" "uuid", "person_id" "uuid", "person_name" "text", "person_email" "text", "current_company" "text", "campaign_type" "text", "priority" integer, "enrich_linkedin" boolean, "enrich_company" boolean, "enrich_media" boolean, "enrich_network" boolean)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    eq.id AS queue_id,
    eq.person_id,
    pim.full_name AS person_name,
    pim.email AS person_email,
    pim.current_company,
    eq.campaign_type,
    eq.priority,
    eq.enrich_linkedin,
    eq.enrich_company,
    eq.enrich_media,
    eq.enrich_network
  FROM exa_enrichment_queue eq
  JOIN person_identity_map pim ON eq.person_id = pim.person_id
  WHERE eq.status = 'pending'
    AND (p_campaign_type IS NULL OR eq.campaign_type = p_campaign_type)
    AND eq.retry_count < 3
  ORDER BY eq.priority DESC, eq.queued_at
  LIMIT p_batch_size;
END;
$$;


ALTER FUNCTION "public"."get_next_exa_batch"("p_batch_size" integer, "p_campaign_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_pending_enrichments"("p_project_slug" "text" DEFAULT NULL::"text") RETURNS TABLE("id" "uuid", "project_slug" "text", "project_title" "text", "enrichment_type" "text", "ai_generated" "jsonb", "original_data" "jsonb", "confidence" numeric, "reasoning" "text", "created_at" timestamp with time zone)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    e.id,
    e.project_slug,
    e.project_title,
    e.enrichment_type,
    e.ai_generated,
    e.original_data,
    e.confidence,
    e.reasoning,
    e.created_at
  FROM enrichment_reviews e
  WHERE e.status = 'pending'
    AND (p_project_slug IS NULL OR e.project_slug = p_project_slug)
  ORDER BY e.created_at ASC;
END;
$$;


ALTER FUNCTION "public"."get_pending_enrichments"("p_project_slug" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_pending_sync_events"("batch_size" integer DEFAULT 10, "target_filter" "text" DEFAULT NULL::"text") RETURNS TABLE("id" "uuid", "event_type" "text", "table_name" "text", "record_id" "uuid", "operation_data" "jsonb", "sync_target" "text", "priority" integer, "created_at" timestamp with time zone, "retry_count" integer)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        e.id,
        e.event_type,
        e.table_name,
        e.record_id,
        e.operation_data,
        e.sync_target,
        e.priority,
        e.created_at,
        e.retry_count
    FROM sync_events e
    WHERE 
        e.sync_status = 'pending'
        AND e.retry_count < e.max_retries
        AND (target_filter IS NULL OR e.sync_target = target_filter OR e.sync_target = 'both')
    ORDER BY 
        e.priority ASC,
        e.created_at ASC
    LIMIT batch_size;
END;
$$;


ALTER FUNCTION "public"."get_pending_sync_events"("batch_size" integer, "target_filter" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_pending_sync_events"("batch_size" integer, "target_filter" "text") IS 'Get pending sync events for processing';



CREATE OR REPLACE FUNCTION "public"."get_project_context"("p_project_code" "text", "p_days" integer DEFAULT 30) RETURNS TABLE("id" "uuid", "knowledge_type" "text", "title" "text", "content" "text", "summary" "text", "recorded_at" timestamp with time zone, "importance" "text", "decision_status" "text")
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    cutoff_date TIMESTAMPTZ;
BEGIN
    cutoff_date := NOW() - (p_days || ' days')::INTERVAL;

    RETURN QUERY
    -- Recent items
    SELECT
        pk.id,
        pk.knowledge_type,
        pk.title,
        pk.content,
        pk.summary,
        pk.recorded_at,
        pk.importance,
        pk.decision_status
    FROM project_knowledge pk
    WHERE pk.project_code = p_project_code
    AND (pk.recorded_at >= cutoff_date OR pk.importance IN ('critical', 'high'))
    ORDER BY
        CASE pk.importance
            WHEN 'critical' THEN 1
            WHEN 'high' THEN 2
            ELSE 3
        END,
        pk.recorded_at DESC
    LIMIT 25;
END;
$$;


ALTER FUNCTION "public"."get_project_context"("p_project_code" "text", "p_days" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_project_media"("p_link_type" "text", "p_link_id" "text") RETURNS TABLE("id" "uuid", "file_url" "text", "thumbnail_url" "text", "file_type" "text", "title" "text", "description" "text", "alt_text" "text", "caption" "text", "credit" "text", "width" integer, "height" integer, "blurhash" "text", "display_order" integer, "is_hero" boolean, "is_featured" boolean)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    m.id,
    m.file_url,
    COALESCE(m.thumbnail_url, '') as thumbnail_url,
    m.file_type,
    COALESCE(m.title, '') as title,
    COALESCE(m.description, '') as description,
    COALESCE(pml.alt_text, m.alt_text, '') as alt_text,
    COALESCE(pml.caption, m.caption, '') as caption,
    COALESCE(m.credit, '') as credit,
    COALESCE(m.width, 0) as width,
    COALESCE(m.height, 0) as height,
    COALESCE(m.blurhash, '') as blurhash,
    COALESCE(pml.display_order, 0) as display_order,
    COALESCE(pml.is_hero, false) as is_hero,
    COALESCE(pml.is_featured, false) as is_featured
  FROM media_items m
  INNER JOIN project_media_links pml ON m.id = pml.media_id
  WHERE pml.link_type = p_link_type
    AND pml.link_id = p_link_id
  ORDER BY pml.is_hero DESC, pml.display_order ASC, m.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_project_media"("p_link_type" "text", "p_link_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_project_timeline"("p_project_code" "text", "p_limit" integer DEFAULT 50, "p_types" "text"[] DEFAULT NULL::"text"[]) RETURNS TABLE("id" "uuid", "knowledge_type" "text", "title" "text", "content" "text", "summary" "text", "recorded_at" timestamp with time zone, "participants" "text"[], "importance" "text", "action_required" boolean)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        pk.id,
        pk.knowledge_type,
        pk.title,
        pk.content,
        pk.summary,
        pk.recorded_at,
        pk.participants,
        pk.importance,
        pk.action_required
    FROM project_knowledge pk
    WHERE pk.project_code = p_project_code
    AND (p_types IS NULL OR pk.knowledge_type = ANY(p_types))
    ORDER BY pk.recorded_at DESC
    LIMIT p_limit;
END;
$$;


ALTER FUNCTION "public"."get_project_timeline"("p_project_code" "text", "p_limit" integer, "p_types" "text"[]) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_roles_by_category"("p_category" "text" DEFAULT NULL::"text") RETURNS TABLE("id" "text", "category" "text", "display_name" "text", "description" "text", "display_order" integer)
    LANGUAGE "sql" STABLE
    AS $$
  SELECT id, category, display_name, description, display_order
  FROM role_taxonomy
  WHERE is_active = true
    AND (p_category IS NULL OR category = p_category)
  ORDER BY display_order, display_name;
$$;


ALTER FUNCTION "public"."get_roles_by_category"("p_category" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_stories_needing_analysis"() RETURNS TABLE("story_id" "uuid", "title" "text", "created_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        s.id as story_id,
        s.title,
        s.created_at
    FROM stories s
    LEFT JOIN story_analysis sa ON s.id = sa.story_id
    WHERE sa.id IS NULL
        AND s.status = 'published' -- Only analyze published stories
    ORDER BY s.created_at DESC
    LIMIT 50;
END;
$$;


ALTER FUNCTION "public"."get_stories_needing_analysis"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_storytellers_needing_analysis"() RETURNS TABLE("storyteller_id" "uuid", "full_name" "text", "created_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    s.id as storyteller_id,
    s.full_name,
    s.created_at
  FROM storytellers s
  LEFT JOIN story_analysis sa ON s.id = sa.storyteller_id
  WHERE sa.id IS NULL
  ORDER BY s.created_at DESC
  LIMIT 20;
END;
$$;


ALTER FUNCTION "public"."get_storytellers_needing_analysis"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_sub_task_results"("p_parent_id" "uuid") RETURNS TABLE("sub_task_id" "uuid", "target_agent" "text", "action_name" "text", "status" "text", "result" "jsonb", "error" "text", "completed_at" timestamp with time zone)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    p.id as sub_task_id,
    p.target_agent_id as target_agent,
    p.action_name,
    p.status,
    p.execution_result as result,
    p.execution_error as error,
    p.execution_completed_at as completed_at
  FROM agent_proposals p
  WHERE p.parent_proposal_id = p_parent_id
  ORDER BY p.created_at;
END;
$$;


ALTER FUNCTION "public"."get_sub_task_results"("p_parent_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_transcript_analysis_for_story"("p_story_id" "uuid") RETURNS TABLE("themes" "text"[], "emotions" "text"[], "quotes" "text"[], "summary" "text", "insights" "text"[])
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ta.themes_identified as themes,
        ta.primary_emotions as emotions,
        ta.key_quotes as quotes,
        ta.summary,
        ta.insights
    FROM stories s
    JOIN transcript_analysis ta ON s.transcript_id = ta.transcript_id
    WHERE s.id = p_story_id
    LIMIT 1;
END;
$$;


ALTER FUNCTION "public"."get_transcript_analysis_for_story"("p_story_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_unified_services_stats"() RETURNS TABLE("total_count" bigint, "with_coordinates" bigint, "from_services" bigint, "from_alma" bigint, "from_community_programs" bigint, "indigenous_specific" bigint, "youth_specific" bigint, "by_state" "jsonb")
    LANGUAGE "sql" STABLE
    AS $$
  SELECT
    COUNT(*) AS total_count,
    COUNT(*) FILTER (WHERE latitude IS NOT NULL) AS with_coordinates,
    COUNT(*) FILTER (WHERE source_table = 'services') AS from_services,
    COUNT(*) FILTER (WHERE source_table = 'alma_interventions') AS from_alma,
    COUNT(*) FILTER (WHERE source_table = 'community_programs') AS from_community_programs,
    COUNT(*) FILTER (WHERE indigenous_specific = TRUE) AS indigenous_specific,
    COUNT(*) FILTER (WHERE youth_specific = TRUE) AS youth_specific,
    (
      SELECT jsonb_object_agg(state, cnt)
      FROM (
        SELECT COALESCE(state, 'Unknown') AS state, COUNT(*) AS cnt
        FROM services_unified
        GROUP BY state
        ORDER BY cnt DESC
      ) sub
    ) AS by_state
  FROM services_unified;
$$;


ALTER FUNCTION "public"."get_unified_services_stats"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_week_start"("p_date" "date" DEFAULT CURRENT_DATE) RETURNS "date"
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
BEGIN
  RETURN p_date - (EXTRACT(DOW FROM p_date)::INTEGER + 6) % 7;
END;
$$;


ALTER FUNCTION "public"."get_week_start"("p_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  INSERT INTO public.profiles (id, email, display_name, full_name)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'display_name', split_part(NEW.email, '@', 1)),
    NEW.raw_user_meta_data->>'full_name'
  );
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."increment_clicks"("portrait_uuid" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
begin
  update portraits set clicks = clicks + 1, updated_at = now() where id = portrait_uuid;
end;
$$;


ALTER FUNCTION "public"."increment_clicks"("portrait_uuid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."increment_communities_joined"("p_user_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  -- Placeholder function - could update communities count if needed
  NULL;
END;
$$;


ALTER FUNCTION "public"."increment_communities_joined"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."increment_stories_contributed"("p_user_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  -- Update the user's contribution count in storytellers table
  UPDATE storytellers
  SET stories_created_count = COALESCE(stories_created_count, 0) + 1
  WHERE user_id = p_user_id;
END;
$$;


ALTER FUNCTION "public"."increment_stories_contributed"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."increment_views"("portrait_uuid" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
begin
  update portraits set views = views + 1, updated_at = now() where id = portrait_uuid;
end;
$$;


ALTER FUNCTION "public"."increment_views"("portrait_uuid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."insert_community_programs_profile"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  INSERT INTO registered_services_profiles (
    program_id,
    public_profile_id,
    role,
    role_description,
    display_order,
    is_featured
  ) VALUES (
    COALESCE(NEW.community_program_id, NEW.program_id),
    COALESCE(NEW.profile_id, NEW.public_profile_id),
    NEW.role,
    NEW.role_description,
    NEW.display_order,
    NEW.is_featured
  )
  RETURNING * INTO NEW;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."insert_community_programs_profile"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_admin"() RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM public.users
    WHERE id = auth.uid()
    AND role = 'platform_admin'
  );
END;
$$;


ALTER FUNCTION "public"."is_admin"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."jsonb_object_keys_count"("j" "jsonb") RETURNS integer
    LANGUAGE "sql" IMMUTABLE
    AS $$
    SELECT COUNT(*)::INT FROM jsonb_object_keys(j);
$$;


ALTER FUNCTION "public"."jsonb_object_keys_count"("j" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_agent_action"("p_agent_id" "text", "p_action" "text", "p_target_table" "text" DEFAULT NULL::"text", "p_target_id" "text" DEFAULT NULL::"text", "p_success" boolean DEFAULT true, "p_duration_ms" integer DEFAULT NULL::integer, "p_error_message" "text" DEFAULT NULL::"text", "p_input_summary" "jsonb" DEFAULT NULL::"jsonb", "p_output_summary" "jsonb" DEFAULT NULL::"jsonb", "p_user_context" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_id UUID;
BEGIN
    INSERT INTO agent_audit_log (
        agent_id, action, target_table, target_id,
        success, duration_ms, error_message,
        input_summary, output_summary, user_context
    ) VALUES (
        p_agent_id, p_action, p_target_table, p_target_id,
        p_success, p_duration_ms, p_error_message,
        p_input_summary, p_output_summary, p_user_context
    )
    RETURNING id INTO v_id;

    RETURN v_id;
END;
$$;


ALTER FUNCTION "public"."log_agent_action"("p_agent_id" "text", "p_action" "text", "p_target_table" "text", "p_target_id" "text", "p_success" boolean, "p_duration_ms" integer, "p_error_message" "text", "p_input_summary" "jsonb", "p_output_summary" "jsonb", "p_user_context" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."log_agent_action"("p_agent_id" "text", "p_action" "text", "p_target_table" "text", "p_target_id" "text", "p_success" boolean, "p_duration_ms" integer, "p_error_message" "text", "p_input_summary" "jsonb", "p_output_summary" "jsonb", "p_user_context" "text") IS 'Simplified function to log agent actions from scripts';



CREATE OR REPLACE FUNCTION "public"."log_alma_usage"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text", "p_query_text" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  INSERT INTO alma_usage_log (
    entity_type,
    entity_id,
    action,
    user_id,
    query_text
  ) VALUES (
    p_entity_type,
    p_entity_id,
    p_action,
    auth.uid(),
    p_query_text
  );
END;
$$;


ALTER FUNCTION "public"."log_alma_usage"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text", "p_query_text" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."log_alma_usage"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text", "p_query_text" "text") IS 'Log all ALMA entity access for attribution and revenue sharing';



CREATE OR REPLACE FUNCTION "public"."log_api_usage"("p_provider" "text", "p_model" "text", "p_endpoint" "text", "p_input_tokens" integer, "p_output_tokens" integer, "p_script_name" "text" DEFAULT NULL::"text", "p_cache_hit" boolean DEFAULT false, "p_latency_ms" integer DEFAULT NULL::integer, "p_agent_id" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_id UUID;
    v_cost DECIMAL(10,6);
BEGIN
    v_cost := calculate_api_cost(p_provider, p_model, p_endpoint, p_input_tokens, p_output_tokens);

    INSERT INTO api_usage (
        provider, model, endpoint,
        input_tokens, output_tokens, estimated_cost,
        script_name, cache_hit, latency_ms, agent_id
    ) VALUES (
        p_provider, p_model, p_endpoint,
        p_input_tokens, p_output_tokens, v_cost,
        p_script_name, p_cache_hit, p_latency_ms, p_agent_id
    )
    RETURNING id INTO v_id;

    RETURN v_id;
END;
$$;


ALTER FUNCTION "public"."log_api_usage"("p_provider" "text", "p_model" "text", "p_endpoint" "text", "p_input_tokens" integer, "p_output_tokens" integer, "p_script_name" "text", "p_cache_hit" boolean, "p_latency_ms" integer, "p_agent_id" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."log_api_usage"("p_provider" "text", "p_model" "text", "p_endpoint" "text", "p_input_tokens" integer, "p_output_tokens" integer, "p_script_name" "text", "p_cache_hit" boolean, "p_latency_ms" integer, "p_agent_id" "text") IS 'Log an API call with automatic cost calculation';



CREATE OR REPLACE FUNCTION "public"."log_decision_trace"("p_decision_type" "text", "p_agent_id" "text", "p_input_context" "jsonb", "p_decision" "jsonb", "p_reasoning" "text" DEFAULT NULL::"text", "p_confidence" numeric DEFAULT NULL::numeric, "p_retrieved_context" "jsonb" DEFAULT NULL::"jsonb", "p_alternatives" "jsonb" DEFAULT NULL::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_id UUID;
BEGIN
    INSERT INTO decision_traces (
        decision_type, agent_id, input_context, decision,
        reasoning, confidence, retrieved_context, alternatives_considered,
        decision_summary
    ) VALUES (
        p_decision_type, p_agent_id, p_input_context, p_decision,
        p_reasoning, p_confidence, p_retrieved_context, p_alternatives,
        COALESCE(p_decision->>'summary', p_decision_type || ' decision')
    )
    RETURNING id INTO v_id;

    RETURN v_id;
END;
$$;


ALTER FUNCTION "public"."log_decision_trace"("p_decision_type" "text", "p_agent_id" "text", "p_input_context" "jsonb", "p_decision" "jsonb", "p_reasoning" "text", "p_confidence" numeric, "p_retrieved_context" "jsonb", "p_alternatives" "jsonb") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."log_decision_trace"("p_decision_type" "text", "p_agent_id" "text", "p_input_context" "jsonb", "p_decision" "jsonb", "p_reasoning" "text", "p_confidence" numeric, "p_retrieved_context" "jsonb", "p_alternatives" "jsonb") IS 'Log a decision with input, output, and optional reasoning';



CREATE OR REPLACE FUNCTION "public"."log_goal_update"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF OLD.title IS DISTINCT FROM NEW.title THEN
    INSERT INTO goal_updates (goal_id, field_changed, old_value, new_value, source, updated_by)
    VALUES (NEW.id, 'title', OLD.title, NEW.title, COALESCE(NEW.last_update_source, 'unknown'), NEW.last_updated_by);
  END IF;
  IF OLD.status IS DISTINCT FROM NEW.status THEN
    INSERT INTO goal_updates (goal_id, field_changed, old_value, new_value, source, updated_by)
    VALUES (NEW.id, 'status', OLD.status, NEW.status, COALESCE(NEW.last_update_source, 'unknown'), NEW.last_updated_by);
  END IF;
  IF OLD.progress_percentage IS DISTINCT FROM NEW.progress_percentage THEN
    INSERT INTO goal_updates (goal_id, field_changed, old_value, new_value, source, updated_by)
    VALUES (NEW.id, 'progress_percentage', OLD.progress_percentage::TEXT, NEW.progress_percentage::TEXT, COALESCE(NEW.last_update_source, 'unknown'), NEW.last_updated_by);
  END IF;
  IF OLD.lane IS DISTINCT FROM NEW.lane THEN
    INSERT INTO goal_updates (goal_id, field_changed, old_value, new_value, source, updated_by)
    VALUES (NEW.id, 'lane', OLD.lane, NEW.lane, COALESCE(NEW.last_update_source, 'unknown'), NEW.last_updated_by);
  END IF;
  IF OLD.key_results IS DISTINCT FROM NEW.key_results THEN
    INSERT INTO goal_updates (goal_id, field_changed, old_value, new_value, source, updated_by)
    VALUES (NEW.id, 'key_results', OLD.key_results, NEW.key_results, COALESCE(NEW.last_update_source, 'unknown'), NEW.last_updated_by);
  END IF;
  IF OLD.owner IS DISTINCT FROM NEW.owner THEN
    INSERT INTO goal_updates (goal_id, field_changed, old_value, new_value, source, updated_by)
    VALUES (NEW.id, 'owner', OLD.owner::TEXT, NEW.owner::TEXT, COALESCE(NEW.last_update_source, 'unknown'), NEW.last_updated_by);
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."log_goal_update"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_research_tool"("p_session_id" "uuid", "p_tool_name" "text", "p_tool_input" "jsonb", "p_tool_output" "jsonb", "p_execution_time_ms" integer, "p_success" boolean, "p_error_message" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_log_id UUID;
BEGIN
  INSERT INTO alma_research_tool_logs (
    session_id, tool_name, tool_input, tool_output,
    execution_time_ms, success, error_message
  )
  VALUES (
    p_session_id, p_tool_name, p_tool_input, p_tool_output,
    p_execution_time_ms, p_success, p_error_message
  )
  RETURNING id INTO v_log_id;

  RETURN v_log_id;
END;
$$;


ALTER FUNCTION "public"."log_research_tool"("p_session_id" "uuid", "p_tool_name" "text", "p_tool_input" "jsonb", "p_tool_output" "jsonb", "p_execution_time_ms" integer, "p_success" boolean, "p_error_message" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mark_service_verified"("service_id_param" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  UPDATE services
  SET
    last_verified_at = NOW(),
    verification_status = 'verified'
  WHERE id = service_id_param;
END;
$$;


ALTER FUNCTION "public"."mark_service_verified"("service_id_param" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mark_task_for_review"("p_task_id" "uuid", "p_output" "jsonb", "p_reasoning" "text" DEFAULT NULL::"text", "p_confidence" numeric DEFAULT NULL::numeric) RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  UPDATE agent_task_queue
  SET status = 'review',
      needs_review = TRUE,
      output = p_output,
      reasoning = p_reasoning,
      confidence = p_confidence,
      updated_at = NOW()
  WHERE id = p_task_id;
END;
$$;


ALTER FUNCTION "public"."mark_task_for_review"("p_task_id" "uuid", "p_output" "jsonb", "p_reasoning" "text", "p_confidence" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."match_knowledge_chunks"("query_embedding" "public"."vector", "match_threshold" double precision DEFAULT 0.7, "match_count" integer DEFAULT 10, "filter_source_type" "text" DEFAULT NULL::"text", "filter_project_id" "text" DEFAULT NULL::"text") RETURNS TABLE("id" "uuid", "content" "text", "source_type" "text", "source_id" "text", "project_id" "text", "file_path" "text", "metadata" "jsonb", "confidence" double precision, "similarity" double precision)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    kc.id,
    kc.content,
    kc.source_type,
    kc.source_id,
    kc.project_id,
    kc.file_path,
    kc.metadata,
    kc.confidence,
    1 - (kc.embedding <=> query_embedding) AS similarity
  FROM knowledge_chunks kc
  WHERE
    (filter_source_type IS NULL OR kc.source_type = filter_source_type)
    AND (filter_project_id IS NULL OR kc.project_id = filter_project_id)
    AND kc.embedding IS NOT NULL
    AND 1 - (kc.embedding <=> query_embedding) > match_threshold
  ORDER BY kc.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;


ALTER FUNCTION "public"."match_knowledge_chunks"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "filter_source_type" "text", "filter_project_id" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."match_knowledge_chunks"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "filter_source_type" "text", "filter_project_id" "text") IS 'Semantic search across knowledge chunks using vector similarity';



CREATE OR REPLACE FUNCTION "public"."name_similarity"("name1" "text", "name2" "text") RETURNS numeric
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
DECLARE
    n1 TEXT;
    n2 TEXT;
    max_len INT;
    distance INT;
BEGIN
    IF name1 IS NULL OR name2 IS NULL THEN RETURN 0; END IF;

    n1 := LOWER(TRIM(name1));
    n2 := LOWER(TRIM(name2));

    IF n1 = n2 THEN RETURN 1.00; END IF;

    max_len := GREATEST(LENGTH(n1), LENGTH(n2));
    IF max_len = 0 THEN RETURN 0; END IF;

    distance := levenshtein(n1, n2);
    RETURN GREATEST(0, 1.0 - (distance::DECIMAL / max_len))::DECIMAL(3,2);
END;
$$;


ALTER FUNCTION "public"."name_similarity"("name1" "text", "name2" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."name_similarity"("name1" "text", "name2" "text") IS 'Calculate similarity between two names (0.0 to 1.0)';



CREATE OR REPLACE FUNCTION "public"."normalize_email"("email" "text") RETURNS "text"
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
BEGIN
    IF email IS NULL THEN RETURN NULL; END IF;
    RETURN LOWER(TRIM(email));
END;
$$;


ALTER FUNCTION "public"."normalize_email"("email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."normalize_location_name"("input_name" "text") RETURNS "text"
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
BEGIN
  -- Handle common spelling variations and normalize
  CASE 
    WHEN input_name ILIKE 'Tennent Creek' THEN RETURN 'Tennant Creek';
    WHEN input_name ILIKE 'Bundaburg' THEN RETURN 'Bundaberg';
    WHEN input_name ILIKE 'Mt Isa' THEN RETURN 'Mount Isa';
    WHEN input_name ILIKE 'central coast' THEN RETURN 'Central Coast';
    WHEN input_name ILIKE 'gold coast' THEN RETURN 'Gold Coast';
    WHEN input_name ILIKE 'spain' THEN RETURN 'Spain';
    WHEN input_name ILIKE 'athens' THEN RETURN 'Athens';
    WHEN input_name ILIKE 'london' THEN RETURN 'London';
    ELSE RETURN TRIM(input_name);
  END CASE;
END;
$$;


ALTER FUNCTION "public"."normalize_location_name"("input_name" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."normalize_phone"("phone" "text") RETURNS "text"
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
DECLARE
    cleaned TEXT;
BEGIN
    IF phone IS NULL THEN RETURN NULL; END IF;

    -- Remove all non-digits
    cleaned := regexp_replace(phone, '[^0-9]', '', 'g');

    -- Handle Australian numbers
    IF cleaned LIKE '0%' AND LENGTH(cleaned) = 10 THEN
        -- Convert 04xx to +614xx
        cleaned := '+61' || SUBSTRING(cleaned FROM 2);
    ELSIF cleaned LIKE '61%' AND LENGTH(cleaned) = 11 THEN
        cleaned := '+' || cleaned;
    ELSIF LENGTH(cleaned) = 9 AND cleaned LIKE '4%' THEN
        -- Just mobile without leading 0
        cleaned := '+61' || cleaned;
    END IF;

    RETURN cleaned;
END;
$$;


ALTER FUNCTION "public"."normalize_phone"("phone" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_webhook_sync_event"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    webhook_url TEXT;
    payload JSONB;
BEGIN
    -- Check if webhook URL is configured (this would be set via environment or config)
    -- For now, just log the event - webhook integration would be handled by the application
    
    payload = jsonb_build_object(
        'event_id', NEW.id,
        'event_type', NEW.event_type,
        'table_name', NEW.table_name,
        'record_id', NEW.record_id,
        'sync_target', NEW.sync_target,
        'priority', NEW.priority,
        'created_at', NEW.created_at
    );

    -- Log webhook notification (application will pick this up)
    RAISE NOTICE 'WEBHOOK_SYNC_EVENT: %', payload::text;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_webhook_sync_event"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."populate_media_quote_links"() RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- This needs to be done based on your quotes table structure
  -- Since quotes have story_id, we need to map old story IDs to media IDs
  UPDATE media 
  SET linked_quotes = (
    SELECT array_agg(q.id)
    FROM quotes q 
    WHERE q.story_id = media.id
  );
END;
$$;


ALTER FUNCTION "public"."populate_media_quote_links"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."populate_storyteller_media_links"() RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  UPDATE users 
  SET linked_media = (
    SELECT array_agg(m.id)
    FROM media m 
    WHERE m.storyteller_id = users.id
  )
  WHERE role = 'storyteller';
END;
$$;


ALTER FUNCTION "public"."populate_storyteller_media_links"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."prevent_cultural_sync"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_restrictions RECORD;
BEGIN
    -- Check cultural restrictions for the source entity
    SELECT * INTO v_restrictions
    FROM check_cultural_restrictions(NEW.source_table, NEW.source_id);

    -- If target is external and data is restricted
    IF NEW.target_system != 'internal' THEN
        -- Check if 'external' is NOT in permitted uses
        IF v_restrictions.has_restrictions
           AND NOT ('external' = ANY(v_restrictions.permitted_uses)) THEN

            -- Log the blocked attempt (if audit table exists)
            BEGIN
                INSERT INTO agent_audit_log (
                    agent_id, action, target_table, target_id,
                    success, error_message, cultural_data_accessed, cultural_review_required
                ) VALUES (
                    'sync-queue', 'sync_blocked', NEW.source_table, NEW.source_id,
                    FALSE, 'Blocked by cultural protocol: external sync not permitted',
                    TRUE, TRUE
                );
            EXCEPTION WHEN undefined_table THEN
                -- agent_audit_log doesn't exist yet, skip logging
                NULL;
            END;

            -- Either block or mark for review based on sensitivity
            IF v_restrictions.sensitivity_level IN ('sacred', 'restricted') THEN
                RAISE EXCEPTION 'Cannot sync culturally protected data (%) to external system. Contact cultural liaison: %',
                    v_restrictions.sensitivity_level, v_restrictions.cultural_liaison_id;
            ELSE
                -- For sensitive data, mark for review instead of blocking
                NEW.status := 'blocked';
                NEW.cultural_check_passed := FALSE;
                NEW.error_message := 'Requires cultural review before external sync';
            END IF;
        ELSE
            NEW.cultural_check_passed := TRUE;
        END IF;
    ELSE
        NEW.cultural_check_passed := TRUE;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."prevent_cultural_sync"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."prevent_cultural_sync"() IS 'Trigger function to block syncing culturally restricted data';



CREATE OR REPLACE FUNCTION "public"."process_new_transcript"("p_story_id" "uuid", "p_transcript_text" "text", "p_source" "text" DEFAULT 'manual'::"text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_transcript_id UUID;
    v_word_count INTEGER;
BEGIN
    v_word_count := array_length(string_to_array(trim(p_transcript_text), ' '), 1);
    
    -- Mark existing as non-current
    UPDATE transcripts 
    SET is_current = false 
    WHERE story_id = p_story_id AND is_current = true;
    
    -- Insert new transcript
    INSERT INTO transcripts (
        story_id,
        raw_transcript,
        edited_transcript,
        source,
        word_count,
        processing_status,
        processing_completed_at
    ) VALUES (
        p_story_id,
        p_transcript_text,
        p_transcript_text,
        p_source,
        COALESCE(v_word_count, 0),
        'completed',
        NOW()
    ) RETURNING id INTO v_transcript_id;
    
    -- Update story for backward compatibility
    UPDATE stories 
    SET transcript = p_transcript_text 
    WHERE id = p_story_id;
    
    RETURN v_transcript_id;
END;
$$;


ALTER FUNCTION "public"."process_new_transcript"("p_story_id" "uuid", "p_transcript_text" "text", "p_source" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."queue_campaign_for_enrichment"("p_campaign_id" "uuid", "p_campaign_type" "text", "p_limit" integer DEFAULT 100) RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_queued_count INTEGER := 0;
  v_person RECORD;
BEGIN
  -- Get campaign contacts not yet enriched
  FOR v_person IN
    SELECT cca.person_id, cca.priority_score
    FROM contact_campaign_assignments cca
    JOIN person_identity_map pim ON cca.person_id = pim.person_id
    WHERE cca.campaign_id = p_campaign_id
      AND (pim.exa_enriched = FALSE OR pim.exa_refresh_needed = TRUE)
      AND cca.status NOT IN ('declined', 'no_response')
    ORDER BY cca.priority_score DESC NULLS LAST
    LIMIT p_limit
  LOOP
    PERFORM queue_for_exa_enrichment(
      v_person.person_id,
      p_campaign_type,
      COALESCE(v_person.priority_score, 50)::integer
    );
    v_queued_count := v_queued_count + 1;
  END LOOP;

  RETURN v_queued_count;
END;
$$;


ALTER FUNCTION "public"."queue_campaign_for_enrichment"("p_campaign_id" "uuid", "p_campaign_type" "text", "p_limit" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."queue_community_event_sync"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    operation_type TEXT;
    sync_data JSONB;
BEGIN
    -- Determine operation type
    IF TG_OP = 'DELETE' THEN
        operation_type = 'delete';
        sync_data = to_jsonb(OLD);
    ELSIF TG_OP = 'UPDATE' THEN
        operation_type = 'update';
        sync_data = to_jsonb(NEW);
    ELSIF TG_OP = 'INSERT' THEN
        operation_type = 'insert';
        sync_data = to_jsonb(NEW);
    END IF;

    -- Only sync certain types of community events
    IF (NEW.event_category IN ('collaboration', 'impact') OR OLD.event_category IN ('collaboration', 'impact')) THEN
        -- Queue the sync event
        INSERT INTO sync_events (
            event_type,
            table_name,
            record_id,
            operation_data,
            sync_target,
            priority
        ) VALUES (
            operation_type,
            'community_events',
            COALESCE(NEW.id, OLD.id),
            sync_data,
            'neo4j',
            6 -- Lower priority for events
        );
    END IF;

    RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."queue_community_event_sync"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."queue_for_exa_enrichment"("p_person_id" "uuid", "p_campaign_type" "text" DEFAULT 'general'::"text", "p_priority" integer DEFAULT 50, "p_enrich_network" boolean DEFAULT false) RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_queue_id UUID;
  v_existing_status TEXT;
BEGIN
  -- Check if already in queue
  SELECT status INTO v_existing_status
  FROM exa_enrichment_queue
  WHERE person_id = p_person_id AND campaign_type = p_campaign_type;

  IF v_existing_status = 'completed' THEN
    -- Already enriched, skip
    RAISE NOTICE 'Person already enriched for campaign %', p_campaign_type;
    RETURN NULL;
  ELSIF v_existing_status = 'pending' OR v_existing_status = 'processing' THEN
    -- Already queued, just update priority if higher
    UPDATE exa_enrichment_queue
    SET priority = GREATEST(priority, p_priority),
        enrich_network = enrich_network OR p_enrich_network
    WHERE person_id = p_person_id AND campaign_type = p_campaign_type
    RETURNING id INTO v_queue_id;

    RETURN v_queue_id;
  ELSE
    -- New queue entry or failed previous attempt
    INSERT INTO exa_enrichment_queue (
      person_id,
      campaign_type,
      priority,
      enrich_network
    )
    VALUES (p_person_id, p_campaign_type, p_priority, p_enrich_network)
    ON CONFLICT (person_id, campaign_type) DO UPDATE
    SET priority = GREATEST(exa_enrichment_queue.priority, EXCLUDED.priority),
        status = 'pending',
        enrich_network = exa_enrichment_queue.enrich_network OR EXCLUDED.enrich_network,
        retry_count = 0,
        error_message = NULL
    RETURNING id INTO v_queue_id;

    RETURN v_queue_id;
  END IF;
END;
$$;


ALTER FUNCTION "public"."queue_for_exa_enrichment"("p_person_id" "uuid", "p_campaign_type" "text", "p_priority" integer, "p_enrich_network" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."queue_project_outcome_sync"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    operation_type TEXT;
    sync_data JSONB;
BEGIN
    -- Determine operation type
    IF TG_OP = 'DELETE' THEN
        operation_type = 'delete';
        sync_data = to_jsonb(OLD);
    ELSIF TG_OP = 'UPDATE' THEN
        operation_type = 'update';
        sync_data = to_jsonb(NEW);
    ELSIF TG_OP = 'INSERT' THEN
        operation_type = 'insert';
        sync_data = to_jsonb(NEW);
    END IF;

    -- Queue the sync event
    INSERT INTO sync_events (
        event_type,
        table_name,
        record_id,
        operation_data,
        sync_target,
        priority
    ) VALUES (
        operation_type,
        'project_outcomes',
        COALESCE(NEW.id, OLD.id),
        sync_data,
        'neo4j',
        5 -- Medium priority for outcomes
    );

    RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."queue_project_outcome_sync"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."queue_project_sync"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    operation_type TEXT;
    sync_data JSONB;
BEGIN
    -- Determine operation type
    IF TG_OP = 'DELETE' THEN
        operation_type = 'delete';
        sync_data = to_jsonb(OLD);
    ELSIF TG_OP = 'UPDATE' THEN
        operation_type = 'update';
        sync_data = to_jsonb(NEW);
    ELSIF TG_OP = 'INSERT' THEN
        operation_type = 'insert';
        sync_data = to_jsonb(NEW);
    END IF;

    -- Queue the sync event
    INSERT INTO sync_events (
        event_type,
        table_name,
        record_id,
        operation_data,
        sync_target,
        priority
    ) VALUES (
        operation_type,
        'projects',
        COALESCE(NEW.id, OLD.id),
        sync_data,
        'neo4j',
        4 -- Medium-high priority for projects
    );

    RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."queue_project_sync"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."queue_user_profile_sync"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    operation_type TEXT;
    sync_data JSONB;
BEGIN
    -- Determine operation type
    IF TG_OP = 'DELETE' THEN
        operation_type = 'delete';
        sync_data = to_jsonb(OLD);
    ELSIF TG_OP = 'UPDATE' THEN
        operation_type = 'update';
        sync_data = to_jsonb(NEW);
    ELSIF TG_OP = 'INSERT' THEN
        operation_type = 'insert';
        sync_data = to_jsonb(NEW);
    END IF;

    -- Queue the sync event
    INSERT INTO sync_events (
        event_type,
        table_name,
        record_id,
        operation_data,
        sync_target,
        priority
    ) VALUES (
        operation_type,
        'user_profiles',
        COALESCE(NEW.user_id, OLD.user_id),
        sync_data,
        'neo4j',
        3 -- High priority for user changes
    );

    -- Log the event
    RAISE NOTICE 'Queued % sync event for user_profiles record %', operation_type, COALESCE(NEW.user_id, OLD.user_id);

    RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."queue_user_profile_sync"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."queue_user_profile_sync"() IS 'Trigger function to queue user profile changes for sync';



CREATE OR REPLACE FUNCTION "public"."record_decision_feedback"("p_decision_id" "uuid", "p_feedback" "text", "p_feedback_by" "text", "p_notes" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    UPDATE decision_traces
    SET human_feedback = p_feedback,
        feedback_by = p_feedback_by,
        feedback_notes = p_notes,
        feedback_at = NOW(),
        -- Update outcome based on feedback
        outcome_status = CASE
            WHEN p_feedback = 'correct' THEN 'correct'
            WHEN p_feedback = 'incorrect' THEN 'incorrect'
            ELSE 'partial'
        END,
        outcome_recorded_at = NOW()
    WHERE id = p_decision_id;
END;
$$;


ALTER FUNCTION "public"."record_decision_feedback"("p_decision_id" "uuid", "p_feedback" "text", "p_feedback_by" "text", "p_notes" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_research_finding"("p_session_id" "uuid", "p_finding_type" "text", "p_content" "jsonb", "p_entity_type" "text" DEFAULT NULL::"text", "p_entity_id" "uuid" DEFAULT NULL::"uuid", "p_confidence" numeric DEFAULT NULL::numeric, "p_sources" "text"[] DEFAULT NULL::"text"[]) RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_finding_id UUID;
BEGIN
  INSERT INTO alma_research_findings (
    session_id, finding_type, content, entity_type,
    entity_id, confidence, sources
  )
  VALUES (
    p_session_id, p_finding_type, p_content, p_entity_type,
    p_entity_id, p_confidence, p_sources
  )
  RETURNING id INTO v_finding_id;

  RETURN v_finding_id;
END;
$$;


ALTER FUNCTION "public"."record_research_finding"("p_session_id" "uuid", "p_finding_type" "text", "p_content" "jsonb", "p_entity_type" "text", "p_entity_id" "uuid", "p_confidence" numeric, "p_sources" "text"[]) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."refresh_alma_dashboards"() RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY alma_dashboard_interventions;
  REFRESH MATERIALIZED VIEW CONCURRENTLY alma_dashboard_funding;
  REFRESH MATERIALIZED VIEW CONCURRENTLY alma_dashboard_sources;
  REFRESH MATERIALIZED VIEW alma_dashboard_queue;
  REFRESH MATERIALIZED VIEW CONCURRENTLY alma_dashboard_tags;
END;
$$;


ALTER FUNCTION "public"."refresh_alma_dashboards"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."refresh_funding_relevance_scores"() RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  updated_count INTEGER := 0;
BEGIN
  UPDATE alma_funding_opportunities
  SET relevance_score = calculate_funding_relevance(id)
  WHERE status NOT IN ('closed', 'archived');

  GET DIAGNOSTICS updated_count = ROW_COUNT;
  RETURN updated_count;
END;
$$;


ALTER FUNCTION "public"."refresh_funding_relevance_scores"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."refresh_portfolio_rankings"() RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW alma_portfolio_rankings;
END;
$$;


ALTER FUNCTION "public"."refresh_portfolio_rankings"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."refresh_sentiment_analytics"() RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY alma_daily_sentiment;
  REFRESH MATERIALIZED VIEW CONCURRENTLY alma_sentiment_program_correlation;
END;
$$;


ALTER FUNCTION "public"."refresh_sentiment_analytics"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."refresh_sentiment_analytics"() IS 'Refresh sentiment analytics materialized views. Call this after media ingestion.';



CREATE OR REPLACE FUNCTION "public"."refresh_trust_scores"() RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY public.mv_trust_scores;
    
    -- Log the refresh for monitoring
    INSERT INTO public.system_logs (event_type, message, created_at)
    VALUES (
        'trust_scores_refresh', 
        'Trust scores materialized view refreshed successfully', 
        now()
    )
    ON CONFLICT DO NOTHING;  -- In case system_logs table doesn't exist yet
    
EXCEPTION WHEN OTHERS THEN
    -- If system_logs doesn't exist, just continue
    NULL;
END;
$$;


ALTER FUNCTION "public"."refresh_trust_scores"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."refresh_trust_scores"() IS 'Refreshes the trust scores materialized view';



CREATE OR REPLACE FUNCTION "public"."reject_proposal"("proposal_id" "uuid", "reviewer" "text", "notes" "text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  UPDATE agent_proposals SET
    status = 'rejected',
    reviewed_by = reviewer,
    reviewed_at = NOW(),
    review_notes = notes,
    updated_at = NOW()
  WHERE id = proposal_id
    AND status = 'pending';

  RETURN proposal_id;
END;
$$;


ALTER FUNCTION "public"."reject_proposal"("proposal_id" "uuid", "reviewer" "text", "notes" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reset_failed_sync_events"("table_filter" "text" DEFAULT NULL::"text", "max_age_hours" integer DEFAULT 24) RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    reset_count INTEGER;
BEGIN
    UPDATE sync_events
    SET 
        sync_status = 'pending',
        retry_count = 0,
        error_message = NULL,
        processed_at = NULL
    WHERE 
        sync_status = 'failed'
        AND retry_count < max_retries
        AND created_at > NOW() - (max_age_hours || ' hours')::INTERVAL
        AND (table_filter IS NULL OR table_name = table_filter);

    GET DIAGNOSTICS reset_count = ROW_COUNT;
    RETURN reset_count;
END;
$$;


ALTER FUNCTION "public"."reset_failed_sync_events"("table_filter" "text", "max_age_hours" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."resolve_entity"("p_source" "text", "p_source_id" "text", "p_name" "text", "p_email" "text" DEFAULT NULL::"text", "p_phone" "text" DEFAULT NULL::"text", "p_company" "text" DEFAULT NULL::"text", "p_entity_type" "text" DEFAULT 'person'::"text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_entity_id UUID;
    v_normalized_email TEXT;
    v_normalized_phone TEXT;
    v_existing_entity_id UUID;
BEGIN
    v_normalized_email := normalize_email(p_email);
    v_normalized_phone := normalize_phone(p_phone);

    -- 1. Check if source record already linked
    SELECT entity_id INTO v_existing_entity_id
    FROM entity_identifiers
    WHERE source = p_source AND source_record_id = p_source_id
    LIMIT 1;

    IF v_existing_entity_id IS NOT NULL THEN
        RETURN v_existing_entity_id;
    END IF;

    -- 2. Try to find existing entity by email
    IF v_normalized_email IS NOT NULL THEN
        SELECT entity_id INTO v_existing_entity_id
        FROM entity_identifiers
        WHERE identifier_type = 'email' AND normalized_value = v_normalized_email
        LIMIT 1;

        IF v_existing_entity_id IS NOT NULL THEN
            -- Add source ID to existing entity
            INSERT INTO entity_identifiers (entity_id, identifier_type, identifier_value, normalized_value, source, source_record_id)
            VALUES (v_existing_entity_id, p_source || '_id', p_source_id, p_source_id, p_source, p_source_id)
            ON CONFLICT DO NOTHING;
            RETURN v_existing_entity_id;
        END IF;
    END IF;

    -- 3. Try to find by phone
    IF v_normalized_phone IS NOT NULL THEN
        SELECT entity_id INTO v_existing_entity_id
        FROM entity_identifiers
        WHERE identifier_type = 'phone' AND normalized_value = v_normalized_phone
        LIMIT 1;

        IF v_existing_entity_id IS NOT NULL THEN
            -- Add source ID and email to existing entity
            INSERT INTO entity_identifiers (entity_id, identifier_type, identifier_value, normalized_value, source, source_record_id)
            VALUES (v_existing_entity_id, p_source || '_id', p_source_id, p_source_id, p_source, p_source_id)
            ON CONFLICT DO NOTHING;

            IF v_normalized_email IS NOT NULL THEN
                INSERT INTO entity_identifiers (entity_id, identifier_type, identifier_value, normalized_value, source, source_record_id)
                VALUES (v_existing_entity_id, 'email', p_email, v_normalized_email, p_source, p_source_id)
                ON CONFLICT DO NOTHING;
            END IF;

            RETURN v_existing_entity_id;
        END IF;
    END IF;

    -- 4. Create new canonical entity
    INSERT INTO canonical_entities (entity_type, canonical_name, canonical_email, canonical_phone, canonical_company)
    VALUES (p_entity_type, p_name, v_normalized_email, v_normalized_phone, p_company)
    RETURNING id INTO v_entity_id;

    -- Add identifiers
    INSERT INTO entity_identifiers (entity_id, identifier_type, identifier_value, normalized_value, source, source_record_id)
    VALUES (v_entity_id, p_source || '_id', p_source_id, p_source_id, p_source, p_source_id);

    IF v_normalized_email IS NOT NULL THEN
        INSERT INTO entity_identifiers (entity_id, identifier_type, identifier_value, normalized_value, source, source_record_id, is_primary)
        VALUES (v_entity_id, 'email', p_email, v_normalized_email, p_source, p_source_id, TRUE)
        ON CONFLICT DO NOTHING;
    END IF;

    IF v_normalized_phone IS NOT NULL THEN
        INSERT INTO entity_identifiers (entity_id, identifier_type, identifier_value, normalized_value, source, source_record_id, is_primary)
        VALUES (v_entity_id, 'phone', p_phone, v_normalized_phone, p_source, p_source_id, TRUE)
        ON CONFLICT DO NOTHING;
    END IF;

    RETURN v_entity_id;
END;
$$;


ALTER FUNCTION "public"."resolve_entity"("p_source" "text", "p_source_id" "text", "p_name" "text", "p_email" "text", "p_phone" "text", "p_company" "text", "p_entity_type" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."resolve_entity"("p_source" "text", "p_source_id" "text", "p_name" "text", "p_email" "text", "p_phone" "text", "p_company" "text", "p_entity_type" "text") IS 'Find or create canonical entity from a source record';



CREATE OR REPLACE FUNCTION "public"."search_alma_interventions"("p_query" "text" DEFAULT NULL::"text", "p_geography" "text"[] DEFAULT NULL::"text"[], "p_type" "text" DEFAULT NULL::"text", "p_evidence_level" "text" DEFAULT NULL::"text", "p_consent_level" "text" DEFAULT 'Public Knowledge Commons'::"text", "p_limit" integer DEFAULT 20) RETURNS TABLE("id" "uuid", "name" "text", "type" "text", "description" "text", "geography" "text", "evidence_level" "text", "consent_level" "text", "operating_organization" "text", "evidence_count" bigint, "outcome_count" bigint, "relevance_score" double precision)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    i.id,
    i.name,
    i.type,
    i.description,
    i.geography,
    i.evidence_level,
    i.consent_level,
    i.operating_organization,
    (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) as evidence_count,
    (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) as outcome_count,
    -- Simple relevance scoring
    CASE
      WHEN p_query IS NOT NULL THEN
        ts_rank(
          to_tsvector('english', COALESCE(i.name, '') || ' ' || COALESCE(i.description, '')),
          plainto_tsquery('english', p_query)
        )
      ELSE 1.0
    END::FLOAT as relevance_score
  FROM alma_interventions i
  WHERE
    -- Consent filter (always applied)
    (i.consent_level = 'Public Knowledge Commons' OR
     (p_consent_level IN ('Community Controlled', 'Strictly Private') AND i.consent_level = 'Community Controlled') OR
     (p_consent_level = 'Strictly Private' AND i.consent_level = 'Strictly Private'))
    -- Optional filters
    AND (p_query IS NULL OR
         to_tsvector('english', COALESCE(i.name, '') || ' ' || COALESCE(i.description, ''))
         @@ plainto_tsquery('english', p_query))
    AND (p_geography IS NULL OR i.geography = ANY(p_geography))
    AND (p_type IS NULL OR i.type = p_type)
    AND (p_evidence_level IS NULL OR i.evidence_level ILIKE '%' || p_evidence_level || '%')
  ORDER BY relevance_score DESC, evidence_count DESC
  LIMIT p_limit;
END;
$$;


ALTER FUNCTION "public"."search_alma_interventions"("p_query" "text", "p_geography" "text"[], "p_type" "text", "p_evidence_level" "text", "p_consent_level" "text", "p_limit" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."search_alma_unified"("query_text" "text", "entity_types" "text"[] DEFAULT NULL::"text"[], "jurisdictions" "text"[] DEFAULT NULL::"text"[], "limit_results" integer DEFAULT 50) RETURNS TABLE("entity_type" "text", "entity_id" "uuid", "title" "text", "description" "text", "category" "text", "jurisdiction" "text", "rank" real)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    s.entity_type,
    s.entity_id,
    s.title,
    LEFT(s.description, 500) as description,
    s.category,
    s.jurisdiction,
    (ts_rank(s.search_vector, websearch_to_tsquery('english', query_text)) * s.relevance_boost) as rank
  FROM alma_unified_search s
  WHERE
    s.search_vector @@ websearch_to_tsquery('english', query_text)
    AND (entity_types IS NULL OR s.entity_type = ANY(entity_types))
    AND (jurisdictions IS NULL OR s.jurisdiction = ANY(jurisdictions) OR s.jurisdiction IS NULL)
  ORDER BY rank DESC
  LIMIT limit_results;
END;
$$;


ALTER FUNCTION "public"."search_alma_unified"("query_text" "text", "entity_types" "text"[], "jurisdictions" "text"[], "limit_results" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."search_interventions_unified"("p_search_query" "text", "p_geography" "text"[] DEFAULT NULL::"text"[], "p_consent_level" "text" DEFAULT NULL::"text", "p_min_evidence_level" "text" DEFAULT NULL::"text") RETURNS TABLE("id" "uuid", "name" "text", "description" "text", "operating_organization" "text", "geography" "text"[], "evidence_level" "text", "source" "text", "relevance_rank" real)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    i.id,
    i.name,
    i.description,
    i.operating_organization,
    i.geography,
    i.evidence_level,
    i.source,
    ts_rank(i.search_vector, websearch_to_tsquery('english', p_search_query)) AS relevance_rank
  FROM alma_interventions_unified i,
       LATERAL (
         SELECT setweight(to_tsvector('english', COALESCE(i.name, '')), 'A') ||
                setweight(to_tsvector('english', COALESCE(i.description, '')), 'B')
       ) AS search_vector(search_vector)
  WHERE
    (p_search_query IS NULL OR search_vector.search_vector @@ websearch_to_tsquery('english', p_search_query))
    AND (p_geography IS NULL OR i.geography && p_geography)
    AND (p_consent_level IS NULL OR i.consent_level = p_consent_level)
    AND (p_min_evidence_level IS NULL OR i.evidence_level >= p_min_evidence_level)
  ORDER BY relevance_rank DESC;
END;
$$;


ALTER FUNCTION "public"."search_interventions_unified"("p_search_query" "text", "p_geography" "text"[], "p_consent_level" "text", "p_min_evidence_level" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."search_interventions_unified"("p_search_query" "text", "p_geography" "text"[], "p_consent_level" "text", "p_min_evidence_level" "text") IS 'Search across both ALMA interventions and legacy community programs';



CREATE OR REPLACE FUNCTION "public"."search_knowledge"("query_embedding" "public"."vector", "match_threshold" double precision DEFAULT 0.7, "match_count" integer DEFAULT 10, "filter_source_type" "text" DEFAULT NULL::"text", "filter_project_id" "text" DEFAULT NULL::"text") RETURNS TABLE("id" "uuid", "content" "text", "summary" "text", "topics" "text"[], "source_type" "text", "source_id" "text", "project_id" "text", "similarity" double precision)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        kc.id,
        kc.content,
        kc.summary,
        kc.topics,
        kc.source_type,
        kc.source_id,
        kc.project_id,
        1 - (kc.embedding <=> query_embedding) as similarity
    FROM knowledge_chunks kc
    WHERE kc.embedding IS NOT NULL
    AND 1 - (kc.embedding <=> query_embedding) > match_threshold
    AND (filter_source_type IS NULL OR kc.source_type = filter_source_type)
    AND (filter_project_id IS NULL OR kc.project_id = filter_project_id)
    ORDER BY kc.embedding <=> query_embedding
    LIMIT match_count;
END;
$$;


ALTER FUNCTION "public"."search_knowledge"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "filter_source_type" "text", "filter_project_id" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."search_knowledge"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "filter_source_type" "text", "filter_project_id" "text") IS 'Semantic search over knowledge chunks using vector similarity';



CREATE OR REPLACE FUNCTION "public"."search_media"("p_search_query" "text" DEFAULT NULL::"text", "p_file_type" "text" DEFAULT NULL::"text", "p_project_slug" "text" DEFAULT NULL::"text", "p_tag" "text" DEFAULT NULL::"text", "p_limit" integer DEFAULT 50, "p_offset" integer DEFAULT 0) RETURNS TABLE("id" "uuid", "file_url" "text", "thumbnail_url" "text", "file_type" "text", "title" "text", "description" "text", "alt_text" "text", "manual_tags" "text"[], "impact_themes" "text"[], "project_slugs" "text"[], "created_at" timestamp with time zone)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    m.id,
    m.file_url,
    m.thumbnail_url,
    m.file_type,
    m.title,
    m.description,
    m.alt_text,
    m.manual_tags,
    m.impact_themes,
    m.project_slugs,
    m.created_at
  FROM media_items m
  WHERE
    (p_search_query IS NULL OR
     to_tsvector('english', COALESCE(m.title, '') || ' ' || COALESCE(m.description, ''))
     @@ plainto_tsquery('english', p_search_query))
    AND (p_file_type IS NULL OR m.file_type = p_file_type)
    AND (p_project_slug IS NULL OR p_project_slug = ANY(m.project_slugs))
    AND (p_tag IS NULL OR p_tag = ANY(m.manual_tags) OR p_tag = ANY(m.impact_themes))
  ORDER BY m.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;


ALTER FUNCTION "public"."search_media"("p_search_query" "text", "p_file_type" "text", "p_project_slug" "text", "p_tag" "text", "p_limit" integer, "p_offset" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."search_project_knowledge"("query_embedding" "public"."vector", "p_project_code" "text" DEFAULT NULL::"text", "p_knowledge_types" "text"[] DEFAULT NULL::"text"[], "match_threshold" double precision DEFAULT 0.6, "match_count" integer DEFAULT 20) RETURNS TABLE("id" "uuid", "project_code" "text", "knowledge_type" "text", "title" "text", "content" "text", "recorded_at" timestamp with time zone, "topics" "text"[], "importance" "text", "similarity" double precision)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        pk.id,
        pk.project_code,
        pk.knowledge_type,
        pk.title,
        pk.content,
        pk.recorded_at,
        pk.topics,
        pk.importance,
        1 - (pk.embedding <=> query_embedding) as similarity
    FROM project_knowledge pk
    WHERE pk.embedding IS NOT NULL
    AND 1 - (pk.embedding <=> query_embedding) > match_threshold
    AND (p_project_code IS NULL OR pk.project_code = p_project_code)
    AND (p_knowledge_types IS NULL OR pk.knowledge_type = ANY(p_knowledge_types))
    ORDER BY pk.embedding <=> query_embedding
    LIMIT match_count;
END;
$$;


ALTER FUNCTION "public"."search_project_knowledge"("query_embedding" "public"."vector", "p_project_code" "text", "p_knowledge_types" "text"[], "match_threshold" double precision, "match_count" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."search_voice_notes"("query_embedding" "public"."vector", "match_threshold" double precision DEFAULT 0.7, "match_count" integer DEFAULT 10, "filter_visibility" "text" DEFAULT NULL::"text", "filter_user_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("id" "uuid", "transcript" "text", "summary" "text", "topics" "text"[], "recorded_by_name" "text", "recorded_at" timestamp with time zone, "similarity" double precision)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        vn.id,
        vn.transcript,
        vn.summary,
        vn.topics,
        vn.recorded_by_name,
        vn.recorded_at,
        1 - (vn.embedding <=> query_embedding) as similarity
    FROM voice_notes vn
    WHERE vn.embedding IS NOT NULL
    AND 1 - (vn.embedding <=> query_embedding) > match_threshold
    AND (filter_visibility IS NULL OR vn.visibility = filter_visibility OR vn.visibility = 'public')
    AND (filter_user_id IS NULL OR vn.recorded_by = filter_user_id OR filter_user_id = ANY(vn.shared_with))
    ORDER BY vn.embedding <=> query_embedding
    LIMIT match_count;
END;
$$;


ALTER FUNCTION "public"."search_voice_notes"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "filter_visibility" "text", "filter_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."search_voice_notes"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "filter_visibility" "text", "filter_user_id" "uuid") IS 'Semantic search over voice note transcripts using vector similarity';



CREATE OR REPLACE FUNCTION "public"."set_album_slug"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    IF NEW.slug IS NULL OR NEW.slug = '' THEN
        NEW.slug := generate_album_slug(NEW.title);
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_album_slug"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_platform_organization_context"("org_slug" "text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    org_id UUID;
BEGIN
    SELECT id INTO org_id FROM platform_organizations WHERE slug = org_slug;
    
    IF org_id IS NULL THEN
        RAISE EXCEPTION 'Platform organization % not found', org_slug;
    END IF;
    
    PERFORM set_config('app.current_platform_organization_id', org_id::text, true);
END;
$$;


ALTER FUNCTION "public"."set_platform_organization_context"("org_slug" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."should_promote_to_notion"("person_uuid" "uuid") RETURNS boolean
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  person_record person_identity_map;
  scores_record contact_intelligence_scores;
BEGIN
  SELECT * INTO person_record FROM person_identity_map WHERE person_id = person_uuid;
  SELECT * INTO scores_record FROM contact_intelligence_scores WHERE person_id = person_uuid;

  IF person_record.notion_person_id IS NOT NULL THEN
    RETURN FALSE;
  END IF;

  IF person_record.engagement_priority != 'critical' THEN
    RETURN FALSE;
  END IF;

  RETURN (
    scores_record.composite_score >= 80 OR
    scores_record.strategic_value_score >= 85
  );
END;
$$;


ALTER FUNCTION "public"."should_promote_to_notion"("person_uuid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."snapshot_alma_metrics"() RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Intervention counts by type
  INSERT INTO alma_metrics_history (metric_name, metric_category, intervention_type, value_count)
  SELECT
    'intervention_count',
    'interventions',
    type,
    COUNT(*)
  FROM alma_interventions
  GROUP BY type;

  -- Funding totals by jurisdiction
  INSERT INTO alma_metrics_history (metric_name, metric_category, jurisdiction, value_numeric)
  SELECT
    'total_expenditure',
    'funding',
    jurisdiction,
    SUM(total_expenditure)
  FROM alma_funding_data
  GROUP BY jurisdiction;

  -- Source processing metrics
  INSERT INTO alma_metrics_history (metric_name, metric_category, source_type, value_count, value_percentage)
  SELECT
    'source_success_rate',
    'sources',
    source_type,
    COUNT(*),
    AVG(success_rate)
  FROM alma_source_registry
  GROUP BY source_type;

  -- Queue status
  INSERT INTO alma_metrics_history (metric_name, metric_category, value_count, metadata)
  SELECT
    'pending_links',
    'processing',
    COUNT(*),
    jsonb_build_object(
      'by_status', jsonb_object_agg(status, cnt)
    )
  FROM (
    SELECT status, COUNT(*) as cnt
    FROM alma_discovered_links
    GROUP BY status
  ) s;
END;
$$;


ALTER FUNCTION "public"."snapshot_alma_metrics"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."spawn_sub_task"("p_parent_id" "uuid", "p_parent_agent" "text", "p_target_agent" "text", "p_action_name" "text", "p_params" "jsonb", "p_context" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_sub_task_id UUID;
  v_title TEXT;
BEGIN
  -- Build title
  v_title := 'Sub-task: ' || p_action_name || ' (delegated by ' || p_parent_agent || ')';

  -- Create the sub-task proposal
  INSERT INTO agent_proposals (
    agent_id,
    target_agent_id,
    action_name,
    title,
    description,
    reasoning,
    proposed_action,
    parent_proposal_id,
    coordination_status,
    coordination_context,
    status,
    priority
  ) VALUES (
    p_target_agent,
    p_target_agent,
    p_action_name,
    v_title,
    'Delegated sub-task from ' || p_parent_agent,
    jsonb_build_object(
      'trigger', 'delegated_from_' || p_parent_agent,
      'parent_proposal', p_parent_id,
      'confidence', 0.9
    ),
    p_params,
    p_parent_id,
    'waiting',
    p_context,
    'pending',
    'normal'
  )
  RETURNING id INTO v_sub_task_id;

  -- Update parent with child reference
  UPDATE agent_proposals
  SET
    child_proposal_ids = array_append(child_proposal_ids, v_sub_task_id),
    coordination_status = 'coordinating',
    updated_at = NOW()
  WHERE id = p_parent_id;

  RETURN v_sub_task_id;
END;
$$;


ALTER FUNCTION "public"."spawn_sub_task"("p_parent_id" "uuid", "p_parent_agent" "text", "p_target_agent" "text", "p_action_name" "text", "p_params" "jsonb", "p_context" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_linkedin_contacts_from_imports"() RETURNS integer
    LANGUAGE "plpgsql"
    AS $_$
      DECLARE
        rec RECORD;
        contact_id BIGINT;
        inserted_count INTEGER := 0;
      BEGIN
        FOR rec IN 
          SELECT DISTINCT
            payload->>'First Name' as first_name,
            payload->>'Last Name' as last_name,
            payload->>'URL' as linkedin_url,
            payload->>'Email Address' as email_address,
            payload->>'Position' as current_position,
            payload->>'Company' as current_company,
            CASE 
              WHEN payload->>'Connected On' ~ '^[0-9]{2} [A-Za-z]{3} [0-9]{4}$' THEN (payload->>'Connected On')::DATE
              ELSE NULL
            END as connected_on,
            owner as connection_source,
            ARRAY_AGG(id) as import_ids
          FROM linkedin_imports 
          WHERE type = 'connections'
            AND payload->>'First Name' IS NOT NULL 
            AND payload->>'Last Name' IS NOT NULL
          GROUP BY 
            payload->>'First Name',
            payload->>'Last Name', 
            payload->>'URL',
            payload->>'Email Address',
            payload->>'Position',
            payload->>'Company',
            payload->>'Connected On',
            owner
        LOOP
          INSERT INTO linkedin_contacts (
            first_name, last_name, linkedin_url, email_address,
            current_position, current_company, connected_on, 
            connection_source, raw_import_ids
          ) VALUES (
            rec.first_name, rec.last_name, rec.linkedin_url, rec.email_address,
            rec.current_position, rec.current_company, rec.connected_on,
            rec.connection_source, rec.import_ids
          )
          ON CONFLICT (linkedin_url) DO UPDATE SET
            email_address = COALESCE(EXCLUDED.email_address, linkedin_contacts.email_address),
            current_position = COALESCE(EXCLUDED.current_position, linkedin_contacts.current_position),
            current_company = COALESCE(EXCLUDED.current_company, linkedin_contacts.current_company),
            connection_source = CASE 
              WHEN linkedin_contacts.connection_source != EXCLUDED.connection_source 
              THEN 'both' 
              ELSE linkedin_contacts.connection_source 
            END,
            raw_import_ids = linkedin_contacts.raw_import_ids || EXCLUDED.raw_import_ids,
            updated_at = now();
            
          inserted_count := inserted_count + 1;
        END LOOP;
        
        RETURN inserted_count;
      END;
      $_$;


ALTER FUNCTION "public"."sync_linkedin_contacts_from_imports"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."track_exa_api_usage"("p_requests_used" integer, "p_request_type" "text" DEFAULT 'general'::"text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_current_month DATE := DATE_TRUNC('month', CURRENT_DATE);
  v_free_tier_limit INTEGER := 1000;
BEGIN
  -- Upsert usage for current month
  INSERT INTO exa_api_usage (
    period_month,
    total_requests,
    successful_requests,
    free_tier_limit,
    free_tier_remaining
  )
  VALUES (
    v_current_month,
    p_requests_used,
    p_requests_used,
    v_free_tier_limit,
    v_free_tier_limit - p_requests_used
  )
  ON CONFLICT (period_month) DO UPDATE
  SET total_requests = exa_api_usage.total_requests + p_requests_used,
      successful_requests = exa_api_usage.successful_requests + p_requests_used,
      free_tier_remaining = GREATEST(0, exa_api_usage.free_tier_remaining - p_requests_used),
      free_tier_exceeded = (exa_api_usage.total_requests + p_requests_used) > v_free_tier_limit,
      updated_at = NOW();

  -- Track by request type
  IF p_request_type = 'linkedin' THEN
    UPDATE exa_api_usage
    SET linkedin_requests = linkedin_requests + p_requests_used
    WHERE period_month = v_current_month;
  ELSIF p_request_type = 'company' THEN
    UPDATE exa_api_usage
    SET company_requests = company_requests + p_requests_used
    WHERE period_month = v_current_month;
  ELSIF p_request_type = 'media' THEN
    UPDATE exa_api_usage
    SET media_requests = media_requests + p_requests_used
    WHERE period_month = v_current_month;
  ELSIF p_request_type = 'network' THEN
    UPDATE exa_api_usage
    SET network_discovery_requests = network_discovery_requests + p_requests_used
    WHERE period_month = v_current_month;
  END IF;
END;
$$;


ALTER FUNCTION "public"."track_exa_api_usage"("p_requests_used" integer, "p_request_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_calculate_temperature"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- Calculate temperature if not provided
    IF NEW.temperature IS NULL THEN
        NEW.temperature := calculate_relationship_temperature(
            NEW.days_since_contact,
            NEW.total_touchpoints,
            NEW.inbound_count,
            NEW.outbound_count
        );
    END IF;
    
    -- Calculate LCAA stage if not provided
    IF NEW.lcaa_stage IS NULL THEN
        NEW.lcaa_stage := determine_lcaa_stage(
            NEW.temperature,
            NEW.inbound_count,
            NEW.outbound_count,
            NEW.total_touchpoints
        );
    END IF;
    
    -- Track temperature changes
    IF TG_OP = 'UPDATE' AND OLD.temperature IS NOT NULL AND NEW.temperature != OLD.temperature THEN
        NEW.last_temperature_change := NEW.temperature - OLD.temperature;
        NEW.temperature_trend := CASE 
            WHEN NEW.temperature > OLD.temperature THEN 'warming'
            WHEN NEW.temperature < OLD.temperature THEN 'cooling'
            ELSE 'stable'
        END;
    END IF;
    
    NEW.calculated_at := NOW();
    NEW.updated_at := NOW();
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_calculate_temperature"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_album_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_album_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_alma_contexts_search_vector"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.search_vector :=
    setweight(to_tsvector('english', COALESCE(NEW.name, '')), 'A') ||
    setweight(to_tsvector('english', COALESCE(NEW.demographics, '')), 'B') ||
    setweight(to_tsvector('english', COALESCE(NEW.system_factors, '')), 'C') ||
    setweight(to_tsvector('english', COALESCE(NEW.protective_factors, '')), 'C');
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_alma_contexts_search_vector"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_alma_evidence_search_vector"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.search_vector :=
    setweight(to_tsvector('english', COALESCE(NEW.title, '')), 'A') ||
    setweight(to_tsvector('english', COALESCE(NEW.findings, '')), 'B') ||
    setweight(to_tsvector('english', COALESCE(NEW.author, '')), 'C') ||
    setweight(to_tsvector('english', COALESCE(NEW.organization, '')), 'C');
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_alma_evidence_search_vector"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_alma_ingestion_jobs_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_alma_ingestion_jobs_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_alma_interventions_search_vector"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.search_vector :=
    setweight(to_tsvector('english', COALESCE(NEW.name, '')), 'A') ||
    setweight(to_tsvector('english', COALESCE(NEW.description, '')), 'B') ||
    setweight(to_tsvector('english', COALESCE(NEW.operating_organization, '')), 'C') ||
    setweight(to_tsvector('english', COALESCE(array_to_string(NEW.target_cohort, ' '), '')), 'D') ||
    setweight(to_tsvector('english', COALESCE(array_to_string(NEW.geography, ' '), '')), 'D');
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_alma_interventions_search_vector"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_alma_outcomes_search_vector"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.search_vector :=
    setweight(to_tsvector('english', COALESCE(NEW.name, '')), 'A') ||
    setweight(to_tsvector('english', COALESCE(NEW.description, '')), 'B') ||
    setweight(to_tsvector('english', COALESCE(NEW.measurement_method, '')), 'C');
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_alma_outcomes_search_vector"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_alma_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_alma_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_article_reading_time"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.reading_time_minutes := calculate_reading_time(NEW.content);
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_article_reading_time"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_calendar_events_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = now();
  -- Auto-set effective project_code
  NEW.project_code = COALESCE(NEW.manual_project_code, NEW.detected_project_code);
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_calendar_events_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_citation_count"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE alma_source_documents SET citation_count = citation_count + 1 WHERE id = NEW.source_document_id;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE alma_source_documents SET citation_count = citation_count - 1 WHERE id = OLD.source_document_id;
  END IF;
  RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."update_citation_count"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_community_programs_search_vector"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.search_vector :=
    setweight(to_tsvector('english', COALESCE(NEW.name, '')), 'A') ||
    setweight(to_tsvector('english', COALESCE(NEW.organization, '')), 'A') ||
    setweight(to_tsvector('english', COALESCE(NEW.description, '')), 'B') ||
    setweight(to_tsvector('english', COALESCE(NEW.impact_summary, '')), 'B') ||
    setweight(to_tsvector('english', COALESCE(array_to_string(NEW.tags, ' '), '')), 'C');
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_community_programs_search_vector"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_contact_review_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_contact_review_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_email_financial_documents_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_email_financial_documents_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_funding_opportunities_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_funding_opportunities_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_funding_opportunity_status"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Set to closing_soon if deadline is within 14 days
  IF NEW.deadline IS NOT NULL AND NEW.status = 'open' THEN
    IF NEW.deadline <= NOW() + INTERVAL '14 days' AND NEW.deadline > NOW() THEN
      NEW.status = 'closing_soon';
    ELSIF NEW.deadline <= NOW() THEN
      NEW.status = 'closed';
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_funding_opportunity_status"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_gmail_sync_state"("p_account_id" "uuid", "p_history_id" "text", "p_items_found" integer, "p_items_extracted" integer, "p_status" "text" DEFAULT 'completed'::"text", "p_error_message" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  INSERT INTO gmail_sync_state (
    account_id,
    last_history_id,
    last_sync_at,
    next_sync_at,
    status,
    items_found,
    items_extracted,
    error_message,
    updated_at
  ) VALUES (
    p_account_id,
    p_history_id,
    NOW(),
    NOW() + INTERVAL '1 hour',  -- Next sync in 1 hour
    p_status,
    p_items_found,
    p_items_extracted,
    p_error_message,
    NOW()
  )
  ON CONFLICT (account_id)
  DO UPDATE SET
    last_history_id = EXCLUDED.last_history_id,
    last_sync_at = EXCLUDED.last_sync_at,
    next_sync_at = EXCLUDED.next_sync_at,
    status = EXCLUDED.status,
    items_found = EXCLUDED.items_found,
    items_extracted = EXCLUDED.items_extracted,
    error_message = EXCLUDED.error_message,
    updated_at = EXCLUDED.updated_at;
END;
$$;


ALTER FUNCTION "public"."update_gmail_sync_state"("p_account_id" "uuid", "p_history_id" "text", "p_items_found" integer, "p_items_extracted" integer, "p_status" "text", "p_error_message" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."update_gmail_sync_state"("p_account_id" "uuid", "p_history_id" "text", "p_items_found" integer, "p_items_extracted" integer, "p_status" "text", "p_error_message" "text") IS 'Updates Gmail sync state after scan';



CREATE OR REPLACE FUNCTION "public"."update_goals_2026_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_goals_2026_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_knowledge_version_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_knowledge_version_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_learned_thresholds_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_learned_thresholds_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_media_library_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_media_library_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_migration_priority"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.migration_priority := calculate_migration_priority(
    NEW.amount,
    NEW.metadata,
    NEW.confidence
  );
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_migration_priority"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_pk_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_pk_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_platform_organization_activity"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    UPDATE platform_organizations 
    SET 
        last_activity_at = NOW(),
        first_upload_at = COALESCE(first_upload_at, NOW())
    WHERE id = NEW.platform_organization_id;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_platform_organization_activity"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_platform_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_platform_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_profile_appearances_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_profile_appearances_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_profiles_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_profiles_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_project_stats"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE projects 
    SET total_stories = total_stories + 1,
        last_story_submitted = NEW.submitted_at
    WHERE id = NEW.project_id;
    
    -- Update storyteller count
    UPDATE projects 
    SET total_storytellers = (
      SELECT COUNT(DISTINCT storyteller_id) 
      FROM stories 
      WHERE project_id = NEW.project_id
    )
    WHERE id = NEW.project_id;
    
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE projects 
    SET total_stories = GREATEST(0, total_stories - 1)
    WHERE id = OLD.project_id;
    
    -- Update storyteller count
    UPDATE projects 
    SET total_storytellers = (
      SELECT COUNT(DISTINCT storyteller_id) 
      FROM stories 
      WHERE project_id = OLD.project_id
    )
    WHERE id = OLD.project_id;
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."update_project_stats"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_public_profiles_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_public_profiles_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_raw_content_stats"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  UPDATE alma_raw_content
  SET
    interventions_extracted = (
      SELECT COUNT(*) FROM alma_content_entities
      WHERE raw_content_id = NEW.raw_content_id AND entity_type = 'intervention'
    ),
    evidence_extracted = (
      SELECT COUNT(*) FROM alma_content_entities
      WHERE raw_content_id = NEW.raw_content_id AND entity_type = 'evidence'
    ),
    funding_data_extracted = (
      SELECT COUNT(*) FROM alma_content_entities
      WHERE raw_content_id = NEW.raw_content_id AND entity_type = 'funding'
    ),
    processing_status = 'completed',
    last_processed_at = NOW()
  WHERE id = NEW.raw_content_id;
  RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."update_raw_content_stats"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_relationship_health"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_last_contact TIMESTAMPTZ;
    v_days_since INT;
BEGIN
    -- Calculate last contact and days since
    v_last_contact := NEW.occurred_at;
    v_days_since := EXTRACT(DAY FROM (NOW() - v_last_contact))::INT;

    -- Update or create relationship health record
    INSERT INTO relationship_health (
        ghl_contact_id,
        last_inbound_at,
        last_outbound_at,
        last_contact_at,
        days_since_contact,
        total_touchpoints
    )
    VALUES (
        NEW.ghl_contact_id,
        CASE WHEN NEW.direction = 'inbound' THEN NEW.occurred_at ELSE NULL END,
        CASE WHEN NEW.direction = 'outbound' THEN NEW.occurred_at ELSE NULL END,
        NEW.occurred_at,
        v_days_since,
        1
    )
    ON CONFLICT (ghl_contact_id) DO UPDATE SET
        last_inbound_at = CASE
            WHEN NEW.direction = 'inbound' THEN GREATEST(relationship_health.last_inbound_at, NEW.occurred_at)
            ELSE relationship_health.last_inbound_at
        END,
        last_outbound_at = CASE
            WHEN NEW.direction = 'outbound' THEN GREATEST(relationship_health.last_outbound_at, NEW.occurred_at)
            ELSE relationship_health.last_outbound_at
        END,
        last_contact_at = GREATEST(relationship_health.last_contact_at, NEW.occurred_at),
        days_since_contact = EXTRACT(DAY FROM (NOW() - GREATEST(relationship_health.last_contact_at, NEW.occurred_at)))::INT,
        inbound_count = relationship_health.inbound_count + CASE WHEN NEW.direction = 'inbound' THEN 1 ELSE 0 END,
        outbound_count = relationship_health.outbound_count + CASE WHEN NEW.direction = 'outbound' THEN 1 ELSE 0 END,
        total_touchpoints = relationship_health.total_touchpoints + 1,
        updated_at = NOW()
    WHERE NEW.ghl_contact_id IS NOT NULL;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_relationship_health"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_research_session"("p_session_id" "uuid", "p_status" "text" DEFAULT NULL::"text", "p_plan" "jsonb" DEFAULT NULL::"jsonb", "p_scratchpad" "jsonb" DEFAULT NULL::"jsonb", "p_results" "jsonb" DEFAULT NULL::"jsonb", "p_error_message" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  UPDATE alma_research_sessions
  SET
    status = COALESCE(p_status, status),
    plan = COALESCE(p_plan, plan),
    scratchpad = COALESCE(p_scratchpad, scratchpad),
    results = COALESCE(p_results, results),
    error_message = COALESCE(p_error_message, error_message),
    updated_at = NOW(),
    completed_at = CASE WHEN p_status IN ('complete', 'failed') THEN NOW() ELSE completed_at END
  WHERE id = p_session_id;
END;
$$;


ALTER FUNCTION "public"."update_research_session"("p_session_id" "uuid", "p_status" "text", "p_plan" "jsonb", "p_scratchpad" "jsonb", "p_results" "jsonb", "p_error_message" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_site_health_from_check"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  UPDATE ecosystem_sites
  SET
    status = NEW.health_status,
    health_score = NEW.health_score,
    last_check_at = NEW.checked_at,
    response_time_ms = NEW.http_response_time_ms,
    ssl_expires_at = NEW.ssl_expires_at,
    updated_at = now()
  WHERE id = NEW.site_id;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_site_health_from_check"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_source_after_scrape"("p_source_url" "text", "p_success" boolean, "p_entities_found" integer) RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  UPDATE alma_source_registry
  SET
    updated_at = NOW(),
    last_scraped_at = NOW(),
    scrape_count = scrape_count + 1,
    success_count = success_count + CASE WHEN p_success THEN 1 ELSE 0 END,
    failure_count = failure_count + CASE WHEN NOT p_success THEN 1 ELSE 0 END,
    total_entities_extracted = total_entities_extracted + COALESCE(p_entities_found, 0),
    quality_score = CASE
      WHEN p_success AND p_entities_found > 0 THEN
        LEAST(10, quality_score + 0.1) -- Small boost for good scrapes
      WHEN NOT p_success THEN
        GREATEST(0, quality_score - 0.2) -- Penalty for failures
      ELSE quality_score
    END,
    next_scrape_at = calculate_next_scrape(update_frequency, priority_score)
  WHERE url = p_source_url;
END;
$$;


ALTER FUNCTION "public"."update_source_after_scrape"("p_source_url" "text", "p_success" boolean, "p_entities_found" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_source_document_search_vector"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.search_vector := 
    setweight(to_tsvector('english', COALESCE(NEW.title, '')), 'A') ||
    setweight(to_tsvector('english', COALESCE(NEW.source_organization, '')), 'B') ||
    setweight(to_tsvector('english', COALESCE(NEW.abstract, '')), 'C');
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_source_document_search_vector"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_story_analysis_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_story_analysis_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_storyteller_ai_intelligence_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_storyteller_ai_intelligence_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_storyteller_videos_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_storyteller_videos_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_subscriptions_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_subscriptions_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_sync_event_status"("event_id" "uuid", "new_status" "text", "error_msg" "text" DEFAULT NULL::"text") RETURNS boolean
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    UPDATE sync_events
    SET 
        sync_status = new_status,
        processed_at = CASE WHEN new_status IN ('completed', 'failed', 'skipped') THEN NOW() ELSE processed_at END,
        error_message = CASE WHEN new_status = 'failed' THEN error_msg ELSE error_message END,
        retry_count = CASE WHEN new_status = 'failed' THEN retry_count + 1 ELSE retry_count END
    WHERE id = event_id;

    RETURN FOUND;
END;
$$;


ALTER FUNCTION "public"."update_sync_event_status"("event_id" "uuid", "new_status" "text", "error_msg" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_tag_usage_count"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE alma_tags SET usage_count = usage_count + 1 WHERE id = NEW.tag_id;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE alma_tags SET usage_count = usage_count - 1 WHERE id = OLD.tag_id;
  END IF;
  RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."update_tag_usage_count"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_task_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_task_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_transcript_search_vector"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.search_vector := to_tsvector('english', 
        COALESCE(NEW.edited_transcript, NEW.raw_transcript, '')
    );
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_transcript_search_vector"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_transcripts_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_transcripts_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_user_last_active"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    UPDATE user_profiles 
    SET last_active_at = NOW() 
    WHERE user_id = NEW.user_id;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_user_last_active"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_xero_invoice_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_xero_invoice_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."user_can_perform_alma_action"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_allowed BOOLEAN;
BEGIN
  -- Use the consent compliance check
  SELECT allowed
  INTO v_allowed
  FROM check_consent_compliance(p_entity_type, p_entity_id, p_action);

  RETURN COALESCE(v_allowed, false);
END;
$$;


ALTER FUNCTION "public"."user_can_perform_alma_action"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."user_can_perform_alma_action"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text") IS 'Check if current user has permission for specific action based on consent ledger';



CREATE OR REPLACE FUNCTION "public"."wiki_page_create_version"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Only create version if content actually changed
  IF (OLD.content IS DISTINCT FROM NEW.content) OR
     (OLD.title IS DISTINCT FROM NEW.title) OR
     (OLD.excerpt IS DISTINCT FROM NEW.excerpt) THEN

    -- Increment version number
    NEW.version := OLD.version + 1;

    -- Save old version to history
    INSERT INTO wiki_page_versions (page_id, version, title, content, excerpt, changed_by)
    VALUES (OLD.id, OLD.version, OLD.title, OLD.content, OLD.excerpt, NEW.updated_by);
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."wiki_page_create_version"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."wiki_pages_review_due_trigger"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF NEW.last_reviewed_at IS NOT NULL AND NEW.review_frequency_days IS NOT NULL THEN
    NEW.next_review_due := NEW.last_reviewed_at + (NEW.review_frequency_days || ' days')::INTERVAL;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."wiki_pages_review_due_trigger"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."wiki_pages_search_trigger"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.search_vector :=
    setweight(to_tsvector('english', COALESCE(NEW.title, '')), 'A') ||
    setweight(to_tsvector('english', COALESCE(NEW.excerpt, '')), 'B') ||
    setweight(to_tsvector('english', COALESCE(NEW.content, '')), 'C') ||
    setweight(to_tsvector('english', COALESCE(array_to_string(NEW.tags, ' '), '')), 'D');
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."wiki_pages_search_trigger"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "drizzle"."__drizzle_migrations" (
    "id" integer NOT NULL,
    "hash" "text" NOT NULL,
    "created_at" bigint
);


ALTER TABLE "drizzle"."__drizzle_migrations" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "drizzle"."__drizzle_migrations_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "drizzle"."__drizzle_migrations_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "drizzle"."__drizzle_migrations_id_seq" OWNED BY "drizzle"."__drizzle_migrations"."id";



CREATE TABLE IF NOT EXISTS "public"."_act_migrations" (
    "id" integer NOT NULL,
    "filename" "text" NOT NULL,
    "applied_at" timestamp with time zone DEFAULT "now"(),
    "checksum" "text" NOT NULL
);


ALTER TABLE "public"."_act_migrations" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."_act_migrations_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."_act_migrations_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."_act_migrations_id_seq" OWNED BY "public"."_act_migrations"."id";



CREATE TABLE IF NOT EXISTS "public"."receipt_status" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "source_type" "text" NOT NULL,
    "source_id" "text" NOT NULL,
    "transaction_date" "date" NOT NULL,
    "vendor_name" "text",
    "description" "text",
    "amount" numeric NOT NULL,
    "currency" "text" DEFAULT 'AUD'::"text",
    "project_code" "text",
    "category" "text",
    "receipt_status" "text" DEFAULT 'missing'::"text",
    "receipt_source" "text",
    "receipt_url" "text",
    "receipt_matched_at" timestamp with time zone,
    "email_match_id" "text",
    "email_match_confidence" numeric,
    "email_match_subject" "text",
    "deferred_until" "date",
    "notes" "text",
    "resolved_by" "text",
    "resolved_at" timestamp with time zone,
    "points_awarded" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."receipt_status" OWNER TO "postgres";


COMMENT ON TABLE "public"."receipt_status" IS 'Live tracking of all expenses and their receipt status';



CREATE OR REPLACE VIEW "public"."accounting_summary" AS
 SELECT ("date_trunc"('month'::"text", ("transaction_date")::timestamp with time zone))::"date" AS "month",
    "project_code",
    "category",
    "count"(*) AS "transaction_count",
    "sum"("amount") AS "total_amount",
    "sum"(
        CASE
            WHEN ("receipt_status" = 'matched'::"text") THEN 1
            ELSE 0
        END) AS "receipts_matched",
    "sum"(
        CASE
            WHEN ("receipt_status" = 'missing'::"text") THEN 1
            ELSE 0
        END) AS "receipts_missing",
    "sum"(
        CASE
            WHEN ("receipt_status" = 'not_required'::"text") THEN 1
            ELSE 0
        END) AS "no_receipt_required",
    "round"(((100.0 * ("sum"(
        CASE
            WHEN ("receipt_status" = ANY (ARRAY['matched'::"text", 'not_required'::"text"])) THEN 1
            ELSE 0
        END))::numeric) / (NULLIF("count"(*), 0))::numeric), 1) AS "completion_pct"
   FROM "public"."receipt_status"
  GROUP BY ("date_trunc"('month'::"text", ("transaction_date")::timestamp with time zone)), "project_code", "category"
  ORDER BY (("date_trunc"('month'::"text", ("transaction_date")::timestamp with time zone))::"date") DESC, ("sum"("amount")) DESC;


ALTER VIEW "public"."accounting_summary" OWNER TO "postgres";


COMMENT ON VIEW "public"."accounting_summary" IS 'Monthly accounting summary by project with receipt completion rates';



CREATE TABLE IF NOT EXISTS "public"."wiki_page_links" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "from_page_id" "uuid" NOT NULL,
    "to_page_id" "uuid" NOT NULL,
    "link_type" "text" DEFAULT 'related'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "wiki_page_links_link_type_check" CHECK (("link_type" = ANY (ARRAY['related'::"text", 'parent'::"text", 'child'::"text", 'prerequisite'::"text", 'see_also'::"text"])))
);


ALTER TABLE "public"."wiki_page_links" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."wiki_pages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "content" "text" NOT NULL,
    "excerpt" "text",
    "page_type" "text" NOT NULL,
    "parent_principle_id" "uuid",
    "parent_method_id" "uuid",
    "parent_practice_id" "uuid",
    "projects" "text"[] DEFAULT ARRAY[]::"text"[],
    "domains" "text"[] DEFAULT ARRAY[]::"text"[],
    "tags" "text"[] DEFAULT ARRAY[]::"text"[],
    "source_types" "text"[] DEFAULT ARRAY[]::"text"[],
    "source_urls" "text"[] DEFAULT ARRAY[]::"text"[],
    "extracted_from_ids" "text"[] DEFAULT ARRAY[]::"text"[],
    "status" "text" DEFAULT 'draft'::"text",
    "last_reviewed_at" timestamp with time zone DEFAULT "now"(),
    "review_frequency_days" integer DEFAULT 90,
    "next_review_due" timestamp with time zone,
    "verified_by" "uuid",
    "verified_at" timestamp with time zone,
    "quality_score" integer,
    "version" integer DEFAULT 1,
    "updated_by" "uuid",
    "search_vector" "tsvector",
    "view_count" integer DEFAULT 0,
    "last_viewed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "content_embedding" "public"."vector"(1536),
    "auto_approved" boolean DEFAULT false,
    "approval_confidence" double precision,
    "notion_page_id" "text",
    CONSTRAINT "wiki_pages_page_type_check" CHECK (("page_type" = ANY (ARRAY['principle'::"text", 'method'::"text", 'practice'::"text", 'procedure'::"text", 'guide'::"text", 'template'::"text"]))),
    CONSTRAINT "wiki_pages_quality_score_check" CHECK ((("quality_score" >= 1) AND ("quality_score" <= 5))),
    CONSTRAINT "wiki_pages_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'active'::"text", 'needs_review'::"text", 'archived'::"text"])))
);


ALTER TABLE "public"."wiki_pages" OWNER TO "postgres";


COMMENT ON COLUMN "public"."wiki_pages"."content_embedding" IS 'OpenAI text-embedding-3-small (1536 dimensions) - used for semantic search';



CREATE OR REPLACE VIEW "public"."active_wiki_pages" AS
 SELECT "id",
    "title",
    "slug",
    "content",
    "excerpt",
    "page_type",
    "parent_principle_id",
    "parent_method_id",
    "parent_practice_id",
    "projects",
    "domains",
    "tags",
    "source_types",
    "source_urls",
    "extracted_from_ids",
    "status",
    "last_reviewed_at",
    "review_frequency_days",
    "next_review_due",
    "verified_by",
    "verified_at",
    "quality_score",
    "version",
    "updated_by",
    "search_vector",
    "view_count",
    "last_viewed_at",
    "created_at",
    "updated_at",
        CASE
            WHEN ("next_review_due" < "now"()) THEN 'overdue'::"text"
            WHEN ("next_review_due" < ("now"() + '7 days'::interval)) THEN 'due_soon'::"text"
            ELSE 'current'::"text"
        END AS "review_status",
    ( SELECT "count"(*) AS "count"
           FROM "public"."wiki_page_links"
          WHERE ("wiki_page_links"."from_page_id" = "w"."id")) AS "outgoing_links",
    ( SELECT "count"(*) AS "count"
           FROM "public"."wiki_page_links"
          WHERE ("wiki_page_links"."to_page_id" = "w"."id")) AS "incoming_links"
   FROM "public"."wiki_pages" "w"
  WHERE ("status" = 'active'::"text")
  ORDER BY "last_viewed_at" DESC NULLS LAST;


ALTER VIEW "public"."active_wiki_pages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."activities" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "user_id" "text" DEFAULT 'anonymous'::"text",
    "activity_type" "text" NOT NULL,
    "message" "text" NOT NULL,
    "timestamp" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."activities" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."agent_actions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "action_name" "text" NOT NULL,
    "description" "text",
    "autonomy_level" integer DEFAULT 2 NOT NULL,
    "bounds" "jsonb" DEFAULT '{}'::"jsonb",
    "risk_level" "text" DEFAULT 'low'::"text",
    "reversible" boolean DEFAULT true,
    "script_path" "text",
    "script_args_template" "jsonb" DEFAULT '{}'::"jsonb",
    "enabled" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "agent_actions_autonomy_level_check" CHECK ((("autonomy_level" >= 1) AND ("autonomy_level" <= 3))),
    CONSTRAINT "agent_actions_risk_level_check" CHECK (("risk_level" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text", 'critical'::"text"])))
);


ALTER TABLE "public"."agent_actions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."agent_audit_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "timestamp" timestamp with time zone DEFAULT "now"(),
    "agent_id" "text" NOT NULL,
    "agent_version" "text",
    "action" "text" NOT NULL,
    "action_category" "text",
    "target_table" "text",
    "target_id" "text",
    "target_count" integer DEFAULT 1,
    "input_summary" "jsonb",
    "output_summary" "jsonb",
    "user_context" "text",
    "trigger_source" "text",
    "parent_audit_id" "uuid",
    "duration_ms" integer,
    "api_calls_made" integer DEFAULT 0,
    "tokens_used" integer DEFAULT 0,
    "success" boolean DEFAULT true,
    "error_message" "text",
    "error_code" "text",
    "retry_count" integer DEFAULT 0,
    "cultural_data_accessed" boolean DEFAULT false,
    "cultural_review_required" boolean DEFAULT false,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."agent_audit_log" OWNER TO "postgres";


COMMENT ON TABLE "public"."agent_audit_log" IS 'Audit trail for all agent actions - governance layer';



COMMENT ON COLUMN "public"."agent_audit_log"."agent_id" IS 'Identifier for the agent: morning-brief, voice-pipeline, contact-sync, etc.';



COMMENT ON COLUMN "public"."agent_audit_log"."action" IS 'Type of action: read, write, delete, sync, enrich, embed';



COMMENT ON COLUMN "public"."agent_audit_log"."cultural_data_accessed" IS 'Flag if action touched culturally sensitive data';



CREATE TABLE IF NOT EXISTS "public"."agent_registry" (
    "agent_id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "type" "text" NOT NULL,
    "endpoint" "text" NOT NULL,
    "endpoint_type" "text",
    "capabilities" "jsonb" DEFAULT '[]'::"jsonb",
    "model" "text",
    "enabled" boolean DEFAULT true,
    "health_status" "text" DEFAULT 'unknown'::"text",
    "last_health_check" timestamp with time zone,
    "avg_response_time_ms" integer,
    "success_rate" numeric(5,2),
    "owner" "text",
    "team" "text",
    "tags" "jsonb" DEFAULT '[]'::"jsonb",
    "config" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "agent_registry_endpoint_type_check" CHECK (("endpoint_type" = ANY (ARRAY['http'::"text", 'event'::"text", 'cli'::"text", 'function'::"text"]))),
    CONSTRAINT "agent_registry_health_status_check" CHECK (("health_status" = ANY (ARRAY['healthy'::"text", 'degraded'::"text", 'down'::"text", 'unknown'::"text"]))),
    CONSTRAINT "agent_registry_type_check" CHECK (("type" = ANY (ARRAY['clawdbot'::"text", 'financial'::"text", 'python'::"text"])))
);


ALTER TABLE "public"."agent_registry" OWNER TO "postgres";


COMMENT ON TABLE "public"."agent_registry" IS 'Registry of all ACT agents across 3 architectural patterns';



COMMENT ON COLUMN "public"."agent_registry"."capabilities" IS 'JSON array of capability strings that this agent supports';



COMMENT ON COLUMN "public"."agent_registry"."config" IS 'Agent-specific configuration (timeouts, rate limits, etc)';



CREATE OR REPLACE VIEW "public"."agent_health_dashboard" AS
 SELECT "agent_id",
    "name",
    "type",
    "health_status",
    "enabled",
    "avg_response_time_ms",
    "success_rate",
    "last_health_check",
        CASE
            WHEN ("last_health_check" < ("now"() - '00:05:00'::interval)) THEN 'stale'::"text"
            WHEN ("health_status" = 'down'::"text") THEN 'critical'::"text"
            WHEN ("health_status" = 'degraded'::"text") THEN 'warning'::"text"
            ELSE 'ok'::"text"
        END AS "alert_level"
   FROM "public"."agent_registry"
  ORDER BY
        CASE "health_status"
            WHEN 'down'::"text" THEN 1
            WHEN 'degraded'::"text" THEN 2
            WHEN 'unknown'::"text" THEN 3
            ELSE 4
        END, "name";


ALTER VIEW "public"."agent_health_dashboard" OWNER TO "postgres";


COMMENT ON VIEW "public"."agent_health_dashboard" IS 'Real-time health status of all agents';



CREATE TABLE IF NOT EXISTS "public"."agent_learnings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "agent_id" "text",
    "task_id" "uuid",
    "learning_type" "text",
    "content" "text" NOT NULL,
    "context" "jsonb",
    "confidence" numeric(3,2),
    "applied_count" integer DEFAULT 0,
    "last_applied" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "agent_learnings_learning_type_check" CHECK (("learning_type" = ANY (ARRAY['success_pattern'::"text", 'failure_pattern'::"text", 'user_preference'::"text", 'domain_knowledge'::"text"])))
);


ALTER TABLE "public"."agent_learnings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."agent_performance" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "agent_id" "text",
    "task_type" "text",
    "period_start" "date",
    "period_end" "date",
    "task_count" integer DEFAULT 0,
    "success_count" integer DEFAULT 0,
    "failure_count" integer DEFAULT 0,
    "review_count" integer DEFAULT 0,
    "approval_rate" numeric(3,2),
    "avg_duration_ms" integer,
    "avg_confidence" numeric(3,2),
    "actual_success_rate" numeric(3,2),
    "common_errors" "jsonb" DEFAULT '[]'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."agent_performance" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."agent_proposals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "agent_id" "text" NOT NULL,
    "agent_version" "text",
    "action_id" "uuid",
    "action_name" "text" NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "reasoning" "jsonb" NOT NULL,
    "proposed_action" "jsonb" NOT NULL,
    "expected_outcome" "text",
    "impact_assessment" "jsonb",
    "priority" "text" DEFAULT 'normal'::"text",
    "deadline" timestamp with time zone,
    "status" "text" DEFAULT 'pending'::"text",
    "reviewed_by" "text",
    "reviewed_at" timestamp with time zone,
    "review_notes" "text",
    "modified_action" "jsonb",
    "execution_started_at" timestamp with time zone,
    "execution_completed_at" timestamp with time zone,
    "execution_result" "jsonb",
    "execution_error" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "parent_proposal_id" "uuid",
    "child_proposal_ids" "uuid"[] DEFAULT '{}'::"uuid"[],
    "coordination_status" "text" DEFAULT 'independent'::"text",
    "target_agent_id" "text",
    "coordination_context" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "agent_proposals_priority_check" CHECK (("priority" = ANY (ARRAY['low'::"text", 'normal'::"text", 'high'::"text", 'urgent'::"text"]))),
    CONSTRAINT "agent_proposals_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'draft_ready'::"text", 'approved'::"text", 'rejected'::"text", 'modified'::"text", 'executing'::"text", 'completed'::"text", 'failed'::"text", 'expired'::"text"])))
);


ALTER TABLE "public"."agent_proposals" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."agent_requests" (
    "request_id" "text" NOT NULL,
    "source_agent" "text" NOT NULL,
    "target_agent" "text" NOT NULL,
    "action" "text" NOT NULL,
    "params" "jsonb",
    "status" "text",
    "response_data" "jsonb",
    "error_message" "text",
    "duration_ms" integer,
    "confidence" numeric(3,2),
    "sources" "jsonb" DEFAULT '[]'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "agent_requests_status_check" CHECK (("status" = ANY (ARRAY['success'::"text", 'error'::"text", 'timeout'::"text"])))
);


ALTER TABLE "public"."agent_requests" OWNER TO "postgres";


COMMENT ON TABLE "public"."agent_requests" IS 'Audit log of all inter-agent requests';



CREATE TABLE IF NOT EXISTS "public"."agent_task_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "task_type" "text",
    "assigned_agent" "text",
    "requested_by" "text",
    "source" "text" NOT NULL,
    "source_id" "text",
    "status" "text" DEFAULT 'queued'::"text",
    "priority" integer DEFAULT 2,
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "output" "jsonb",
    "reasoning" "text",
    "confidence" numeric(3,2),
    "error" "text",
    "duration_ms" integer,
    "needs_review" boolean DEFAULT false,
    "reviewed_by" "text",
    "reviewed_at" timestamp with time zone,
    "review_decision" "text",
    "review_feedback" "text",
    "human_edits" "jsonb",
    "notify_channels" "text"[] DEFAULT ARRAY['discord'::"text"],
    "reply_to" "jsonb",
    "depends_on" "uuid"[],
    "blocks" "uuid"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "agent_task_queue_priority_check" CHECK ((("priority" >= 1) AND ("priority" <= 4))),
    CONSTRAINT "agent_task_queue_review_decision_check" CHECK (("review_decision" = ANY (ARRAY['approved'::"text", 'rejected'::"text", 'edited'::"text"]))),
    CONSTRAINT "agent_task_queue_status_check" CHECK (("status" = ANY (ARRAY['queued'::"text", 'assigned'::"text", 'working'::"text", 'review'::"text", 'approved'::"text", 'done'::"text", 'failed'::"text", 'rejected'::"text", 'cancelled'::"text"])))
);


ALTER TABLE "public"."agent_task_queue" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."agents" (
    "id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "domain" "text" NOT NULL,
    "description" "text",
    "autonomy_level" integer DEFAULT 2,
    "enabled" boolean DEFAULT true,
    "current_task_id" "uuid",
    "last_heartbeat" timestamp with time zone,
    "config" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "agents_autonomy_level_check" CHECK ((("autonomy_level" >= 1) AND ("autonomy_level" <= 3)))
);


ALTER TABLE "public"."agents" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."agent_status" AS
 SELECT "a"."id",
    "a"."name",
    "a"."domain",
    "a"."autonomy_level",
    "a"."enabled",
    "a"."last_heartbeat",
        CASE
            WHEN ("a"."last_heartbeat" > ("now"() - '00:10:00'::interval)) THEN 'online'::"text"
            WHEN ("a"."last_heartbeat" > ("now"() - '01:00:00'::interval)) THEN 'idle'::"text"
            ELSE 'offline'::"text"
        END AS "status",
    "a"."current_task_id",
    "t"."title" AS "current_task_title",
    ( SELECT "count"(*) AS "count"
           FROM "public"."agent_task_queue"
          WHERE (("agent_task_queue"."assigned_agent" = "a"."id") AND ("agent_task_queue"."status" = 'done'::"text"))) AS "completed_today",
    ( SELECT "count"(*) AS "count"
           FROM "public"."agent_task_queue"
          WHERE (("agent_task_queue"."assigned_agent" = "a"."id") AND ("agent_task_queue"."status" = 'review'::"text"))) AS "pending_review"
   FROM ("public"."agents" "a"
     LEFT JOIN "public"."agent_task_queue" "t" ON (("a"."current_task_id" = "t"."id")));


ALTER VIEW "public"."agent_status" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."agentic_chat" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_id" "uuid",
    "task_id" "uuid",
    "role" "text" NOT NULL,
    "agent_type" "text",
    "content" "text" NOT NULL,
    "action_taken" "jsonb",
    "artifacts" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "agentic_chat_role_check" CHECK (("role" = ANY (ARRAY['user'::"text", 'agent'::"text", 'system'::"text"])))
);


ALTER TABLE "public"."agentic_chat" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."agentic_project_dashboard" AS
SELECT
    NULL::"uuid" AS "id",
    NULL::"text" AS "name",
    NULL::"text" AS "goal",
    NULL::"text" AS "status",
    NULL::"text" AS "owner",
    NULL::timestamp with time zone AS "created_at",
    NULL::bigint AS "total_tasks",
    NULL::bigint AS "completed_tasks",
    NULL::bigint AS "agent_working",
    NULL::bigint AS "needs_review",
    NULL::bigint AS "agent_tasks",
    NULL::bigint AS "human_tasks";


ALTER VIEW "public"."agentic_project_dashboard" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."agentic_projects" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "goal" "text" NOT NULL,
    "context" "jsonb" DEFAULT '{}'::"jsonb",
    "status" "text" DEFAULT 'active'::"text",
    "owner" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "agentic_projects_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'completed'::"text", 'paused'::"text", 'archived'::"text"])))
);


ALTER TABLE "public"."agentic_projects" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."agentic_tasks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_id" "uuid",
    "title" "text" NOT NULL,
    "description" "text",
    "task_type" "text" DEFAULT 'action'::"text",
    "assigned_human" "text",
    "assigned_agent" "text",
    "assignment_mode" "text" DEFAULT 'agent'::"text",
    "status" "text" DEFAULT 'pending'::"text",
    "priority" integer DEFAULT 2,
    "agent_output" "jsonb",
    "agent_reasoning" "text",
    "agent_confidence" numeric(3,2),
    "agent_started_at" timestamp with time zone,
    "agent_completed_at" timestamp with time zone,
    "human_feedback" "text",
    "human_approved" boolean,
    "human_edits" "jsonb",
    "depends_on" "uuid"[],
    "position" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "agentic_tasks_assignment_mode_check" CHECK (("assignment_mode" = ANY (ARRAY['human'::"text", 'agent'::"text", 'dual'::"text", 'review'::"text"]))),
    CONSTRAINT "agentic_tasks_priority_check" CHECK ((("priority" >= 1) AND ("priority" <= 4))),
    CONSTRAINT "agentic_tasks_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'in_progress'::"text", 'agent_working'::"text", 'needs_review'::"text", 'completed'::"text", 'blocked'::"text"]))),
    CONSTRAINT "agentic_tasks_task_type_check" CHECK (("task_type" = ANY (ARRAY['research'::"text", 'draft'::"text", 'calculate'::"text", 'action'::"text", 'review'::"text", 'decision'::"text"])))
);


ALTER TABLE "public"."agentic_tasks" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."agentic_work_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_id" "uuid",
    "task_id" "uuid",
    "agent_type" "text" NOT NULL,
    "action" "text" NOT NULL,
    "input_summary" "jsonb",
    "output_summary" "jsonb",
    "duration_ms" integer,
    "tokens_used" integer,
    "model_used" "text",
    "success" boolean DEFAULT true,
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."agentic_work_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ai_content_verifications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "content_id" "uuid",
    "content_type" "text" NOT NULL,
    "project_slug" "text",
    "generated_content" "text" NOT NULL,
    "final_content" "text",
    "brand_voice_score" integer,
    "cultural_safety_score" integer,
    "factual_accuracy_score" integer,
    "community_voice_score" integer,
    "overall_quality_score" integer,
    "human_notes" "text",
    "improvement_suggestions" "text"[],
    "issues_found" "text"[],
    "verified_by" "uuid",
    "verified_at" timestamp with time zone DEFAULT "now"(),
    "status" "text" NOT NULL,
    "requires_elder_review" boolean DEFAULT false,
    "elder_reviewed_by" "uuid",
    "elder_reviewed_at" timestamp with time zone,
    "elder_notes" "text",
    "used_for_training" boolean DEFAULT false,
    "training_added_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "ai_content_verifications_brand_voice_score_check" CHECK ((("brand_voice_score" >= 1) AND ("brand_voice_score" <= 5))),
    CONSTRAINT "ai_content_verifications_community_voice_score_check" CHECK ((("community_voice_score" >= 1) AND ("community_voice_score" <= 5))),
    CONSTRAINT "ai_content_verifications_cultural_safety_score_check" CHECK ((("cultural_safety_score" >= 1) AND ("cultural_safety_score" <= 5))),
    CONSTRAINT "ai_content_verifications_factual_accuracy_score_check" CHECK ((("factual_accuracy_score" >= 1) AND ("factual_accuracy_score" <= 5))),
    CONSTRAINT "ai_content_verifications_overall_quality_score_check" CHECK ((("overall_quality_score" >= 1) AND ("overall_quality_score" <= 5))),
    CONSTRAINT "ai_content_verifications_status_check" CHECK (("status" = ANY (ARRAY['approved'::"text", 'revised'::"text", 'rejected'::"text"])))
);


ALTER TABLE "public"."ai_content_verifications" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ai_discoveries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "storyteller_id" "uuid",
    "transcript_id" "uuid",
    "discovery_type" "text" NOT NULL,
    "extracted_text" "text" NOT NULL,
    "context_before" "text",
    "context_after" "text",
    "confidence_score" double precision,
    "human_verified" boolean DEFAULT false,
    "verification_notes" "text",
    "discovered_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "ai_discoveries_confidence_score_check" CHECK ((("confidence_score" >= (0)::double precision) AND ("confidence_score" <= (1)::double precision)))
);


ALTER TABLE "public"."ai_discoveries" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_discoveries" IS 'AI-discovered insights from storyteller transcripts - authentic expressions of vision, skills, needs, achievements';



CREATE TABLE IF NOT EXISTS "public"."alma_community_contexts" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "name" "text" NOT NULL,
    "context_type" "text" NOT NULL,
    "location" "text",
    "state" "text",
    "population_size" "text",
    "demographics" "text",
    "system_factors" "text",
    "protective_factors" "text",
    "cultural_authority" "text" NOT NULL,
    "consent_level" "text" DEFAULT 'Strictly Private'::"text" NOT NULL,
    "contributors" "text"[] DEFAULT '{}'::"text"[],
    "search_vector" "tsvector",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "alma_community_contexts_consent_level_check" CHECK (("consent_level" = ANY (ARRAY['Public Knowledge Commons'::"text", 'Community Controlled'::"text", 'Strictly Private'::"text"]))),
    CONSTRAINT "alma_community_contexts_context_type_check" CHECK (("context_type" = ANY (ARRAY['First Nations community'::"text", 'Remote community'::"text", 'Regional area'::"text", 'Metro suburb'::"text", 'Cultural community'::"text", 'Care system'::"text", 'Education setting'::"text"]))),
    CONSTRAINT "alma_community_contexts_population_size_check" CHECK (("population_size" = ANY (ARRAY['<1,000'::"text", '1,000-10,000'::"text", '10,000-50,000'::"text", '50,000+'::"text", 'Unknown'::"text"]))),
    CONSTRAINT "alma_community_contexts_state_check" CHECK (("state" = ANY (ARRAY['VIC'::"text", 'NSW'::"text", 'QLD'::"text", 'SA'::"text", 'WA'::"text", 'TAS'::"text", 'NT'::"text", 'ACT'::"text"])))
);


ALTER TABLE "public"."alma_community_contexts" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_community_contexts" IS 'Place-based and cultural contexts where interventions operate';



COMMENT ON COLUMN "public"."alma_community_contexts"."cultural_authority" IS 'ALWAYS REQUIRED - who has authority to speak about this context';



CREATE TABLE IF NOT EXISTS "public"."alma_consent_ledger" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "entity_type" "text" NOT NULL,
    "entity_id" "uuid" NOT NULL,
    "consent_level" "text" NOT NULL,
    "permitted_uses" "text"[] DEFAULT '{}'::"text"[],
    "cultural_authority" "text",
    "contributors" "jsonb" DEFAULT '[]'::"jsonb",
    "attribution_text" "text",
    "consent_given_by" "text",
    "consent_given_at" timestamp with time zone DEFAULT "now"(),
    "consent_expires_at" timestamp with time zone,
    "consent_revoked" boolean DEFAULT false,
    "consent_revoked_at" timestamp with time zone,
    "consent_revoked_by" "text",
    "revenue_share_enabled" boolean DEFAULT false,
    "revenue_share_percentage" numeric(5,2),
    "notes" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "alma_consent_ledger_consent_level_check" CHECK (("consent_level" = ANY (ARRAY['Public Knowledge Commons'::"text", 'Community Controlled'::"text", 'Strictly Private'::"text"]))),
    CONSTRAINT "alma_consent_ledger_entity_type_check" CHECK (("entity_type" = ANY (ARRAY['intervention'::"text", 'context'::"text", 'evidence'::"text", 'outcome'::"text"])))
);


ALTER TABLE "public"."alma_consent_ledger" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_consent_ledger" IS 'Governance ledger tracking all consent and permissions - foundation of ALMA ethics';



CREATE TABLE IF NOT EXISTS "public"."alma_content_entities" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "raw_content_id" "uuid" NOT NULL,
    "entity_type" "text" NOT NULL,
    "entity_id" "uuid" NOT NULL,
    "extraction_confidence" numeric(3,2) DEFAULT 1.00,
    "extraction_method" "text",
    "extracted_at" timestamp with time zone DEFAULT "now"(),
    "content_start_pos" integer,
    "content_end_pos" integer,
    "matched_text" "text",
    CONSTRAINT "alma_content_entities_entity_type_check" CHECK (("entity_type" = ANY (ARRAY['intervention'::"text", 'evidence'::"text", 'outcome'::"text", 'context'::"text", 'funding'::"text"])))
);


ALTER TABLE "public"."alma_content_entities" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_funding_data" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "source_url" "text" NOT NULL,
    "source_name" "text" NOT NULL,
    "source_type" "text",
    "report_year" "text" NOT NULL,
    "jurisdiction" "text",
    "total_expenditure" numeric(15,2),
    "detention_expenditure" numeric(15,2),
    "community_expenditure" numeric(15,2),
    "diversion_expenditure" numeric(15,2),
    "prevention_expenditure" numeric(15,2),
    "cost_per_day_detention" numeric(10,2),
    "cost_per_day_community" numeric(10,2),
    "cost_per_participant" numeric(10,2),
    "young_people_supervised" integer,
    "young_people_detained" integer,
    "indigenous_percentage" numeric(5,2),
    "recidivism_rate" numeric(5,2),
    "completion_rate" numeric(5,2),
    "raw_data" "jsonb" DEFAULT '{}'::"jsonb",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "alma_funding_data_jurisdiction_check" CHECK (("jurisdiction" = ANY (ARRAY['VIC'::"text", 'QLD'::"text", 'NSW'::"text", 'NT'::"text", 'SA'::"text", 'WA'::"text", 'TAS'::"text", 'ACT'::"text", 'National'::"text"]))),
    CONSTRAINT "alma_funding_data_source_type_check" CHECK (("source_type" = ANY (ARRAY['government'::"text", 'research'::"text", 'budget'::"text", 'audit'::"text"])))
);


ALTER TABLE "public"."alma_funding_data" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_funding_data" IS 'Youth justice expenditure data for cost-effectiveness analysis';



CREATE OR REPLACE VIEW "public"."alma_cost_analysis" AS
 SELECT "jurisdiction",
    "report_year",
    "total_expenditure",
    "detention_expenditure",
    "community_expenditure",
        CASE
            WHEN ("total_expenditure" > (0)::numeric) THEN "round"((("detention_expenditure" / "total_expenditure") * (100)::numeric), 1)
            ELSE NULL::numeric
        END AS "detention_percent",
        CASE
            WHEN ("total_expenditure" > (0)::numeric) THEN "round"((("community_expenditure" / "total_expenditure") * (100)::numeric), 1)
            ELSE NULL::numeric
        END AS "community_percent",
    "cost_per_day_detention",
    "cost_per_day_community",
        CASE
            WHEN ("cost_per_day_community" > (0)::numeric) THEN "round"(("cost_per_day_detention" / "cost_per_day_community"), 1)
            ELSE NULL::numeric
        END AS "detention_vs_community_ratio",
    "recidivism_rate",
    "indigenous_percentage"
   FROM "public"."alma_funding_data"
  WHERE ("total_expenditure" IS NOT NULL)
  ORDER BY "jurisdiction", "report_year" DESC;


ALTER VIEW "public"."alma_cost_analysis" OWNER TO "postgres";


COMMENT ON VIEW "public"."alma_cost_analysis" IS 'Pre-calculated cost analysis by jurisdiction';



CREATE TABLE IF NOT EXISTS "public"."alma_coverage_metrics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "calculated_at" timestamp with time zone DEFAULT "now"(),
    "dimension_type" "text",
    "dimension_value" "text" NOT NULL,
    "source_count" integer DEFAULT 0,
    "intervention_count" integer DEFAULT 0,
    "evidence_count" integer DEFAULT 0,
    "last_update" timestamp with time zone,
    "update_frequency_avg" numeric(5,2),
    "coverage_score" numeric(5,2),
    "recommended_sources" "text"[],
    "priority_rank" integer,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "alma_coverage_metrics_dimension_type_check" CHECK (("dimension_type" = ANY (ARRAY['jurisdiction'::"text", 'topic'::"text", 'source_type'::"text", 'organization'::"text"])))
);


ALTER TABLE "public"."alma_coverage_metrics" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_coverage_metrics" IS 'Calculated coverage by jurisdiction, topic, etc.';



CREATE TABLE IF NOT EXISTS "public"."alma_media_articles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "job_id" "uuid",
    "headline" "text" NOT NULL,
    "url" "text",
    "published_date" timestamp with time zone,
    "source_name" "text",
    "sentiment" "text",
    "sentiment_score" numeric,
    "confidence" numeric,
    "topics" "text"[],
    "government_mentions" "jsonb",
    "community_mentions" "jsonb",
    "intervention_mentions" "uuid"[],
    "summary" "text",
    "key_quotes" "text"[],
    "full_text" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "alma_media_articles_confidence_check" CHECK ((("confidence" >= 0.0) AND ("confidence" <= 1.0))),
    CONSTRAINT "alma_media_articles_sentiment_check" CHECK (("sentiment" = ANY (ARRAY['positive'::"text", 'negative'::"text", 'neutral'::"text", 'mixed'::"text"]))),
    CONSTRAINT "alma_media_articles_sentiment_score_check" CHECK ((("sentiment_score" >= '-1.0'::numeric) AND ("sentiment_score" <= 1.0)))
);


ALTER TABLE "public"."alma_media_articles" OWNER TO "postgres";


CREATE MATERIALIZED VIEW "public"."alma_daily_sentiment" AS
 SELECT "date_trunc"('day'::"text", "published_date") AS "date",
    "source_name",
    "count"(*) AS "article_count",
    "avg"("sentiment_score") AS "avg_sentiment",
    "stddev"("sentiment_score") AS "sentiment_stddev",
    "count"(*) FILTER (WHERE ("sentiment" = 'positive'::"text")) AS "positive_count",
    "count"(*) FILTER (WHERE ("sentiment" = 'negative'::"text")) AS "negative_count",
    "count"(*) FILTER (WHERE ("sentiment" = 'neutral'::"text")) AS "neutral_count",
    "count"(*) FILTER (WHERE ("sentiment" = 'mixed'::"text")) AS "mixed_count"
   FROM "public"."alma_media_articles"
  WHERE ("published_date" IS NOT NULL)
  GROUP BY ("date_trunc"('day'::"text", "published_date")), "source_name"
  ORDER BY ("date_trunc"('day'::"text", "published_date")) DESC
  WITH NO DATA;


ALTER MATERIALIZED VIEW "public"."alma_daily_sentiment" OWNER TO "postgres";


CREATE MATERIALIZED VIEW "public"."alma_dashboard_funding" AS
 SELECT "jurisdiction",
    "report_year",
    "sum"("total_expenditure") AS "total_expenditure",
    "sum"("detention_expenditure") AS "detention_expenditure",
    "sum"("community_expenditure") AS "community_expenditure",
    "avg"("cost_per_day_detention") AS "avg_detention_cost_per_day",
    "avg"("cost_per_day_community") AS "avg_community_cost_per_day",
        CASE
            WHEN ("sum"("total_expenditure") > (0)::numeric) THEN "round"((("sum"("detention_expenditure") / "sum"("total_expenditure")) * (100)::numeric), 1)
            ELSE NULL::numeric
        END AS "detention_percentage"
   FROM "public"."alma_funding_data"
  WHERE ("total_expenditure" IS NOT NULL)
  GROUP BY "jurisdiction", "report_year"
  WITH NO DATA;


ALTER MATERIALIZED VIEW "public"."alma_dashboard_funding" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_interventions" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "name" "text" NOT NULL,
    "type" "text" NOT NULL,
    "description" "text" NOT NULL,
    "target_cohort" "text"[] DEFAULT '{}'::"text"[],
    "geography" "text"[] DEFAULT '{}'::"text"[],
    "evidence_level" "text",
    "cultural_authority" "text",
    "consent_level" "text" DEFAULT 'Strictly Private'::"text" NOT NULL,
    "permitted_uses" "text"[] DEFAULT ARRAY['Query (internal)'::"text"],
    "contributors" "text"[] DEFAULT '{}'::"text"[],
    "source_documents" "jsonb" DEFAULT '[]'::"jsonb",
    "risks" "text",
    "harm_risk_level" "text",
    "implementation_cost" "text",
    "cost_per_young_person" numeric(10,2),
    "scalability" "text",
    "replication_readiness" "text",
    "operating_organization" "text",
    "contact_person" "text",
    "contact_email" "text",
    "contact_phone" "text",
    "website" "text",
    "years_operating" integer,
    "current_funding" "text",
    "portfolio_score" numeric(5,4),
    "evidence_strength_signal" numeric(5,4),
    "community_authority_signal" numeric(5,4),
    "harm_risk_signal" numeric(5,4),
    "implementation_capability_signal" numeric(5,4),
    "option_value_signal" numeric(5,4),
    "review_status" "text" DEFAULT 'Draft'::"text" NOT NULL,
    "reviewed_by" "uuid",
    "reviewed_at" timestamp with time zone,
    "linked_service_id" "uuid",
    "linked_community_program_id" "uuid",
    "search_vector" "tsvector",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "operating_organization_id" "uuid",
    "latitude" numeric(10,8),
    "longitude" numeric(11,8),
    "service_area_km" integer,
    "location_type" "text",
    CONSTRAINT "alma_interventions_consent_level_check" CHECK (("consent_level" = ANY (ARRAY['Public Knowledge Commons'::"text", 'Community Controlled'::"text", 'Strictly Private'::"text"]))),
    CONSTRAINT "alma_interventions_current_funding_check" CHECK (("current_funding" = ANY (ARRAY['Unfunded'::"text", 'Pilot/seed'::"text", 'Established'::"text", 'Oversubscribed'::"text", 'At-risk'::"text"]))),
    CONSTRAINT "alma_interventions_evidence_level_check" CHECK (("evidence_level" = ANY (ARRAY['Promising (community-endorsed, emerging evidence)'::"text", 'Effective (strong evaluation, positive outcomes)'::"text", 'Proven (RCT/quasi-experimental, replicated)'::"text", 'Indigenous-led (culturally grounded, community authority)'::"text", 'Untested (theory/pilot stage)'::"text"]))),
    CONSTRAINT "alma_interventions_harm_risk_level_check" CHECK (("harm_risk_level" = ANY (ARRAY['Low'::"text", 'Medium'::"text", 'High'::"text", 'Requires cultural review'::"text"]))),
    CONSTRAINT "alma_interventions_implementation_cost_check" CHECK (("implementation_cost" = ANY (ARRAY['Low (<$50k/year)'::"text", 'Medium ($50k-$250k)'::"text", 'High (>$250k)'::"text", 'Unknown'::"text"]))),
    CONSTRAINT "alma_interventions_location_type_check" CHECK (("location_type" = ANY (ARRAY['metropolitan'::"text", 'regional'::"text", 'rural'::"text", 'remote'::"text", 'very_remote'::"text", 'statewide'::"text", 'national'::"text"]))),
    CONSTRAINT "alma_interventions_replication_readiness_check" CHECK (("replication_readiness" = ANY (ARRAY['Not ready (needs more development)'::"text", 'Ready with support (requires adaptation guidance)'::"text", 'Ready (playbook available)'::"text", 'Community authority required'::"text"]))),
    CONSTRAINT "alma_interventions_review_status_check" CHECK (("review_status" = ANY (ARRAY['Draft'::"text", 'Community Review'::"text", 'Approved'::"text", 'Published'::"text", 'Archived'::"text"]))),
    CONSTRAINT "alma_interventions_scalability_check" CHECK (("scalability" = ANY (ARRAY['Local only'::"text", 'Regional'::"text", 'State-wide'::"text", 'National'::"text", 'Context-dependent'::"text"]))),
    CONSTRAINT "alma_interventions_type_check" CHECK (("type" = ANY (ARRAY['Prevention'::"text", 'Early Intervention'::"text", 'Diversion'::"text", 'Therapeutic'::"text", 'Wraparound Support'::"text", 'Family Strengthening'::"text", 'Cultural Connection'::"text", 'Education/Employment'::"text", 'Justice Reinvestment'::"text", 'Community-Led'::"text"]))),
    CONSTRAINT "check_cultural_authority_required" CHECK ((("consent_level" = 'Public Knowledge Commons'::"text") OR ("cultural_authority" IS NOT NULL)))
);


ALTER TABLE "public"."alma_interventions" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_interventions" IS 'ALMA interventions - programs and practices addressing youth justice outcomes with community governance';



COMMENT ON COLUMN "public"."alma_interventions"."cultural_authority" IS 'REQUIRED for Community Controlled and Strictly Private - enforced by constraint';



COMMENT ON COLUMN "public"."alma_interventions"."consent_level" IS 'Governance tier - defaults to Strictly Private, requires explicit escalation';



COMMENT ON COLUMN "public"."alma_interventions"."portfolio_score" IS 'Weighted combination of 5 signals: evidence(25%), authority(30%), harm(20%), capability(15%), option(10%)';



COMMENT ON COLUMN "public"."alma_interventions"."operating_organization_id" IS 'Links to organizations table - keeps operating_organization text for backwards compatibility';



CREATE MATERIALIZED VIEW "public"."alma_dashboard_interventions" AS
 SELECT COALESCE("geography"[1], 'National'::"text") AS "jurisdiction",
    "type" AS "intervention_type",
    "evidence_level",
    "count"(*) AS "count",
    "count"(*) FILTER (WHERE ("evidence_level" = ANY (ARRAY['Proven'::"text", 'Effective'::"text"]))) AS "evidence_backed_count",
    "avg"("portfolio_score") AS "avg_portfolio_score",
    "count"(*) FILTER (WHERE ("review_status" = 'Published'::"text")) AS "published_count"
   FROM "public"."alma_interventions"
  GROUP BY COALESCE("geography"[1], 'National'::"text"), "type", "evidence_level"
  WITH NO DATA;


ALTER MATERIALIZED VIEW "public"."alma_dashboard_interventions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_discovered_links" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "url" "text" NOT NULL,
    "title" "text",
    "discovered_from" "text" NOT NULL,
    "predicted_type" "text",
    "predicted_relevance" numeric(5,2),
    "jurisdiction_hint" "text",
    "status" "text" DEFAULT 'pending'::"text",
    "priority" integer DEFAULT 0,
    "rejection_reason" "text",
    "error_message" "text",
    "scraped_at" timestamp with time zone,
    "added_to_registry" boolean DEFAULT false,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "relevance_category" "text",
    CONSTRAINT "alma_discovered_links_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'queued'::"text", 'scraped'::"text", 'rejected'::"text", 'error'::"text"])))
);


ALTER TABLE "public"."alma_discovered_links" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_discovered_links" IS 'Links discovered during scraping for follow-up';



CREATE MATERIALIZED VIEW "public"."alma_dashboard_queue" AS
 SELECT "status",
    "predicted_type" AS "source_type",
    "jurisdiction_hint" AS "jurisdiction",
    "count"(*) AS "count",
    "avg"("priority") AS "avg_priority",
    "min"("created_at") AS "oldest_pending"
   FROM "public"."alma_discovered_links"
  GROUP BY "status", "predicted_type", "jurisdiction_hint"
  WITH NO DATA;


ALTER MATERIALIZED VIEW "public"."alma_dashboard_queue" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_source_registry" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "url" "text" NOT NULL,
    "name" "text" NOT NULL,
    "organization" "text",
    "source_type" "text",
    "jurisdiction" "text",
    "cultural_authority" boolean DEFAULT false,
    "consent_level" "text" DEFAULT 'Public Knowledge Commons'::"text",
    "last_scraped_at" timestamp with time zone,
    "scrape_count" integer DEFAULT 0,
    "success_count" integer DEFAULT 0,
    "failure_count" integer DEFAULT 0,
    "success_rate" numeric(5,2) GENERATED ALWAYS AS (
CASE
    WHEN ("scrape_count" > 0) THEN ((("success_count")::numeric / ("scrape_count")::numeric) * (100)::numeric)
    ELSE (0)::numeric
END) STORED,
    "total_entities_extracted" integer DEFAULT 0,
    "avg_entities_per_scrape" numeric(5,2) GENERATED ALWAYS AS (
CASE
    WHEN ("success_count" > 0) THEN (("total_entities_extracted")::numeric / ("success_count")::numeric)
    ELSE (0)::numeric
END) STORED,
    "quality_score" numeric(5,2) DEFAULT 5.0,
    "discovered_from" "text",
    "discovered_at" timestamp with time zone,
    "child_links" "text"[] DEFAULT '{}'::"text"[],
    "priority_score" numeric(5,2) DEFAULT 5.0,
    "update_frequency" "text" DEFAULT 'monthly'::"text",
    "next_scrape_at" timestamp with time zone,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "alma_source_registry_jurisdiction_check" CHECK (("jurisdiction" = ANY (ARRAY['VIC'::"text", 'QLD'::"text", 'NSW'::"text", 'NT'::"text", 'SA'::"text", 'WA'::"text", 'TAS'::"text", 'ACT'::"text", 'National'::"text", 'International'::"text"]))),
    CONSTRAINT "alma_source_registry_source_type_check" CHECK (("source_type" = ANY (ARRAY['government'::"text", 'indigenous'::"text", 'research'::"text", 'media'::"text", 'advocacy'::"text", 'legal'::"text", 'inquiry'::"text"]))),
    CONSTRAINT "alma_source_registry_update_frequency_check" CHECK (("update_frequency" = ANY (ARRAY['daily'::"text", 'weekly'::"text", 'monthly'::"text", 'quarterly'::"text", 'yearly'::"text", 'once'::"text"])))
);


ALTER TABLE "public"."alma_source_registry" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_source_registry" IS 'Registry of all known sources with learning metrics';



CREATE MATERIALIZED VIEW "public"."alma_dashboard_sources" AS
 SELECT "source_type",
    "jurisdiction",
    "count"(*) AS "source_count",
    "avg"("success_rate") AS "avg_success_rate",
    "avg"("quality_score") AS "avg_quality_score",
    "sum"("total_entities_extracted") AS "total_entities",
    "max"("last_scraped_at") AS "last_scraped"
   FROM "public"."alma_source_registry"
  GROUP BY "source_type", "jurisdiction"
  WITH NO DATA;


ALTER MATERIALIZED VIEW "public"."alma_dashboard_sources" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_entity_tags" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "entity_type" "text" NOT NULL,
    "entity_id" "uuid" NOT NULL,
    "tag_id" "uuid" NOT NULL,
    "tagged_by" "uuid",
    "confidence" numeric(3,2) DEFAULT 1.00,
    CONSTRAINT "alma_entity_tags_entity_type_check" CHECK (("entity_type" = ANY (ARRAY['intervention'::"text", 'evidence'::"text", 'outcome'::"text", 'context'::"text", 'raw_content'::"text", 'funding'::"text"])))
);


ALTER TABLE "public"."alma_entity_tags" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_tags" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "category" "text" NOT NULL,
    "name" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "parent_id" "uuid",
    "display_name" "text",
    "description" "text",
    "color" "text",
    "icon" "text",
    "is_system" boolean DEFAULT false,
    "usage_count" integer DEFAULT 0
);


ALTER TABLE "public"."alma_tags" OWNER TO "postgres";


CREATE MATERIALIZED VIEW "public"."alma_dashboard_tags" AS
 SELECT "t"."category",
    "t"."name",
    "t"."slug",
    "count"("et"."id") AS "usage_count",
    "count"(DISTINCT "et"."entity_id") AS "unique_entities"
   FROM ("public"."alma_tags" "t"
     LEFT JOIN "public"."alma_entity_tags" "et" ON (("t"."id" = "et"."tag_id")))
  GROUP BY "t"."id", "t"."category", "t"."name", "t"."slug"
  WITH NO DATA;


ALTER MATERIALIZED VIEW "public"."alma_dashboard_tags" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_embeddings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "entity_type" "text" NOT NULL,
    "entity_id" "uuid" NOT NULL,
    "embedding_model" "text" DEFAULT 'text-embedding-3-small'::"text" NOT NULL,
    "embedding_dimensions" integer DEFAULT 1536 NOT NULL,
    "embedding_data" "jsonb" NOT NULL,
    "source_text" "text" NOT NULL,
    "source_text_hash" "text" NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "alma_embeddings_entity_type_check" CHECK (("entity_type" = ANY (ARRAY['intervention'::"text", 'evidence'::"text", 'outcome'::"text", 'context'::"text", 'raw_content'::"text", 'funding'::"text"])))
);


ALTER TABLE "public"."alma_embeddings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_entity_sources" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "entity_type" "text" NOT NULL,
    "entity_id" "uuid" NOT NULL,
    "source_document_id" "uuid" NOT NULL,
    "page_numbers" "text",
    "section_reference" "text",
    "quote" "text",
    "citation_context" "text",
    "verified_by" "uuid",
    "verified_at" timestamp with time zone,
    CONSTRAINT "alma_entity_sources_entity_type_check" CHECK (("entity_type" = ANY (ARRAY['intervention'::"text", 'evidence'::"text", 'outcome'::"text", 'context'::"text", 'funding'::"text"])))
);


ALTER TABLE "public"."alma_entity_sources" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_evidence" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "title" "text" NOT NULL,
    "evidence_type" "text" NOT NULL,
    "methodology" "text",
    "sample_size" integer,
    "timeframe" "text",
    "findings" "text" NOT NULL,
    "effect_size" "text",
    "limitations" "text",
    "cultural_safety" "text",
    "author" "text",
    "organization" "text",
    "publication_date" "date",
    "doi" "text",
    "source_url" "text",
    "source_document_url" "text",
    "consent_level" "text" DEFAULT 'Strictly Private'::"text" NOT NULL,
    "contributors" "text"[] DEFAULT '{}'::"text"[],
    "search_vector" "tsvector",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "author_profile_id" "uuid",
    CONSTRAINT "alma_evidence_consent_level_check" CHECK (("consent_level" = ANY (ARRAY['Public Knowledge Commons'::"text", 'Community Controlled'::"text", 'Strictly Private'::"text"]))),
    CONSTRAINT "alma_evidence_cultural_safety_check" CHECK (("cultural_safety" = ANY (ARRAY['Culturally grounded (led by community)'::"text", 'Culturally adapted (with community input)'::"text", 'Culturally neutral'::"text", 'Cultural safety concerns'::"text", 'Unknown'::"text"]))),
    CONSTRAINT "alma_evidence_effect_size_check" CHECK (("effect_size" = ANY (ARRAY['Large positive'::"text", 'Moderate positive'::"text", 'Small positive'::"text", 'Null'::"text", 'Mixed'::"text", 'Not measured'::"text"]))),
    CONSTRAINT "alma_evidence_evidence_type_check" CHECK (("evidence_type" = ANY (ARRAY['RCT (Randomized Control Trial)'::"text", 'Quasi-experimental'::"text", 'Program evaluation'::"text", 'Longitudinal study'::"text", 'Case study'::"text", 'Community-led research'::"text", 'Lived experience'::"text", 'Cultural knowledge'::"text", 'Policy analysis'::"text"])))
);


ALTER TABLE "public"."alma_evidence" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_evidence" IS 'Research, evaluations, and outcome data supporting interventions';



COMMENT ON COLUMN "public"."alma_evidence"."cultural_safety" IS 'Assessment of cultural grounding and community leadership';



COMMENT ON COLUMN "public"."alma_evidence"."author_profile_id" IS 'Links to public_profiles for author - keeps author text field for backwards compatibility';



CREATE TABLE IF NOT EXISTS "public"."alma_evidence_outcomes" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "evidence_id" "uuid" NOT NULL,
    "outcome_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."alma_evidence_outcomes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_external_source_cache" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "url" "text" NOT NULL,
    "content_hash" "text",
    "parsed_content" "jsonb",
    "source_type" "text",
    "fetched_at" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone DEFAULT ("now"() + '7 days'::interval),
    "title" "text",
    "publication_date" "date",
    "author" "text"
);


ALTER TABLE "public"."alma_external_source_cache" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_extraction_patterns" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "source_type" "text" NOT NULL,
    "pattern_name" "text" NOT NULL,
    "pattern_version" integer DEFAULT 1,
    "extraction_prompt" "text" NOT NULL,
    "times_used" integer DEFAULT 0,
    "successful_extractions" integer DEFAULT 0,
    "total_entities_extracted" integer DEFAULT 0,
    "success_rate" numeric(5,2) GENERATED ALWAYS AS (
CASE
    WHEN ("times_used" > 0) THEN ((("successful_extractions")::numeric / ("times_used")::numeric) * (100)::numeric)
    ELSE (0)::numeric
END) STORED,
    "avg_entities" numeric(5,2) GENERATED ALWAYS AS (
CASE
    WHEN ("successful_extractions" > 0) THEN (("total_entities_extracted")::numeric / ("successful_extractions")::numeric)
    ELSE (0)::numeric
END) STORED,
    "is_active" boolean DEFAULT true,
    "last_used_at" timestamp with time zone,
    "superseded_by" "uuid",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."alma_extraction_patterns" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_extraction_patterns" IS 'Learned extraction prompts that improve over time';



CREATE TABLE IF NOT EXISTS "public"."alma_funding_applications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "opportunity_id" "uuid" NOT NULL,
    "organization_id" "uuid",
    "status" "text" DEFAULT 'identified'::"text" NOT NULL,
    "amount_requested" numeric,
    "amount_awarded" numeric,
    "submitted_at" timestamp with time zone,
    "outcome_at" timestamp with time zone,
    "notes" "text",
    "internal_match_score" numeric,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "alma_funding_applications_status_check" CHECK (("status" = ANY (ARRAY['identified'::"text", 'evaluating'::"text", 'preparing'::"text", 'submitted'::"text", 'under_review'::"text", 'successful'::"text", 'unsuccessful'::"text", 'withdrawn'::"text"])))
);


ALTER TABLE "public"."alma_funding_applications" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_funding_applications" IS 'Track basecamp applications to funding opportunities';



CREATE TABLE IF NOT EXISTS "public"."alma_funding_opportunities" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "funder_name" "text" NOT NULL,
    "source_type" "text" NOT NULL,
    "category" "text",
    "total_pool_amount" numeric,
    "min_grant_amount" numeric,
    "max_grant_amount" numeric,
    "funding_duration" "text",
    "opens_at" timestamp with time zone,
    "deadline" timestamp with time zone,
    "decision_date" timestamp with time zone,
    "status" "text" DEFAULT 'open'::"text" NOT NULL,
    "jurisdictions" "text"[] DEFAULT '{}'::"text"[],
    "regions" "text"[] DEFAULT '{}'::"text"[],
    "is_national" boolean DEFAULT false,
    "eligibility_criteria" "jsonb" DEFAULT '{}'::"jsonb",
    "eligible_org_types" "text"[] DEFAULT '{}'::"text"[],
    "requires_deductible_gift_recipient" boolean DEFAULT false,
    "requires_abn" boolean DEFAULT true,
    "focus_areas" "text"[] DEFAULT '{}'::"text"[],
    "keywords" "text"[] DEFAULT '{}'::"text"[],
    "source_url" "text",
    "application_url" "text",
    "guidelines_url" "text",
    "source_id" "text",
    "scraped_at" timestamp with time zone,
    "scrape_source" "text",
    "raw_data" "jsonb",
    "relevance_score" numeric DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "alma_funding_opportunities_category_check" CHECK (("category" = ANY (ARRAY['youth_justice'::"text", 'indigenous_programs'::"text", 'mental_health'::"text", 'education'::"text", 'employment'::"text", 'housing'::"text", 'family_services'::"text", 'community_development'::"text", 'research'::"text", 'capacity_building'::"text", 'general'::"text"]))),
    CONSTRAINT "alma_funding_opportunities_source_type_check" CHECK (("source_type" = ANY (ARRAY['government'::"text", 'philanthropy'::"text", 'corporate'::"text", 'community'::"text"]))),
    CONSTRAINT "alma_funding_opportunities_status_check" CHECK (("status" = ANY (ARRAY['upcoming'::"text", 'open'::"text", 'closing_soon'::"text", 'closed'::"text", 'recurring'::"text", 'archived'::"text"]))),
    CONSTRAINT "valid_amounts" CHECK ((("min_grant_amount" IS NULL) OR ("max_grant_amount" IS NULL) OR ("min_grant_amount" <= "max_grant_amount"))),
    CONSTRAINT "valid_timeline" CHECK ((("opens_at" IS NULL) OR ("deadline" IS NULL) OR ("opens_at" <= "deadline")))
);


ALTER TABLE "public"."alma_funding_opportunities" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_funding_opportunities" IS 'Funding opportunities from government, philanthropy, corporate, and community sources';



CREATE TABLE IF NOT EXISTS "public"."alma_government_programs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "jurisdiction" "text",
    "program_type" "text",
    "announced_date" "date",
    "implementation_date" "date",
    "status" "text",
    "budget_amount" numeric,
    "budget_currency" "text" DEFAULT 'AUD'::"text",
    "description" "text",
    "official_url" "text",
    "community_led" boolean DEFAULT false,
    "cultural_authority" boolean DEFAULT false,
    "consent_level" "text" DEFAULT 'Public Knowledge Commons'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "alma_government_programs_status_check" CHECK (("status" = ANY (ARRAY['announced'::"text", 'in_progress'::"text", 'implemented'::"text", 'abandoned'::"text"])))
);


ALTER TABLE "public"."alma_government_programs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_ingestion_jobs" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "source_type" "text" NOT NULL,
    "source_url" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "documents_found" integer DEFAULT 0,
    "entities_created" integer DEFAULT 0,
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "error" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "consent_level" "text" DEFAULT 'Public Knowledge Commons'::"text",
    "cultural_authority" boolean DEFAULT false,
    "category" "text",
    CONSTRAINT "alma_ingestion_jobs_source_type_check" CHECK (("source_type" = ANY (ARRAY['url'::"text", 'website'::"text", 'pdf'::"text", 'search'::"text", 'rss'::"text", 'api'::"text"]))),
    CONSTRAINT "alma_ingestion_jobs_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'crawling'::"text", 'extracting'::"text", 'completed'::"text", 'failed'::"text"])))
);


ALTER TABLE "public"."alma_ingestion_jobs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_intervention_contexts" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "intervention_id" "uuid" NOT NULL,
    "context_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."alma_intervention_contexts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_intervention_evidence" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "intervention_id" "uuid" NOT NULL,
    "evidence_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."alma_intervention_evidence" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_intervention_funding" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "intervention_id" "uuid" NOT NULL,
    "funding_data_id" "uuid",
    "funding_source" "text",
    "funding_amount" numeric(15,2),
    "funding_period_start" "date",
    "funding_period_end" "date",
    "funding_type" "text",
    "annual_budget" numeric(15,2),
    "cost_per_participant" numeric(10,2),
    "participants_per_year" integer,
    "cost_per_successful_outcome" numeric(10,2),
    "cost_benefit_ratio" numeric(5,2),
    "comparison_to_detention" numeric(5,2),
    "data_source" "text",
    "data_year" integer,
    "confidence_level" "text",
    "notes" "text",
    CONSTRAINT "alma_intervention_funding_confidence_level_check" CHECK (("confidence_level" = ANY (ARRAY['high'::"text", 'medium'::"text", 'low'::"text", 'estimated'::"text"]))),
    CONSTRAINT "alma_intervention_funding_funding_type_check" CHECK (("funding_type" = ANY (ARRAY['recurrent'::"text", 'one-off'::"text", 'pilot'::"text", 'grant'::"text", 'contract'::"text"])))
);


ALTER TABLE "public"."alma_intervention_funding" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_intervention_outcomes" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "intervention_id" "uuid" NOT NULL,
    "outcome_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."alma_intervention_outcomes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_intervention_profiles" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "intervention_id" "uuid" NOT NULL,
    "public_profile_id" "uuid" NOT NULL,
    "role" "text" NOT NULL,
    "started_date" "date",
    "ended_date" "date",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "alma_intervention_profiles_role_check" CHECK (("role" = ANY (ARRAY['founder'::"text", 'staff'::"text", 'researcher'::"text", 'participant'::"text", 'community_elder'::"text", 'evaluator'::"text", 'supporter'::"text"])))
);


ALTER TABLE "public"."alma_intervention_profiles" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_intervention_profiles" IS 'Links people to ALMA interventions with their role';



COMMENT ON COLUMN "public"."alma_intervention_profiles"."role" IS 'Role: founder, staff, researcher, participant, community_elder, evaluator, supporter';



COMMENT ON COLUMN "public"."alma_intervention_profiles"."started_date" IS 'When this person started this role';



COMMENT ON COLUMN "public"."alma_intervention_profiles"."ended_date" IS 'When this person ended this role (NULL if ongoing)';



CREATE TABLE IF NOT EXISTS "public"."alma_outcomes" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "name" "text" NOT NULL,
    "outcome_type" "text" NOT NULL,
    "description" "text",
    "measurement_method" "text",
    "indicators" "text",
    "time_horizon" "text",
    "beneficiary" "text",
    "search_vector" "tsvector",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "alma_outcomes_beneficiary_check" CHECK (("beneficiary" = ANY (ARRAY['Young person'::"text", 'Family'::"text", 'Community'::"text", 'System/Government'::"text"]))),
    CONSTRAINT "alma_outcomes_outcome_type_check" CHECK (("outcome_type" = ANY (ARRAY['Reduced detention/incarceration'::"text", 'Reduced recidivism'::"text", 'Diversion from justice system'::"text", 'Educational engagement'::"text", 'Employment/training'::"text", 'Family connection'::"text", 'Cultural connection'::"text", 'Mental health/wellbeing'::"text", 'Reduced substance use'::"text", 'Community safety'::"text", 'System cost reduction'::"text", 'Healing/restoration'::"text"]))),
    CONSTRAINT "alma_outcomes_time_horizon_check" CHECK (("time_horizon" = ANY (ARRAY['Immediate (<6 months)'::"text", 'Short-term (6-12 months)'::"text", 'Medium-term (1-3 years)'::"text", 'Long-term (3+ years)'::"text"])))
);


ALTER TABLE "public"."alma_outcomes" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_outcomes" IS 'Intended and measured outcomes for young people and communities';



CREATE TABLE IF NOT EXISTS "public"."registered_services" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "organization" "text" NOT NULL,
    "location" "text" NOT NULL,
    "state" "text" NOT NULL,
    "approach" "text" NOT NULL,
    "indigenous_knowledge" boolean DEFAULT false,
    "is_featured" boolean DEFAULT false,
    "description" "text" NOT NULL,
    "impact_summary" "text" NOT NULL,
    "tags" "text"[] DEFAULT '{}'::"text"[],
    "success_rate" integer,
    "participants_served" integer,
    "years_operating" integer,
    "founded_year" integer,
    "community_connection_score" integer,
    "contact_phone" "text",
    "contact_email" "text",
    "website" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "text",
    "search_vector" "tsvector",
    "organization_id" "uuid",
    "service_id" "uuid",
    "empathy_ledger_project_id" "uuid",
    "synced_from_empathy_ledger" boolean DEFAULT false,
    "last_synced_at" timestamp without time zone,
    "alma_intervention_id" "uuid",
    "latitude" numeric(10,8),
    "longitude" numeric(11,8),
    "location_type" "text" DEFAULT 'fixed'::"text",
    "relationship_type" "text" DEFAULT 'community_partner'::"text",
    "linked_service_id" "uuid",
    "interview_date" "date",
    "is_verified" boolean DEFAULT false,
    CONSTRAINT "community_programs_approach_check" CHECK (("approach" = ANY (ARRAY['Indigenous-led'::"text", 'Community-based'::"text", 'Grassroots'::"text", 'Culturally-responsive'::"text"]))),
    CONSTRAINT "community_programs_community_connection_score_check" CHECK ((("community_connection_score" >= 0) AND ("community_connection_score" <= 100))),
    CONSTRAINT "community_programs_location_type_check" CHECK (("location_type" = ANY (ARRAY['fixed'::"text", 'mobile'::"text", 'statewide'::"text", 'remote_communities'::"text", 'multi_site'::"text"]))),
    CONSTRAINT "community_programs_state_check" CHECK (("state" = ANY (ARRAY['NSW'::"text", 'VIC'::"text", 'QLD'::"text", 'SA'::"text", 'WA'::"text", 'TAS'::"text", 'NT'::"text", 'ACT'::"text"]))),
    CONSTRAINT "community_programs_success_rate_check" CHECK ((("success_rate" >= 0) AND ("success_rate" <= 100)))
);


ALTER TABLE "public"."registered_services" OWNER TO "postgres";


COMMENT ON TABLE "public"."registered_services" IS 'Services we have direct relationships with - interviewed, partnered, verified through personal contact';



COMMENT ON COLUMN "public"."registered_services"."approach" IS 'Program type: Indigenous-led, Community-based, Grassroots, or Culturally-responsive';



COMMENT ON COLUMN "public"."registered_services"."indigenous_knowledge" IS 'Program incorporates traditional Indigenous knowledge and practices';



COMMENT ON COLUMN "public"."registered_services"."is_featured" IS 'Show in featured programs section on homepage';



COMMENT ON COLUMN "public"."registered_services"."community_connection_score" IS 'Assessment of community integration and local connection (0-100)';



COMMENT ON COLUMN "public"."registered_services"."search_vector" IS 'Full-text search vector for program search functionality';



COMMENT ON COLUMN "public"."registered_services"."alma_intervention_id" IS 'Hybrid linking: Community programs converted to ALMA interventions';



CREATE OR REPLACE VIEW "public"."alma_interventions_unified" AS
 SELECT "i"."id",
    "i"."name",
    "i"."type",
    "i"."description",
    "i"."target_cohort",
    "i"."geography",
    "i"."evidence_level",
    "i"."cultural_authority",
    "i"."consent_level",
    "i"."operating_organization",
    "i"."contact_email",
    "i"."contact_phone",
    "i"."website",
    "i"."years_operating",
    "i"."review_status",
    "i"."portfolio_score",
    "i"."created_at",
    "i"."updated_at",
    'alma'::"text" AS "source",
    "i"."linked_community_program_id",
    "i"."linked_service_id",
    COALESCE(( SELECT "json_agg"("json_build_object"('id', "o"."id", 'name', "o"."name", 'type', "o"."outcome_type")) AS "json_agg"
           FROM ("public"."alma_outcomes" "o"
             JOIN "public"."alma_intervention_outcomes" "io" ON (("o"."id" = "io"."outcome_id")))
          WHERE ("io"."intervention_id" = "i"."id")), '[]'::json) AS "outcomes",
    COALESCE(( SELECT "json_agg"("json_build_object"('id', "e"."id", 'title', "e"."title", 'type', "e"."evidence_type")) AS "json_agg"
           FROM ("public"."alma_evidence" "e"
             JOIN "public"."alma_intervention_evidence" "ie" ON (("e"."id" = "ie"."evidence_id")))
          WHERE ("ie"."intervention_id" = "i"."id")), '[]'::json) AS "evidence",
    COALESCE(( SELECT "json_agg"("json_build_object"('id', "c"."id", 'name', "c"."name", 'type', "c"."context_type")) AS "json_agg"
           FROM ("public"."alma_community_contexts" "c"
             JOIN "public"."alma_intervention_contexts" "ic" ON (("c"."id" = "ic"."context_id")))
          WHERE ("ic"."intervention_id" = "i"."id")), '[]'::json) AS "contexts"
   FROM "public"."alma_interventions" "i"
UNION ALL
 SELECT "cp"."id",
    "cp"."name",
    'Community-Led'::"text" AS "type",
    "cp"."description",
    '{}'::"text"[] AS "target_cohort",
    ARRAY["cp"."state"] AS "geography",
        CASE
            WHEN "cp"."indigenous_knowledge" THEN 'Indigenous-led (culturally grounded, community authority)'::"text"
            ELSE 'Promising (community-endorsed, emerging evidence)'::"text"
        END AS "evidence_level",
    "cp"."organization" AS "cultural_authority",
    'Community Controlled'::"text" AS "consent_level",
    "cp"."organization" AS "operating_organization",
    "cp"."contact_email",
    "cp"."contact_phone",
    "cp"."website",
    "cp"."years_operating",
    'Approved'::"text" AS "review_status",
    NULL::numeric AS "portfolio_score",
    "cp"."created_at",
    "cp"."updated_at",
    'community_programs'::"text" AS "source",
    NULL::"uuid" AS "linked_community_program_id",
    NULL::"uuid" AS "linked_service_id",
    '[]'::json AS "outcomes",
    '[]'::json AS "evidence",
    '[]'::json AS "contexts"
   FROM "public"."registered_services" "cp"
  WHERE ("cp"."alma_intervention_id" IS NULL);


ALTER VIEW "public"."alma_interventions_unified" OWNER TO "postgres";


COMMENT ON VIEW "public"."alma_interventions_unified" IS 'Unified view for querying both ALMA interventions and legacy community programs together';



CREATE TABLE IF NOT EXISTS "public"."alma_locations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "state" "text" NOT NULL,
    "postcode" "text",
    "latitude" numeric(10,8),
    "longitude" numeric(11,8),
    "location_type" "text",
    "lga_name" "text",
    "sa3_name" "text",
    "traditional_country" "text",
    "indigenous_population_pct" numeric(5,2),
    CONSTRAINT "alma_locations_location_type_check" CHECK (("location_type" = ANY (ARRAY['metropolitan'::"text", 'regional'::"text", 'rural'::"text", 'remote'::"text", 'very_remote'::"text"])))
);


ALTER TABLE "public"."alma_locations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_metrics_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "recorded_at" timestamp with time zone DEFAULT "now"(),
    "metric_name" "text" NOT NULL,
    "metric_category" "text" NOT NULL,
    "jurisdiction" "text",
    "intervention_type" "text",
    "source_type" "text",
    "value_numeric" numeric(15,2),
    "value_count" integer,
    "value_percentage" numeric(5,2),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."alma_metrics_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_program_interventions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "program_id" "uuid",
    "intervention_id" "uuid",
    "relationship" "text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "alma_program_interventions_relationship_check" CHECK (("relationship" = ANY (ARRAY['implements'::"text", 'inspired_by'::"text", 'contradicts'::"text", 'replaces'::"text", 'expands'::"text"])))
);


ALTER TABLE "public"."alma_program_interventions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_raw_content" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "source_url" "text" NOT NULL,
    "source_type" "text",
    "raw_content" "text" NOT NULL,
    "content_hash" "text" NOT NULL,
    "content_length" integer GENERATED ALWAYS AS ("length"("raw_content")) STORED,
    "file_path" "text",
    "file_size_bytes" bigint,
    "file_mime_type" "text",
    "file_hash" "text",
    "extraction_method" "text",
    "extracted_at" timestamp with time zone DEFAULT "now"(),
    "page_count" integer,
    "processing_status" "text" DEFAULT 'pending'::"text",
    "last_processed_at" timestamp with time zone,
    "processing_error" "text",
    "language" "text" DEFAULT 'en'::"text",
    "word_count" integer,
    "relevance_score" numeric(3,2),
    "interventions_extracted" integer DEFAULT 0,
    "evidence_extracted" integer DEFAULT 0,
    "funding_data_extracted" integer DEFAULT 0,
    "search_vector" "tsvector" GENERATED ALWAYS AS (("setweight"("to_tsvector"('"english"'::"regconfig", COALESCE("source_url", ''::"text")), 'A'::"char") || "setweight"("to_tsvector"('"english"'::"regconfig", COALESCE("left"("raw_content", 50000), ''::"text")), 'B'::"char"))) STORED,
    "processed_at" timestamp with time zone,
    CONSTRAINT "alma_raw_content_processing_status_check" CHECK (("processing_status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text", 'needs_reprocessing'::"text", 'entities_extracted'::"text"]))),
    CONSTRAINT "alma_raw_content_source_type_check" CHECK (("source_type" = ANY (ARRAY['webpage'::"text", 'pdf'::"text", 'document'::"text", 'api'::"text", 'rss'::"text"])))
);


ALTER TABLE "public"."alma_raw_content" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_report_deliveries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "report_id" "uuid" NOT NULL,
    "subscription_id" "uuid",
    "delivery_method" "text" NOT NULL,
    "recipient_email" "text",
    "recipient_user_id" "uuid",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "sent_at" timestamp with time zone,
    "opened_at" timestamp with time zone,
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "alma_report_deliveries_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'sent'::"text", 'failed'::"text", 'opened'::"text"])))
);


ALTER TABLE "public"."alma_report_deliveries" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_report_deliveries" IS 'Log of report deliveries';



CREATE TABLE IF NOT EXISTS "public"."alma_report_subscriptions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "email" "text",
    "organization_id" "uuid",
    "report_types" "text"[] DEFAULT ARRAY['comprehensive'::"text"],
    "frequency" "text" DEFAULT 'weekly'::"text" NOT NULL,
    "delivery_method" "text" DEFAULT 'email'::"text" NOT NULL,
    "is_active" boolean DEFAULT true,
    "confirmed_at" timestamp with time zone,
    "unsubscribed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "alma_report_subscriptions_delivery_method_check" CHECK (("delivery_method" = ANY (ARRAY['email'::"text", 'dashboard'::"text", 'both'::"text"]))),
    CONSTRAINT "alma_report_subscriptions_frequency_check" CHECK (("frequency" = ANY (ARRAY['daily'::"text", 'weekly'::"text", 'monthly'::"text"]))),
    CONSTRAINT "subscriber_check" CHECK ((("user_id" IS NOT NULL) OR ("email" IS NOT NULL)))
);


ALTER TABLE "public"."alma_report_subscriptions" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_report_subscriptions" IS 'User subscriptions to weekly reports';



CREATE TABLE IF NOT EXISTS "public"."alma_research_findings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "session_id" "uuid",
    "finding_type" "text" NOT NULL,
    "entity_type" "text",
    "entity_id" "uuid",
    "content" "jsonb" NOT NULL,
    "confidence" numeric(3,2),
    "validated" boolean DEFAULT false,
    "validation_source" "text",
    "sources" "text"[],
    "applied" boolean DEFAULT false,
    "applied_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "alma_research_findings_confidence_check" CHECK ((("confidence" >= (0)::numeric) AND ("confidence" <= (1)::numeric))),
    CONSTRAINT "alma_research_findings_finding_type_check" CHECK (("finding_type" = ANY (ARRAY['evidence_link'::"text", 'outcome_link'::"text", 'gap_identified'::"text", 'verification'::"text", 'contradiction'::"text", 'new_intervention'::"text", 'external_source'::"text", 'recommendation'::"text"])))
);


ALTER TABLE "public"."alma_research_findings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_research_sessions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "query" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text",
    "depth" "text" DEFAULT 'quick'::"text",
    "plan" "jsonb" DEFAULT '[]'::"jsonb",
    "scratchpad" "jsonb" DEFAULT '{}'::"jsonb",
    "results" "jsonb",
    "max_consent_level" "text" DEFAULT 'Public Knowledge Commons'::"text",
    "user_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    "error_message" "text",
    "retry_count" integer DEFAULT 0,
    CONSTRAINT "alma_research_sessions_depth_check" CHECK (("depth" = ANY (ARRAY['quick'::"text", 'thorough'::"text", 'comprehensive'::"text"]))),
    CONSTRAINT "alma_research_sessions_max_consent_level_check" CHECK (("max_consent_level" = ANY (ARRAY['Public Knowledge Commons'::"text", 'Community Controlled'::"text", 'Strictly Private'::"text"]))),
    CONSTRAINT "alma_research_sessions_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'planning'::"text", 'executing'::"text", 'validating'::"text", 'synthesizing'::"text", 'complete'::"text", 'failed'::"text"])))
);


ALTER TABLE "public"."alma_research_sessions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_research_tool_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "session_id" "uuid",
    "tool_name" "text" NOT NULL,
    "tool_input" "jsonb",
    "tool_output" "jsonb",
    "execution_time_ms" integer,
    "success" boolean,
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."alma_research_tool_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_scrape_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "source_id" "uuid",
    "source_url" "text" NOT NULL,
    "status" "text",
    "content_length" integer,
    "entities_found" integer DEFAULT 0,
    "entities_inserted" integer DEFAULT 0,
    "relevance_score" numeric(5,2),
    "novelty_score" numeric(5,2),
    "quality_score" numeric(5,2),
    "pattern_id" "uuid",
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "duration_seconds" integer,
    "error_message" "text",
    "extracted_data" "jsonb",
    "links_discovered" "text"[] DEFAULT '{}'::"text"[],
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "alma_scrape_history_status_check" CHECK (("status" = ANY (ARRAY['success'::"text", 'partial'::"text", 'failed'::"text", 'skipped'::"text"])))
);


ALTER TABLE "public"."alma_scrape_history" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_scrape_history" IS 'Detailed history of all scraping activity';



CREATE MATERIALIZED VIEW "public"."alma_sentiment_program_correlation" AS
 SELECT "p"."id" AS "program_id",
    "p"."name" AS "program_name",
    "p"."announced_date",
    "p"."community_led",
    "avg"(
        CASE
            WHEN (("date_trunc"('day'::"text", "a"."published_date") >= ("p"."announced_date" - '30 days'::interval)) AND ("date_trunc"('day'::"text", "a"."published_date") <= ("p"."announced_date" - '1 day'::interval))) THEN "a"."sentiment_score"
            ELSE NULL::numeric
        END) AS "sentiment_before",
    "avg"(
        CASE
            WHEN (("date_trunc"('day'::"text", "a"."published_date") >= "p"."announced_date") AND ("date_trunc"('day'::"text", "a"."published_date") <= ("p"."announced_date" + '30 days'::interval))) THEN "a"."sentiment_score"
            ELSE NULL::numeric
        END) AS "sentiment_after",
    ("avg"(
        CASE
            WHEN (("date_trunc"('day'::"text", "a"."published_date") >= "p"."announced_date") AND ("date_trunc"('day'::"text", "a"."published_date") <= ("p"."announced_date" + '30 days'::interval))) THEN "a"."sentiment_score"
            ELSE NULL::numeric
        END) - "avg"(
        CASE
            WHEN (("date_trunc"('day'::"text", "a"."published_date") >= ("p"."announced_date" - '30 days'::interval)) AND ("date_trunc"('day'::"text", "a"."published_date") <= ("p"."announced_date" - '1 day'::interval))) THEN "a"."sentiment_score"
            ELSE NULL::numeric
        END)) AS "sentiment_shift"
   FROM ("public"."alma_government_programs" "p"
     LEFT JOIN "public"."alma_media_articles" "a" ON (true))
  WHERE ("p"."announced_date" IS NOT NULL)
  GROUP BY "p"."id", "p"."name", "p"."announced_date", "p"."community_led"
 HAVING ("count"("a"."id") > 0)
  WITH NO DATA;


ALTER MATERIALIZED VIEW "public"."alma_sentiment_program_correlation" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_source_documents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "title" "text" NOT NULL,
    "document_type" "text" NOT NULL,
    "source_url" "text" NOT NULL,
    "source_organization" "text",
    "author" "text",
    "publication_date" "date",
    "report_period" "text",
    "file_path" "text",
    "file_name" "text",
    "file_size_bytes" bigint,
    "file_hash" "text",
    "mime_type" "text" DEFAULT 'application/pdf'::"text",
    "page_count" integer,
    "downloaded_at" timestamp with time zone,
    "last_verified_at" timestamp with time zone,
    "is_accessible" boolean DEFAULT true,
    "abstract" "text",
    "key_findings" "jsonb" DEFAULT '[]'::"jsonb",
    "topics" "text"[],
    "jurisdiction" "text",
    "scope" "text",
    "authority_level" "text",
    "citation_count" integer DEFAULT 0,
    "search_vector" "tsvector",
    CONSTRAINT "alma_source_documents_authority_level_check" CHECK (("authority_level" = ANY (ARRAY['primary_source'::"text", 'government_official'::"text", 'peer_reviewed'::"text", 'grey_literature'::"text", 'media'::"text", 'community_voice'::"text"]))),
    CONSTRAINT "alma_source_documents_document_type_check" CHECK (("document_type" = ANY (ARRAY['government_report'::"text", 'academic_paper'::"text", 'inquiry_report'::"text", 'policy_document'::"text", 'evaluation_report'::"text", 'annual_report'::"text", 'budget_paper'::"text", 'statistical_report'::"text", 'community_report'::"text", 'media_article'::"text", 'legal_document'::"text", 'other'::"text"]))),
    CONSTRAINT "alma_source_documents_scope_check" CHECK (("scope" = ANY (ARRAY['national'::"text", 'state'::"text", 'regional'::"text", 'local'::"text", 'international'::"text"])))
);


ALTER TABLE "public"."alma_source_documents" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."alma_unified_search" AS
 SELECT 'intervention'::"text" AS "entity_type",
    "alma_interventions"."id" AS "entity_id",
    "alma_interventions"."name" AS "title",
    "alma_interventions"."description",
    "alma_interventions"."type" AS "category",
    "alma_interventions"."geography"[1] AS "jurisdiction",
    "alma_interventions"."search_vector",
    "alma_interventions"."portfolio_score" AS "relevance_boost",
    "alma_interventions"."created_at"
   FROM "public"."alma_interventions"
  WHERE ("alma_interventions"."review_status" = 'Published'::"text")
UNION ALL
 SELECT 'evidence'::"text" AS "entity_type",
    "alma_evidence"."id" AS "entity_id",
    "alma_evidence"."title",
    "alma_evidence"."findings" AS "description",
    "alma_evidence"."evidence_type" AS "category",
    NULL::"text" AS "jurisdiction",
    "alma_evidence"."search_vector",
        CASE "alma_evidence"."evidence_type"
            WHEN 'RCT'::"text" THEN 1.0
            WHEN 'Quasi-experimental'::"text" THEN 0.9
            WHEN 'Program eval'::"text" THEN 0.8
            ELSE 0.5
        END AS "relevance_boost",
    "alma_evidence"."created_at"
   FROM "public"."alma_evidence"
UNION ALL
 SELECT 'funding'::"text" AS "entity_type",
    "alma_funding_data"."id" AS "entity_id",
    "alma_funding_data"."source_name" AS "title",
    "concat"('$', (("alma_funding_data"."total_expenditure" / (1000000)::numeric))::"text", 'M expenditure in ', "alma_funding_data"."report_year") AS "description",
    "alma_funding_data"."source_type" AS "category",
    "alma_funding_data"."jurisdiction",
    "to_tsvector"('"english"'::"regconfig", ((COALESCE("alma_funding_data"."source_name", ''::"text") || ' '::"text") || COALESCE("alma_funding_data"."jurisdiction", ''::"text"))) AS "search_vector",
    0.7 AS "relevance_boost",
    "alma_funding_data"."created_at"
   FROM "public"."alma_funding_data";


ALTER VIEW "public"."alma_unified_search" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."alma_usage_log" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "entity_type" "text" NOT NULL,
    "entity_id" "uuid" NOT NULL,
    "action" "text" NOT NULL,
    "user_id" "uuid",
    "query_text" "text",
    "destination" "text",
    "revenue_generated" numeric(10,2),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "alma_usage_log_action_check" CHECK (("action" = ANY (ARRAY['query'::"text", 'view'::"text", 'export'::"text", 'publish'::"text", 'training'::"text", 'commercial'::"text"]))),
    CONSTRAINT "alma_usage_log_entity_type_check" CHECK (("entity_type" = ANY (ARRAY['intervention'::"text", 'context'::"text", 'evidence'::"text", 'outcome'::"text"])))
);


ALTER TABLE "public"."alma_usage_log" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_usage_log" IS 'Usage tracking for attribution and revenue sharing';



CREATE TABLE IF NOT EXISTS "public"."alma_weekly_reports" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "week_start" "date" NOT NULL,
    "week_end" "date" NOT NULL,
    "report_type" "text" NOT NULL,
    "organization_id" "uuid",
    "title" "text" NOT NULL,
    "executive_summary" "text",
    "funding_section" "jsonb" DEFAULT '{}'::"jsonb",
    "research_section" "jsonb" DEFAULT '{}'::"jsonb",
    "sector_section" "jsonb" DEFAULT '{}'::"jsonb",
    "media_section" "jsonb" DEFAULT '{}'::"jsonb",
    "highlights" "text"[] DEFAULT '{}'::"text"[],
    "alerts" "text"[] DEFAULT '{}'::"text"[],
    "recommended_actions" "text"[] DEFAULT '{}'::"text"[],
    "stats_snapshot" "jsonb" DEFAULT '{}'::"jsonb",
    "generated_at" timestamp with time zone DEFAULT "now"(),
    "generation_duration_ms" integer,
    "data_sources_used" "text"[] DEFAULT '{}'::"text"[],
    "status" "text" DEFAULT 'draft'::"text" NOT NULL,
    "published_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "alma_weekly_reports_report_type_check" CHECK (("report_type" = ANY (ARRAY['comprehensive'::"text", 'funding'::"text", 'research'::"text", 'media'::"text", 'sector'::"text", 'basecamp'::"text"]))),
    CONSTRAINT "alma_weekly_reports_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'published'::"text", 'archived'::"text"])))
);


ALTER TABLE "public"."alma_weekly_reports" OWNER TO "postgres";


COMMENT ON TABLE "public"."alma_weekly_reports" IS 'Weekly intelligence reports generated by ALMA';



CREATE TABLE IF NOT EXISTS "public"."analysis_jobs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "transcript_id" "uuid" NOT NULL,
    "storyteller_id" "uuid" NOT NULL,
    "status" "public"."analysis_job_status_enum" DEFAULT 'queued'::"public"."analysis_job_status_enum" NOT NULL,
    "attempts" integer DEFAULT 0 NOT NULL,
    "last_error" "text",
    "priority" integer DEFAULT 5,
    "scheduled_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "started_at" timestamp with time zone,
    "finished_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."analysis_jobs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."api_pricing" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "provider" "text" NOT NULL,
    "model" "text" NOT NULL,
    "endpoint" "text" DEFAULT 'default'::"text" NOT NULL,
    "input_price_per_1m" numeric(10,4),
    "output_price_per_1m" numeric(10,4),
    "price_per_request" numeric(10,6),
    "effective_from" "date" DEFAULT CURRENT_DATE NOT NULL,
    "effective_until" "date"
);


ALTER TABLE "public"."api_pricing" OWNER TO "postgres";


COMMENT ON TABLE "public"."api_pricing" IS 'Current pricing for API providers and models';



CREATE TABLE IF NOT EXISTS "public"."api_usage" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "timestamp" timestamp with time zone DEFAULT "now"(),
    "provider" "text" NOT NULL,
    "model" "text" NOT NULL,
    "endpoint" "text",
    "api_version" "text",
    "input_tokens" integer,
    "output_tokens" integer,
    "total_tokens" integer GENERATED ALWAYS AS ((COALESCE("input_tokens", 0) + COALESCE("output_tokens", 0))) STORED,
    "input_cost" numeric(10,6),
    "output_cost" numeric(10,6),
    "estimated_cost" numeric(10,6),
    "cache_hit" boolean DEFAULT false,
    "cache_key" "text",
    "script_name" "text",
    "agent_id" "text",
    "operation" "text",
    "latency_ms" integer,
    "retries" integer DEFAULT 0,
    "request_hash" "text",
    "response_status" integer,
    "error_message" "text",
    "batch_id" "uuid",
    "batch_sequence" integer
);


ALTER TABLE "public"."api_usage" OWNER TO "postgres";


COMMENT ON TABLE "public"."api_usage" IS 'Tracks all LLM and external API calls for cost optimization';



CREATE TABLE IF NOT EXISTS "public"."app_users" (
    "id" integer NOT NULL,
    "openId" "uuid" NOT NULL,
    "name" "text",
    "email" character varying(320),
    "loginMethod" character varying(64),
    "role" "public"."user_role" DEFAULT 'user'::"public"."user_role" NOT NULL,
    "createdAt" timestamp without time zone DEFAULT "now"() NOT NULL,
    "updatedAt" timestamp without time zone DEFAULT "now"() NOT NULL,
    "lastSignedIn" timestamp without time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."app_users" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."app_users_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."app_users_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."app_users_id_seq" OWNED BY "public"."app_users"."id";



CREATE TABLE IF NOT EXISTS "public"."art_innovation" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "title" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "type" "text" NOT NULL,
    "status" "text" DEFAULT 'draft'::"text" NOT NULL,
    "tagline" "text",
    "description" "text" NOT NULL,
    "story" "text",
    "impact" "text",
    "featured_image_url" "text",
    "video_url" "text",
    "gallery_images" "jsonb" DEFAULT '[]'::"jsonb",
    "creators" "jsonb" DEFAULT '[]'::"jsonb",
    "year" integer,
    "location" "text",
    "tags" "text"[] DEFAULT ARRAY[]::"text"[],
    "website_url" "text",
    "social_links" "jsonb" DEFAULT '{}'::"jsonb",
    "organization_id" "uuid",
    "program_id" "uuid",
    "is_featured" boolean DEFAULT false,
    "view_count" integer DEFAULT 0,
    "search_vector" "tsvector" GENERATED ALWAYS AS (((("setweight"("to_tsvector"('"english"'::"regconfig", COALESCE("title", ''::"text")), 'A'::"char") || "setweight"("to_tsvector"('"english"'::"regconfig", COALESCE("tagline", ''::"text")), 'B'::"char")) || "setweight"("to_tsvector"('"english"'::"regconfig", COALESCE("description", ''::"text")), 'C'::"char")) || "setweight"("to_tsvector"('"english"'::"regconfig", COALESCE("story", ''::"text")), 'D'::"char"))) STORED,
    CONSTRAINT "art_innovation_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'published'::"text", 'archived'::"text"]))),
    CONSTRAINT "art_innovation_type_check" CHECK (("type" = ANY (ARRAY['art'::"text", 'campaign'::"text", 'innovation'::"text", 'technology'::"text", 'design'::"text", 'multimedia'::"text"])))
);


ALTER TABLE "public"."art_innovation" OWNER TO "postgres";


COMMENT ON TABLE "public"."art_innovation" IS 'Creative works, campaigns, and innovative solutions in youth justice';



COMMENT ON COLUMN "public"."art_innovation"."type" IS 'Type of project: art, campaign, innovation, technology, design, multimedia';



COMMENT ON COLUMN "public"."art_innovation"."gallery_images" IS 'Array of image objects with url, caption, and credit';



COMMENT ON COLUMN "public"."art_innovation"."creators" IS 'Array of creator objects with name, role, bio, photo_url, and optional profile_id';



COMMENT ON COLUMN "public"."art_innovation"."social_links" IS 'Social media links as JSON object';



CREATE TABLE IF NOT EXISTS "public"."art_innovation_profiles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "art_innovation_id" "uuid",
    "public_profile_id" "uuid",
    "role" "text" NOT NULL,
    "role_description" "text",
    "display_order" integer DEFAULT 0,
    "is_featured" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."art_innovation_profiles" OWNER TO "postgres";


COMMENT ON TABLE "public"."art_innovation_profiles" IS 'Links people to art & innovation projects';



CREATE TABLE IF NOT EXISTS "public"."article_locations" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "article_id" "uuid",
    "location_name" "text" NOT NULL,
    "location_city" "text",
    "location_state" "text",
    "location_country" "text" DEFAULT 'Australia'::"text",
    "latitude" numeric(10,8),
    "longitude" numeric(11,8),
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."article_locations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."article_related_art" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "article_id" "uuid",
    "art_innovation_id" "uuid",
    "relevance_note" "text",
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."article_related_art" OWNER TO "postgres";


COMMENT ON TABLE "public"."article_related_art" IS 'Links articles to art/innovation projects they discuss';



CREATE TABLE IF NOT EXISTS "public"."article_related_articles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "article_id" "uuid",
    "related_article_id" "uuid",
    "relationship_type" "text" DEFAULT 'related'::"text",
    "relevance_note" "text",
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "article_related_articles_check" CHECK (("article_id" <> "related_article_id"))
);


ALTER TABLE "public"."article_related_articles" OWNER TO "postgres";


COMMENT ON TABLE "public"."article_related_articles" IS 'Links related articles for "related reading" sections';



CREATE TABLE IF NOT EXISTS "public"."article_related_evidence" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "article_id" "uuid" NOT NULL,
    "evidence_id" "uuid" NOT NULL,
    "relevance_note" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."article_related_evidence" OWNER TO "postgres";


COMMENT ON TABLE "public"."article_related_evidence" IS 'Links articles to ALMA evidence records';



COMMENT ON COLUMN "public"."article_related_evidence"."relevance_note" IS 'Optional note explaining why this evidence is related to this article';



CREATE TABLE IF NOT EXISTS "public"."article_related_interventions" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "article_id" "uuid" NOT NULL,
    "intervention_id" "uuid" NOT NULL,
    "relevance_note" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."article_related_interventions" OWNER TO "postgres";


COMMENT ON TABLE "public"."article_related_interventions" IS 'Links articles to ALMA interventions for cross-referencing';



COMMENT ON COLUMN "public"."article_related_interventions"."relevance_note" IS 'Optional note explaining why this intervention is related to this article';



CREATE TABLE IF NOT EXISTS "public"."article_related_programs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "article_id" "uuid",
    "program_id" "uuid",
    "relevance_note" "text",
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."article_related_programs" OWNER TO "postgres";


COMMENT ON TABLE "public"."article_related_programs" IS 'Links articles to community programs they discuss';



CREATE TABLE IF NOT EXISTS "public"."article_related_services" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "article_id" "uuid",
    "service_id" "uuid",
    "relevance_note" "text",
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."article_related_services" OWNER TO "postgres";


COMMENT ON TABLE "public"."article_related_services" IS 'Links articles to services they discuss';



CREATE TABLE IF NOT EXISTS "public"."article_tags" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "article_id" "uuid",
    "tag" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."article_tags" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."articles" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "slug" "text" NOT NULL,
    "title" "text" NOT NULL,
    "excerpt" "text",
    "content" "text" NOT NULL,
    "featured_image_url" "text",
    "author_id" "uuid",
    "category" "text",
    "is_trending" boolean DEFAULT false,
    "published_at" timestamp with time zone,
    "status" "text" DEFAULT 'draft'::"text",
    "seo_title" "text",
    "seo_description" "text",
    "location_tags" "text"[],
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "view_count" integer DEFAULT 0,
    "reading_time_minutes" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "featured_image_caption" "text",
    "co_authors" "uuid"[],
    "tags" "text"[],
    "share_count" integer DEFAULT 0,
    "categories" "text"[],
    CONSTRAINT "articles_category_check" CHECK (("category" = ANY (ARRAY['seeds'::"text", 'growth'::"text", 'harvest'::"text", 'roots'::"text"]))),
    CONSTRAINT "articles_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'published'::"text", 'archived'::"text"])))
);


ALTER TABLE "public"."articles" OWNER TO "postgres";


COMMENT ON COLUMN "public"."articles"."featured_image_caption" IS 'Caption for the featured image';



COMMENT ON COLUMN "public"."articles"."co_authors" IS 'Array of profile IDs for co-authors (references public_profiles.id)';



COMMENT ON COLUMN "public"."articles"."tags" IS 'Content tags for categorization and filtering';



COMMENT ON COLUMN "public"."articles"."share_count" IS 'Number of times content has been shared on social media';



COMMENT ON COLUMN "public"."articles"."categories" IS 'Content categories (array) - first element becomes primary category';



CREATE TABLE IF NOT EXISTS "public"."audit_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "action" "text" NOT NULL,
    "resource_type" "text" NOT NULL,
    "resource_id" "uuid",
    "user_id" "uuid",
    "user_email" "text",
    "user_role" "text",
    "ip_address" "inet",
    "user_agent" "text",
    "session_id" "text",
    "old_values" "jsonb",
    "new_values" "jsonb",
    "metadata" "jsonb",
    "action_category" "text",
    "risk_level" "text" DEFAULT 'low'::"text",
    "gdpr_relevant" boolean DEFAULT false,
    "requires_notification" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "audit_logs_action_category_check" CHECK (("action_category" = ANY (ARRAY['create'::"text", 'read'::"text", 'update'::"text", 'delete'::"text", 'export'::"text", 'share'::"text", 'analyze'::"text"]))),
    CONSTRAINT "audit_logs_risk_level_check" CHECK (("risk_level" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text", 'critical'::"text"])))
);


ALTER TABLE "public"."audit_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."australian_frameworks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "slug" "text" NOT NULL,
    "name" "text" NOT NULL,
    "state" "text" NOT NULL,
    "tagline" "text" NOT NULL,
    "overview" "text" NOT NULL,
    "key_features" "text"[] DEFAULT '{}'::"text"[],
    "strengths" "text"[] DEFAULT '{}'::"text"[],
    "challenges" "text"[] DEFAULT '{}'::"text"[],
    "outcomes" "jsonb" DEFAULT '[]'::"jsonb",
    "resources" "jsonb" DEFAULT '[]'::"jsonb",
    "color" "text" DEFAULT 'blue'::"text",
    "display_order" integer DEFAULT 0,
    "is_active" boolean DEFAULT true,
    "latitude" numeric(10,8),
    "longitude" numeric(11,8),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."australian_frameworks" OWNER TO "postgres";


COMMENT ON TABLE "public"."australian_frameworks" IS 'Seeded with 4 Australian state/territory frameworks from best-practice page';



COMMENT ON COLUMN "public"."australian_frameworks"."outcomes" IS 'JSON array: [{metric: string, value: string, context: string}]';



COMMENT ON COLUMN "public"."australian_frameworks"."resources" IS 'JSON array: [{title: string, type: research|policy|report, url: string, description: string}]';



CREATE TABLE IF NOT EXISTS "public"."authors" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "slug" "text" NOT NULL,
    "name" "text" NOT NULL,
    "bio" "text",
    "photo_url" "text",
    "role" "text",
    "email" "text",
    "linkedin_url" "text",
    "twitter_url" "text",
    "website_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "public_profile_id" "uuid"
);


ALTER TABLE "public"."authors" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."auto_approval_quality" AS
 SELECT "id",
    "title",
    "page_type",
    "approval_confidence",
    "created_at" AS "approved_at",
    "updated_at" AS "last_updated",
        CASE
            WHEN ("updated_at" > ("created_at" + '1 day'::interval)) THEN 'edited'::"text"
            ELSE 'untouched'::"text"
        END AS "post_approval_status",
    (EXTRACT(day FROM ("now"() - "created_at")))::integer AS "days_since_approval"
   FROM "public"."wiki_pages" "wp"
  WHERE ("auto_approved" = true)
  ORDER BY "created_at" DESC;


ALTER VIEW "public"."auto_approval_quality" OWNER TO "postgres";


COMMENT ON VIEW "public"."auto_approval_quality" IS 'Monitor quality of auto-approved pages';



CREATE TABLE IF NOT EXISTS "public"."automated_insights" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "insight_type" "text" NOT NULL,
    "insight_category" "text" NOT NULL,
    "priority_level" "text" DEFAULT 'medium'::"text" NOT NULL,
    "title" "text" NOT NULL,
    "description" "text" NOT NULL,
    "detailed_analysis" "jsonb" DEFAULT '{}'::"jsonb",
    "data_sources" "jsonb" DEFAULT '[]'::"jsonb",
    "evidence_data" "jsonb" DEFAULT '{}'::"jsonb",
    "confidence_score" numeric DEFAULT 0,
    "recommended_actions" "jsonb" DEFAULT '[]'::"jsonb",
    "expected_impact" "jsonb" DEFAULT '{}'::"jsonb",
    "implementation_complexity" "text" DEFAULT 'medium'::"text",
    "target_audience" "jsonb" DEFAULT '[]'::"jsonb",
    "relevant_projects" "jsonb" DEFAULT '[]'::"jsonb",
    "relevant_communities" "jsonb" DEFAULT '[]'::"jsonb",
    "status" "text" DEFAULT 'active'::"text",
    "expires_at" timestamp with time zone,
    "implemented_at" timestamp with time zone,
    "implementation_notes" "text",
    "generated_by" "text" NOT NULL,
    "model_version" "text",
    "generation_timestamp" timestamp with time zone NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "valid_implementation_complexity" CHECK (("implementation_complexity" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text"]))),
    CONSTRAINT "valid_insight_status" CHECK (("status" = ANY (ARRAY['active'::"text", 'implemented'::"text", 'dismissed'::"text", 'expired'::"text"]))),
    CONSTRAINT "valid_insight_type" CHECK (("insight_type" = ANY (ARRAY['trend'::"text", 'anomaly'::"text", 'opportunity'::"text", 'recommendation'::"text", 'warning'::"text"]))),
    CONSTRAINT "valid_priority" CHECK (("priority_level" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text", 'critical'::"text"])))
);


ALTER TABLE "public"."automated_insights" OWNER TO "postgres";


COMMENT ON TABLE "public"."automated_insights" IS 'AI-generated insights and recommendations for the platform';



CREATE TABLE IF NOT EXISTS "public"."autonomous_executions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "agent_id" "text" NOT NULL,
    "action_id" "uuid",
    "action_name" "text" NOT NULL,
    "action_params" "jsonb" NOT NULL,
    "reasoning" "jsonb" NOT NULL,
    "confidence" numeric(3,2),
    "result" "jsonb",
    "success" boolean,
    "error_message" "text",
    "duration_ms" integer,
    "within_bounds" boolean DEFAULT true,
    "bounds_violated" "jsonb",
    "flagged_for_review" boolean DEFAULT false,
    "reviewed_by" "text",
    "reviewed_at" timestamp with time zone,
    "review_outcome" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "autonomous_executions_review_outcome_check" CHECK (("review_outcome" = ANY (ARRAY['correct'::"text", 'incorrect'::"text", 'uncertain'::"text"])))
);


ALTER TABLE "public"."autonomous_executions" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."autonomous_review_queue" AS
 SELECT "id",
    "agent_id",
    "action_name",
    "success",
    "confidence",
    ("reasoning" ->> 'trigger'::"text") AS "trigger_reason",
    "within_bounds",
    "created_at"
   FROM "public"."autonomous_executions" "e"
  WHERE (("flagged_for_review" = true) AND ("reviewed_at" IS NULL))
  ORDER BY "created_at" DESC;


ALTER VIEW "public"."autonomous_review_queue" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."backups" (
    "id" "text" NOT NULL,
    "backup_timestamp" timestamp with time zone DEFAULT "now"(),
    "size_bytes" bigint DEFAULT 0,
    "checksum" "text",
    "data_types" "text"[] DEFAULT ARRAY[]::"text"[],
    "version" "text" DEFAULT '1.0'::"text",
    "is_completed" boolean DEFAULT false,
    "created_by" "text" DEFAULT 'system'::"text",
    "description" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."backups" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."best_practices" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "category" "text" NOT NULL,
    "description" "text" NOT NULL,
    "supporting_research" "text",
    "example_programs" "uuid"[],
    "australian_implementation" "text",
    "challenges" "text",
    "recommendations" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."best_practices" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."billing_coupons" (
    "id" bigint NOT NULL,
    "tenant_id" "text" NOT NULL,
    "code" "text" NOT NULL,
    "percent_off" numeric(5,2),
    "amount_off" numeric(14,2),
    "currency" "text",
    "duration" "text",
    "duration_in_months" integer,
    "max_redemptions" integer,
    "redeem_by" timestamp with time zone,
    "active" boolean DEFAULT true,
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "billing_coupons_duration_check" CHECK (("duration" = ANY (ARRAY['once'::"text", 'repeating'::"text", 'forever'::"text"]))),
    CONSTRAINT "billing_coupons_percent_off_check" CHECK ((("percent_off" >= (0)::numeric) AND ("percent_off" <= (100)::numeric)))
);


ALTER TABLE "public"."billing_coupons" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."billing_coupons_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."billing_coupons_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."billing_coupons_id_seq" OWNED BY "public"."billing_coupons"."id";



CREATE TABLE IF NOT EXISTS "public"."billing_customers" (
    "id" bigint NOT NULL,
    "tenant_id" "text" NOT NULL,
    "email" "text",
    "name" "text",
    "stripe_customer_id" "text",
    "xero_contact_id" "text",
    "default_payment_brand" "text",
    "default_payment_last4" "text",
    "billing_address" "jsonb",
    "shipping_address" "jsonb",
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."billing_customers" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."billing_customers_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."billing_customers_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."billing_customers_id_seq" OWNED BY "public"."billing_customers"."id";



CREATE TABLE IF NOT EXISTS "public"."billing_invoice_lines" (
    "id" bigint NOT NULL,
    "invoice_id" bigint,
    "description" "text",
    "quantity" numeric(10,2) DEFAULT 1,
    "unit_amount" numeric(14,2) DEFAULT 0,
    "amount" numeric(14,2) DEFAULT 0,
    "product_id" bigint,
    "price_id" bigint,
    "tax_rate" numeric(5,2) DEFAULT 0,
    "metadata" "jsonb"
);


ALTER TABLE "public"."billing_invoice_lines" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."billing_invoice_lines_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."billing_invoice_lines_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."billing_invoice_lines_id_seq" OWNED BY "public"."billing_invoice_lines"."id";



CREATE TABLE IF NOT EXISTS "public"."billing_invoices" (
    "id" bigint NOT NULL,
    "tenant_id" "text" NOT NULL,
    "customer_id" bigint,
    "subscription_id" bigint,
    "invoice_number" "text",
    "currency" "text",
    "subtotal" numeric(14,2) DEFAULT 0,
    "tax_total" numeric(14,2) DEFAULT 0,
    "total" numeric(14,2) DEFAULT 0,
    "status" "text" NOT NULL,
    "due_date" "date",
    "issued_at" timestamp with time zone,
    "stripe_invoice_id" "text",
    "xero_invoice_id" "text",
    "pdf_url" "text",
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "billing_invoices_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'open'::"text", 'paid'::"text", 'uncollectible'::"text", 'void'::"text"])))
);


ALTER TABLE "public"."billing_invoices" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."billing_invoices_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."billing_invoices_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."billing_invoices_id_seq" OWNED BY "public"."billing_invoices"."id";



CREATE TABLE IF NOT EXISTS "public"."billing_payments" (
    "id" bigint NOT NULL,
    "invoice_id" bigint,
    "amount" numeric(14,2) NOT NULL,
    "status" "text" NOT NULL,
    "paid_at" timestamp with time zone,
    "stripe_payment_intent_id" "text",
    "stripe_charge_id" "text",
    "failure_code" "text",
    "failure_message" "text",
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "billing_payments_status_check" CHECK (("status" = ANY (ARRAY['succeeded'::"text", 'failed'::"text", 'pending'::"text", 'refunded'::"text"])))
);


ALTER TABLE "public"."billing_payments" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."billing_payments_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."billing_payments_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."billing_payments_id_seq" OWNED BY "public"."billing_payments"."id";



CREATE TABLE IF NOT EXISTS "public"."billing_prices" (
    "id" bigint NOT NULL,
    "product_id" bigint,
    "currency" "text" NOT NULL,
    "unit_amount" numeric(14,2) NOT NULL,
    "billing_period" "text" NOT NULL,
    "usage_type" "text" DEFAULT 'licensed'::"text",
    "trial_days" integer,
    "stripe_price_id" "text",
    "active" boolean DEFAULT true,
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "billing_prices_billing_period_check" CHECK (("billing_period" = ANY (ARRAY['month'::"text", 'year'::"text", 'one_time'::"text"]))),
    CONSTRAINT "billing_prices_usage_type_check" CHECK (("usage_type" = ANY (ARRAY['licensed'::"text", 'metered'::"text"])))
);


ALTER TABLE "public"."billing_prices" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."billing_prices_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."billing_prices_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."billing_prices_id_seq" OWNED BY "public"."billing_prices"."id";



CREATE TABLE IF NOT EXISTS "public"."billing_products" (
    "id" bigint NOT NULL,
    "tenant_id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "accounting_account_code" "text",
    "xero_item_code" "text",
    "active" boolean DEFAULT true,
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."billing_products" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."billing_products_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."billing_products_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."billing_products_id_seq" OWNED BY "public"."billing_products"."id";



CREATE TABLE IF NOT EXISTS "public"."billing_subscription_items" (
    "id" bigint NOT NULL,
    "subscription_id" bigint,
    "price_id" bigint,
    "quantity" integer DEFAULT 1,
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."billing_subscription_items" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."billing_subscription_items_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."billing_subscription_items_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."billing_subscription_items_id_seq" OWNED BY "public"."billing_subscription_items"."id";



CREATE TABLE IF NOT EXISTS "public"."billing_subscriptions" (
    "id" bigint NOT NULL,
    "tenant_id" "text" NOT NULL,
    "customer_id" bigint,
    "status" "text" NOT NULL,
    "current_period_start" timestamp with time zone,
    "current_period_end" timestamp with time zone,
    "cancel_at_period_end" boolean DEFAULT false,
    "canceled_at" timestamp with time zone,
    "trial_end" timestamp with time zone,
    "stripe_subscription_id" "text",
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "billing_subscriptions_status_check" CHECK (("status" = ANY (ARRAY['trialing'::"text", 'active'::"text", 'past_due'::"text", 'canceled'::"text", 'incomplete'::"text", 'incomplete_expired'::"text", 'unpaid'::"text", 'paused'::"text"])))
);


ALTER TABLE "public"."billing_subscriptions" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."billing_subscriptions_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."billing_subscriptions_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."billing_subscriptions_id_seq" OWNED BY "public"."billing_subscriptions"."id";



CREATE TABLE IF NOT EXISTS "public"."billing_tax_rates" (
    "id" bigint NOT NULL,
    "tenant_id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "percentage" numeric(5,2) NOT NULL,
    "inclusive" boolean DEFAULT false,
    "jurisdiction" "text",
    "active" boolean DEFAULT true,
    "stripe_tax_rate_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."billing_tax_rates" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."billing_tax_rates_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."billing_tax_rates_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."billing_tax_rates_id_seq" OWNED BY "public"."billing_tax_rates"."id";



CREATE TABLE IF NOT EXISTS "public"."billing_tax_settings" (
    "tenant_id" "text" NOT NULL,
    "default_tax_rate_id" bigint,
    "tax_behavior" "text",
    "country" "text",
    "region" "text",
    "metadata" "jsonb",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "billing_tax_settings_tax_behavior_check" CHECK (("tax_behavior" = ANY (ARRAY['exclusive'::"text", 'inclusive'::"text"])))
);


ALTER TABLE "public"."billing_tax_settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."billing_webhook_events" (
    "id" bigint NOT NULL,
    "provider" "text" NOT NULL,
    "event_type" "text" NOT NULL,
    "payload" "jsonb" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text",
    "error_message" "text",
    "received_at" timestamp with time zone DEFAULT "now"(),
    "processed_at" timestamp with time zone,
    CONSTRAINT "billing_webhook_events_provider_check" CHECK (("provider" = ANY (ARRAY['stripe'::"text", 'xero'::"text"]))),
    CONSTRAINT "billing_webhook_events_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processed'::"text", 'error'::"text"])))
);


ALTER TABLE "public"."billing_webhook_events" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."billing_webhook_events_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."billing_webhook_events_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."billing_webhook_events_id_seq" OWNED BY "public"."billing_webhook_events"."id";



CREATE TABLE IF NOT EXISTS "public"."blog_comments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "blog_post_id" "uuid",
    "author_id" "uuid",
    "content" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text",
    "parent_comment_id" "uuid"
);


ALTER TABLE "public"."blog_comments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."blog_content_links" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "blog_post_id" "uuid",
    "link_type" "text" NOT NULL,
    "profile_id" "uuid",
    "program_id" "uuid",
    "service_id" "uuid",
    "art_id" "uuid",
    "story_id" "uuid",
    "context" "text"
);


ALTER TABLE "public"."blog_content_links" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."blog_media" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "blog_post_id" "uuid",
    "media_type" "text" NOT NULL,
    "url" "text" NOT NULL,
    "thumbnail_url" "text",
    "title" "text",
    "caption" "text",
    "alt_text" "text",
    "video_provider" "text",
    "video_embed_code" "text",
    "file_size" integer,
    "mime_type" "text",
    "display_order" integer DEFAULT 0
);


ALTER TABLE "public"."blog_media" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."blog_posts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "published_at" timestamp with time zone,
    "title" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "excerpt" "text",
    "content" "text" NOT NULL,
    "featured_image_url" "text",
    "featured_image_caption" "text",
    "author_id" "uuid",
    "co_authors" "uuid"[],
    "status" "text" DEFAULT 'draft'::"text",
    "tags" "text"[],
    "categories" "text"[],
    "meta_title" "text",
    "meta_description" "text",
    "view_count" integer DEFAULT 0,
    "share_count" integer DEFAULT 0,
    "reading_time_minutes" integer,
    "empathy_ledger_transcript_id" "uuid",
    "empathy_ledger_story_id" "uuid",
    "synced_from_empathy_ledger" boolean DEFAULT false,
    "video_url" "text",
    "audio_url" "text",
    "cultural_sensitivity_flag" boolean DEFAULT false
);


ALTER TABLE "public"."blog_posts" OWNER TO "postgres";


COMMENT ON COLUMN "public"."blog_posts"."empathy_ledger_transcript_id" IS 'Reference to transcript in Empathy Ledger if synced from there';



COMMENT ON COLUMN "public"."blog_posts"."empathy_ledger_story_id" IS 'Reference to story in Empathy Ledger if synced from there';



COMMENT ON COLUMN "public"."blog_posts"."synced_from_empathy_ledger" IS 'True if this content was synced from Empathy Ledger';



COMMENT ON COLUMN "public"."blog_posts"."video_url" IS 'URL to video content (from Empathy Ledger or direct upload)';



COMMENT ON COLUMN "public"."blog_posts"."audio_url" IS 'URL to audio content (from Empathy Ledger or direct upload)';



COMMENT ON COLUMN "public"."blog_posts"."cultural_sensitivity_flag" IS 'Requires cultural sensitivity or elder review';



CREATE TABLE IF NOT EXISTS "public"."blog_posts_profiles" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "blog_post_id" "uuid" NOT NULL,
    "public_profile_id" "uuid" NOT NULL,
    "role" "text",
    "is_featured" boolean DEFAULT false,
    "display_order" integer DEFAULT 0,
    "created_at" timestamp without time zone DEFAULT "now"()
);


ALTER TABLE "public"."blog_posts_profiles" OWNER TO "postgres";


COMMENT ON TABLE "public"."blog_posts_profiles" IS 'Links people to stories/blog posts they are featured in';



CREATE TABLE IF NOT EXISTS "public"."bookkeeping_project_links" (
    "id" bigint NOT NULL,
    "tenant_id" "text" NOT NULL,
    "transaction_id" bigint NOT NULL,
    "project_id" "text" NOT NULL,
    "allocation" numeric(5,4) DEFAULT 1.0,
    "note" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "bookkeeping_project_links_allocation_check" CHECK ((("allocation" > (0)::numeric) AND ("allocation" <= (1)::numeric)))
);


ALTER TABLE "public"."bookkeeping_project_links" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."bookkeeping_project_links_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."bookkeeping_project_links_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."bookkeeping_project_links_id_seq" OWNED BY "public"."bookkeeping_project_links"."id";



CREATE TABLE IF NOT EXISTS "public"."bookkeeping_receipts" (
    "id" bigint NOT NULL,
    "tenant_id" "text" NOT NULL,
    "receipt_id" "text",
    "vendor" "text",
    "amount" numeric(14,2),
    "currency" "text",
    "receipt_date" "date",
    "url" "text",
    "status" "text",
    "raw" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."bookkeeping_receipts" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."bookkeeping_receipts_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."bookkeeping_receipts_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."bookkeeping_receipts_id_seq" OWNED BY "public"."bookkeeping_receipts"."id";



CREATE TABLE IF NOT EXISTS "public"."bookkeeping_rules" (
    "id" bigint NOT NULL,
    "tenant_id" "text" NOT NULL,
    "pattern" "text" NOT NULL,
    "category" "text" NOT NULL,
    "account_code" "text",
    "priority" integer DEFAULT 100,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."bookkeeping_rules" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."bookkeeping_rules_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."bookkeeping_rules_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."bookkeeping_rules_id_seq" OWNED BY "public"."bookkeeping_rules"."id";



CREATE TABLE IF NOT EXISTS "public"."bookkeeping_sync_state" (
    "tenant_id" "text" NOT NULL,
    "last_synced_at" timestamp with time zone,
    "last_page" integer,
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."bookkeeping_sync_state" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."bookkeeping_transactions" (
    "id" bigint NOT NULL,
    "tenant_id" "text" NOT NULL,
    "xero_id" "text",
    "txn_date" "date" NOT NULL,
    "amount" numeric(14,2) NOT NULL,
    "currency" "text",
    "direction" "text",
    "description" "text",
    "contact_name" "text",
    "account_code" "text",
    "account_name" "text",
    "category" "text",
    "category_confidence" numeric(3,2) DEFAULT 0,
    "raw" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "bookkeeping_transactions_direction_check" CHECK (("direction" = ANY (ARRAY['spent'::"text", 'received'::"text"])))
);


ALTER TABLE "public"."bookkeeping_transactions" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."bookkeeping_transactions_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."bookkeeping_transactions_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."bookkeeping_transactions_id_seq" OWNED BY "public"."bookkeeping_transactions"."id";



CREATE TABLE IF NOT EXISTS "public"."brand_tests" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "test_type" "text" DEFAULT 'content'::"text" NOT NULL,
    "is_active" boolean DEFAULT false,
    "start_date" "date",
    "end_date" "date",
    "target_audience" "text",
    "hypothesis" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "author_id" "text" DEFAULT 'anonymous'::"text"
);


ALTER TABLE "public"."brand_tests" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."business_agent_queries" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "query" "text" NOT NULL,
    "intent" "jsonb" DEFAULT '{}'::"jsonb",
    "response" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "confidence" numeric(3,2) DEFAULT 0.50,
    "sources" "text"[] DEFAULT '{}'::"text"[],
    "actions" "text"[] DEFAULT '{}'::"text"[],
    "user_feedback" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "business_agent_queries_user_feedback_check" CHECK (("user_feedback" = ANY (ARRAY['helpful'::"text", 'not_helpful'::"text", 'partially_helpful'::"text"])))
);


ALTER TABLE "public"."business_agent_queries" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."business_alerts" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "alert_type" "text" NOT NULL,
    "priority" integer DEFAULT 5,
    "title" "text" NOT NULL,
    "description" "text" NOT NULL,
    "action_required" "text",
    "due_date" timestamp with time zone,
    "status" "text" DEFAULT 'active'::"text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."business_alerts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."businesses" (
    "id" integer NOT NULL,
    "userId" integer,
    "name" character varying(255) NOT NULL,
    "category" "public"."business_category" NOT NULL,
    "description" "text" NOT NULL,
    "address" character varying(500),
    "phone" character varying(50),
    "email" character varying(320),
    "website" character varying(500),
    "facebook" character varying(500),
    "instagram" character varying(500),
    "imageUrl" character varying(1000),
    "status" "public"."business_status" DEFAULT 'pending'::"public"."business_status" NOT NULL,
    "submittedBy" character varying(255),
    "submitterEmail" character varying(320) NOT NULL,
    "createdAt" timestamp without time zone DEFAULT "now"() NOT NULL,
    "updatedAt" timestamp without time zone DEFAULT "now"() NOT NULL,
    "userOpenId" "uuid"
);


ALTER TABLE "public"."businesses" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."businesses_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."businesses_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."businesses_id_seq" OWNED BY "public"."businesses"."id";



CREATE TABLE IF NOT EXISTS "public"."calendar_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "google_event_id" "text" NOT NULL,
    "google_calendar_id" "text" DEFAULT 'primary'::"text",
    "calendar_name" "text",
    "calendar_color" "text",
    "title" "text" NOT NULL,
    "description" "text",
    "start_time" timestamp with time zone NOT NULL,
    "end_time" timestamp with time zone,
    "location" "text",
    "attendees" "jsonb" DEFAULT '[]'::"jsonb",
    "organizer_email" "text",
    "is_all_day" boolean DEFAULT false,
    "recurrence_rule" "text",
    "recurring_event_id" "text",
    "status" "text" DEFAULT 'confirmed'::"text",
    "transparency" "text",
    "visibility" "text",
    "event_type" "text" DEFAULT 'meeting'::"text",
    "project_code" "text",
    "detected_project_code" "text",
    "manual_project_code" "text",
    "ghl_contact_ids" "text"[] DEFAULT '{}'::"text"[],
    "attendee_contact_matches" "jsonb" DEFAULT '[]'::"jsonb",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "html_link" "text",
    "etag" "text",
    "synced_at" timestamp with time zone DEFAULT "now"(),
    "sync_source" "text" DEFAULT 'google'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."calendar_events" OWNER TO "postgres";


COMMENT ON TABLE "public"."calendar_events" IS 'Synced Google Calendar events with project linking and attendee extraction for ACT Intelligence Platform';



CREATE TABLE IF NOT EXISTS "public"."canonical_entities" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "entity_type" "text" NOT NULL,
    "canonical_name" "text" NOT NULL,
    "canonical_email" "text",
    "canonical_phone" "text",
    "canonical_company" "text",
    "merged_from" "uuid"[] DEFAULT ARRAY[]::"uuid"[],
    "merge_count" integer DEFAULT 1,
    "last_merge_at" timestamp with time zone,
    "confidence" numeric(3,2) DEFAULT 1.00,
    "data_completeness" numeric(3,2),
    "verification_status" "text" DEFAULT 'unverified'::"text",
    "enrichment_data" "jsonb" DEFAULT '{}'::"jsonb",
    "enriched_at" timestamp with time zone,
    "cultural_affiliation" "text",
    "community_connections" "text"[],
    "relationship_strength" "text",
    "primary_project_codes" "text"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tags" "text"[],
    "projects" "text"[],
    "engagement_status" "text",
    "enrichment_source" "text"
);


ALTER TABLE "public"."canonical_entities" OWNER TO "postgres";


COMMENT ON TABLE "public"."canonical_entities" IS 'Master entity records after deduplication and merging';



CREATE TABLE IF NOT EXISTS "public"."ce_activities" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "user_id" "text" DEFAULT 'anonymous'::"text",
    "activity_type" "text" NOT NULL,
    "message" "text" NOT NULL,
    "event_timestamp" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."ce_activities" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ce_backups" (
    "id" "text" NOT NULL,
    "backup_timestamp" timestamp with time zone DEFAULT "now"(),
    "size_bytes" bigint DEFAULT 0,
    "checksum" "text",
    "data_types" "text"[] DEFAULT ARRAY[]::"text"[],
    "version" "text" DEFAULT '1.0'::"text",
    "is_completed" boolean DEFAULT false,
    "created_by" "text" DEFAULT 'system'::"text",
    "description" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."ce_backups" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ce_brand_analyses" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "content_id" "uuid",
    "brand_values_demonstrated" "jsonb" DEFAULT '[]'::"jsonb",
    "authenticity_score" real DEFAULT 0,
    "emotional_resonance" real DEFAULT 0,
    "community_impact" real DEFAULT 0,
    "overall_score" real DEFAULT 0,
    "analysis_date" timestamp with time zone DEFAULT "now"(),
    "analyst_id" "text" DEFAULT 'system'::"text"
);


ALTER TABLE "public"."ce_brand_analyses" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ce_brand_tests" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "test_type" "text" DEFAULT 'content'::"text" NOT NULL,
    "is_active" boolean DEFAULT false,
    "start_date" "date",
    "end_date" "date",
    "target_audience" "text",
    "hypothesis" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "author_id" "text" DEFAULT 'anonymous'::"text"
);


ALTER TABLE "public"."ce_brand_tests" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ce_media_assets" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "filename" "text" NOT NULL,
    "file_path" "text" NOT NULL,
    "file_size" integer,
    "mime_type" "text",
    "category" "text",
    "tags" "text"[] DEFAULT ARRAY[]::"text"[],
    "uploaded_by" "text" DEFAULT 'anonymous'::"text",
    "uploaded_at" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."ce_media_assets" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ce_metrics" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "user_id" "text" DEFAULT 'anonymous'::"text",
    "stories_analyzed" integer DEFAULT 0,
    "brand_tests_active" integer DEFAULT 0,
    "content_items" integer DEFAULT 0,
    "brand_score" real DEFAULT 0,
    "last_updated" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."ce_metrics" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ce_saved_searches" (
    "id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "query" "text" NOT NULL,
    "filters" "jsonb" DEFAULT '{}'::"jsonb",
    "user_id" "text" DEFAULT 'anonymous'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "last_used" timestamp with time zone DEFAULT "now"(),
    "use_count" integer DEFAULT 0
);


ALTER TABLE "public"."ce_saved_searches" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ce_search_history" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "user_id" "text" DEFAULT 'anonymous'::"text",
    "query" "text" NOT NULL,
    "filters" "jsonb" DEFAULT '{}'::"jsonb",
    "results_count" integer DEFAULT 0,
    "search_timestamp" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."ce_search_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ce_stories" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "title" "text" NOT NULL,
    "content" "text" NOT NULL,
    "participant_name" "text" NOT NULL,
    "participant_age" integer,
    "location" "text",
    "date_recorded" "date",
    "themes" "text"[] DEFAULT ARRAY[]::"text"[],
    "impact_level" "text",
    "summary" "text",
    "transcript_id" "text",
    "is_published" boolean DEFAULT false,
    "tags" "text"[] DEFAULT ARRAY[]::"text"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "author_id" "text" DEFAULT 'anonymous'::"text"
);


ALTER TABLE "public"."ce_stories" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ce_users" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "email" "text" NOT NULL,
    "username" "text" NOT NULL,
    "name" "text" NOT NULL,
    "user_role" "text" DEFAULT 'staff'::"text" NOT NULL,
    "permissions" "text"[] DEFAULT ARRAY[]::"text"[],
    "password_hash" "text" NOT NULL,
    "last_login" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_active" boolean DEFAULT true
);


ALTER TABLE "public"."ce_users" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."channel_messages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "channel" "text" NOT NULL,
    "channel_id" "text",
    "message_id" "text",
    "thread_id" "text",
    "task_id" "uuid",
    "direction" "text",
    "content" "text",
    "sender" "text",
    "message_type" "text" DEFAULT 'text'::"text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "channel_messages_direction_check" CHECK (("direction" = ANY (ARRAY['inbound'::"text", 'outbound'::"text"])))
);


ALTER TABLE "public"."channel_messages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."clearinghouse_documents" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "content" "text",
    "url" "text",
    "format" "text" DEFAULT 'markdown'::"text",
    "source_system" "text" NOT NULL,
    "source_record_id" "text",
    "source_url" "text",
    "submitted_by" "text",
    "tags" "text"[] DEFAULT '{}'::"text"[],
    "status" "text" DEFAULT 'pending'::"text",
    "summary" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "clearinghouse_documents_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'verified'::"text", 'rejected'::"text"])))
);


ALTER TABLE "public"."clearinghouse_documents" OWNER TO "postgres";


COMMENT ON TABLE "public"."clearinghouse_documents" IS 'Partner-submitted documents (metadata + text) for the clearinghouse';



COMMENT ON COLUMN "public"."clearinghouse_documents"."content" IS 'Optional raw markdown/text content (PDFs should provide url instead)';



COMMENT ON COLUMN "public"."clearinghouse_documents"."summary" IS 'Optional short summary or AI-generated abstract';



CREATE TABLE IF NOT EXISTS "public"."cms_content_blocks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" character varying(255) NOT NULL,
    "block_type" character varying(100) NOT NULL,
    "category" character varying(100),
    "description" "text",
    "schema" "jsonb" DEFAULT '{}'::"jsonb",
    "default_content" "jsonb" DEFAULT '{}'::"jsonb",
    "is_active" boolean DEFAULT true,
    "project_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."cms_content_blocks" OWNER TO "postgres";


COMMENT ON TABLE "public"."cms_content_blocks" IS 'Reusable content blocks for CMS';



CREATE TABLE IF NOT EXISTS "public"."cms_media" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" character varying(255) NOT NULL,
    "file_name" character varying(500) NOT NULL,
    "mime_type" character varying(100),
    "file_size" integer,
    "url" "text" NOT NULL,
    "alt_text" "text",
    "caption" "text",
    "category" character varying(100),
    "tags" "text"[],
    "usage" "text",
    "project_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."cms_media" OWNER TO "postgres";


COMMENT ON TABLE "public"."cms_media" IS 'Media library for images, videos, and documents';



CREATE TABLE IF NOT EXISTS "public"."cms_pages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "slug" character varying(255) NOT NULL,
    "title" character varying(500) NOT NULL,
    "description" "text",
    "page_type" character varying(50) DEFAULT 'content'::character varying,
    "status" character varying(20) DEFAULT 'draft'::character varying,
    "content" "jsonb" DEFAULT '{}'::"jsonb",
    "seo_title" character varying(500),
    "seo_description" "text",
    "seo_keywords" "text",
    "meta_data" "jsonb" DEFAULT '{}'::"jsonb",
    "project_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "published_at" timestamp with time zone
);


ALTER TABLE "public"."cms_pages" OWNER TO "postgres";


COMMENT ON TABLE "public"."cms_pages" IS 'Site-wide content management pages';



CREATE TABLE IF NOT EXISTS "public"."coe_key_people" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "profile_id" "uuid" NOT NULL,
    "role_title" "text" NOT NULL,
    "expertise_area" "text",
    "bio_override" "text",
    "display_order" integer DEFAULT 0,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "role" "text" NOT NULL,
    "role_description" "text"
);


ALTER TABLE "public"."coe_key_people" OWNER TO "postgres";


COMMENT ON COLUMN "public"."coe_key_people"."role" IS 'Standardized role from role_taxonomy (e.g., director, researcher). Use role_description for context.';



COMMENT ON COLUMN "public"."coe_key_people"."role_description" IS 'Free-text description of the role, e.g., "Research Director 2024-present"';



CREATE OR REPLACE VIEW "public"."coe_key_people_v" AS
 SELECT "id",
    "profile_id",
    "role",
    "role" AS "role_title",
    "expertise_area",
    "bio_override",
    "display_order",
    "is_active",
    "created_at"
   FROM "public"."coe_key_people";


ALTER VIEW "public"."coe_key_people_v" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."collection_media" (
    "collection_id" "uuid" NOT NULL,
    "media_id" "uuid" NOT NULL,
    "sort_order" integer DEFAULT 0,
    "caption" "text",
    "featured_in_collection" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."collection_media" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."communications_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ghl_contact_id" "text",
    "channel" "text" NOT NULL,
    "direction" "text" NOT NULL,
    "from_identity" "uuid",
    "to_identities" "uuid"[],
    "subject" "text",
    "content_preview" "text",
    "full_content_ref" "text",
    "summary" "text",
    "sentiment" "text",
    "topics" "text"[],
    "action_items" "jsonb",
    "key_decisions" "text"[],
    "waiting_for_response" boolean DEFAULT false,
    "response_needed_by" "text",
    "follow_up_date" "date",
    "source_system" "text" NOT NULL,
    "source_id" "text",
    "source_thread_id" "text",
    "parent_id" "uuid",
    "occurred_at" timestamp with time zone NOT NULL,
    "synced_at" timestamp with time zone DEFAULT "now"(),
    "enriched_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "contact_email" "text",
    "contact_name" "text",
    "is_reply" boolean DEFAULT false,
    "has_reply" boolean DEFAULT false,
    "requires_response" boolean DEFAULT false,
    "response_received_at" timestamp with time zone,
    "project_code" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."communications_history" OWNER TO "postgres";


COMMENT ON TABLE "public"."communications_history" IS 'Full communication tracking with AI enrichment - respects cultural protocols';



COMMENT ON COLUMN "public"."communications_history"."content_preview" IS 'First 500 chars only - no sensitive cultural data';



COMMENT ON COLUMN "public"."communications_history"."contact_email" IS 'Email address for linking (allows retroactive contact matching)';



COMMENT ON COLUMN "public"."communications_history"."requires_response" IS 'Flag for follow-up tracking';



COMMENT ON COLUMN "public"."communications_history"."project_code" IS 'ACT project code (e.g., ACT-JH) for linking communications to projects';



CREATE TABLE IF NOT EXISTS "public"."community_connections" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "storyteller_id" "uuid",
    "connection_type" "public"."connection_type_enum" NOT NULL,
    "connected_entity" character varying(500),
    "relationship_nature" character varying(200),
    "connection_strength" "public"."connection_strength_enum",
    "evidence_quote" "text",
    "relationship_duration" character varying(100),
    "interaction_frequency" character varying(100),
    "mutual_benefit_description" "text",
    "geographic_scope" character varying(100),
    "cultural_significance" numeric(3,2),
    "traditional_protocol_involved" boolean DEFAULT false,
    "influence_potential" numeric(3,2),
    "resource_access_value" numeric(3,2),
    "knowledge_exchange_value" numeric(3,2),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."community_connections" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."community_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "event_type" "text" NOT NULL,
    "event_category" "text" NOT NULL,
    "event_name" "text" NOT NULL,
    "user_id" "uuid",
    "session_id" "text",
    "user_agent" "text",
    "ip_address" "inet",
    "project_id" "uuid",
    "story_id" "uuid",
    "outcome_id" "uuid",
    "community_id" "uuid",
    "event_properties" "jsonb" DEFAULT '{}'::"jsonb",
    "event_metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "geographic_data" "jsonb" DEFAULT '{}'::"jsonb",
    "device_data" "jsonb" DEFAULT '{}'::"jsonb",
    "referrer_data" "jsonb" DEFAULT '{}'::"jsonb",
    "conversion_funnel_stage" "text",
    "engagement_score" numeric DEFAULT 0,
    "business_value" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "event_timestamp" timestamp with time zone DEFAULT "now"(),
    "session_start_time" timestamp with time zone,
    "time_on_page" integer,
    "data_retention_policy" "text" DEFAULT 'standard'::"text",
    "anonymized" boolean DEFAULT false,
    "consent_level" "text" DEFAULT 'basic'::"text",
    CONSTRAINT "valid_consent_level" CHECK (("consent_level" = ANY (ARRAY['basic'::"text", 'analytics'::"text", 'personalization'::"text", 'marketing'::"text"]))),
    CONSTRAINT "valid_event_category" CHECK (("event_category" = ANY (ARRAY['engagement'::"text", 'content'::"text", 'collaboration'::"text", 'impact'::"text", 'technical'::"text"]))),
    CONSTRAINT "valid_event_type" CHECK (("event_type" = ANY (ARRAY['user_action'::"text", 'system_event'::"text", 'milestone'::"text", 'external_integration'::"text"])))
);


ALTER TABLE "public"."community_events" OWNER TO "postgres";


COMMENT ON TABLE "public"."community_events" IS 'Event tracking for analytics and user behavior insights';



CREATE OR REPLACE VIEW "public"."community_engagement_overview" AS
 SELECT "date_trunc"('week'::"text", "created_at") AS "week",
    "event_category",
    "count"(*) AS "event_count",
    "count"(DISTINCT "user_id") AS "unique_users",
    "avg"("engagement_score") AS "avg_engagement_score",
    "count"(*) FILTER (WHERE ("event_type" = 'user_action'::"text")) AS "user_actions",
    "count"(*) FILTER (WHERE ("event_type" = 'milestone'::"text")) AS "milestones_reached"
   FROM "public"."community_events" "ce"
  WHERE ("created_at" >= ("now"() - '84 days'::interval))
  GROUP BY ("date_trunc"('week'::"text", "created_at")), "event_category"
  ORDER BY ("date_trunc"('week'::"text", "created_at")) DESC, ("count"(*)) DESC;


ALTER VIEW "public"."community_engagement_overview" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."community_feedback" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "content_id" "uuid",
    "content_type" "text" NOT NULL,
    "content_url" "text",
    "feedback_type" "text" NOT NULL,
    "feedback_text" "text" NOT NULL,
    "category" "text",
    "severity" "text",
    "submitted_by" "uuid",
    "submitter_name" "text",
    "submitter_email" "text",
    "anonymous" boolean DEFAULT false,
    "status" "text" DEFAULT 'new'::"text",
    "reviewed_by" "uuid",
    "reviewed_at" timestamp with time zone,
    "review_notes" "text",
    "action_taken" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "community_feedback_feedback_type_check" CHECK (("feedback_type" = ANY (ARRAY['correction'::"text", 'suggestion'::"text", 'appreciation'::"text", 'concern'::"text"]))),
    CONSTRAINT "community_feedback_severity_check" CHECK (("severity" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text", 'critical'::"text"]))),
    CONSTRAINT "community_feedback_status_check" CHECK (("status" = ANY (ARRAY['new'::"text", 'reviewing'::"text", 'addressed'::"text", 'dismissed'::"text"])))
);


ALTER TABLE "public"."community_feedback" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."community_health_metrics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "community_id" "uuid",
    "active_users_daily" integer DEFAULT 0,
    "active_users_weekly" integer DEFAULT 0,
    "active_users_monthly" integer DEFAULT 0,
    "new_user_registrations" integer DEFAULT 0,
    "user_retention_rate" numeric DEFAULT 0,
    "stories_published" integer DEFAULT 0,
    "project_updates_posted" integer DEFAULT 0,
    "outcomes_reported" integer DEFAULT 0,
    "community_interactions" integer DEFAULT 0,
    "new_collaborations" integer DEFAULT 0,
    "active_projects" integer DEFAULT 0,
    "completed_projects" integer DEFAULT 0,
    "cross_community_collaborations" integer DEFAULT 0,
    "total_beneficiaries" integer DEFAULT 0,
    "verified_outcomes" integer DEFAULT 0,
    "community_value_generated" numeric DEFAULT 0,
    "cultural_knowledge_preserved" integer DEFAULT 0,
    "diversity_index" numeric DEFAULT 0,
    "inclusion_score" numeric DEFAULT 0,
    "sustainability_index" numeric DEFAULT 0,
    "innovation_rate" numeric DEFAULT 0,
    "content_quality_average" numeric DEFAULT 0,
    "user_satisfaction_score" numeric DEFAULT 0,
    "platform_reliability_score" numeric DEFAULT 0,
    "metric_date" "date" NOT NULL,
    "metric_period" "text" NOT NULL,
    "calculated_at" timestamp with time zone DEFAULT "now"(),
    "calculation_method" "text",
    "data_completeness_score" numeric DEFAULT 1.0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "valid_metric_period" CHECK (("metric_period" = ANY (ARRAY['daily'::"text", 'weekly'::"text", 'monthly'::"text", 'quarterly'::"text"])))
);


ALTER TABLE "public"."community_health_metrics" OWNER TO "postgres";


COMMENT ON TABLE "public"."community_health_metrics" IS 'Community health and engagement metrics over time';



CREATE TABLE IF NOT EXISTS "public"."community_inquiries" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "name" "text" NOT NULL,
    "email" "text" NOT NULL,
    "organization" "text",
    "inquiry_type" "text" NOT NULL,
    "subject" "text",
    "message" "text" NOT NULL,
    "location" "text",
    "how_heard" "text",
    "follow_up_consent" boolean DEFAULT true,
    "status" "text" DEFAULT 'new'::"text",
    "assigned_to" "text",
    "response_sent_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."community_inquiries" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."registered_services_profiles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "program_id" "uuid",
    "public_profile_id" "uuid",
    "role" "text" NOT NULL,
    "role_description" "text",
    "display_order" integer DEFAULT 0,
    "is_featured" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."registered_services_profiles" OWNER TO "postgres";


COMMENT ON TABLE "public"."registered_services_profiles" IS 'Junction table linking public_profiles to community programs (registered_services). NAMING NOTE: This table is misleadingly named. It links to community programs, not services. Prefer using the community_programs_profiles_v view for clarity.';



COMMENT ON COLUMN "public"."registered_services_profiles"."program_id" IS 'References registered_services.id (which stores COMMUNITY PROGRAMS, not services)';



CREATE OR REPLACE VIEW "public"."community_programs_profiles_v" AS
 SELECT "id",
    "program_id" AS "community_program_id",
    "program_id",
    "public_profile_id" AS "profile_id",
    "public_profile_id",
    "role",
    "role_description",
    "display_order",
    "is_featured",
    "created_at"
   FROM "public"."registered_services_profiles";


ALTER VIEW "public"."community_programs_profiles_v" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."compliance_tracking" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "compliance_type" "text" NOT NULL,
    "status" "text" DEFAULT 'unknown'::"text" NOT NULL,
    "due_date" "date",
    "details" "jsonb" DEFAULT '{}'::"jsonb",
    "next_actions" "text"[] DEFAULT '{}'::"text"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "compliance_tracking_compliance_type_check" CHECK (("compliance_type" = ANY (ARRAY['bas'::"text", 'payg'::"text", 'superannuation'::"text", 'rd_tax_incentive'::"text", 'indigenous_programs'::"text"]))),
    CONSTRAINT "compliance_tracking_status_check" CHECK (("status" = ANY (ARRAY['current'::"text", 'due_soon'::"text", 'overdue'::"text", 'unknown'::"text"])))
);


ALTER TABLE "public"."compliance_tracking" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."consent_management" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "storyteller_id" "uuid",
    "consent_type" "public"."consent_type_enum" NOT NULL,
    "consent_granted" boolean NOT NULL,
    "consent_scope" "jsonb" NOT NULL,
    "traditional_protocols_followed" boolean DEFAULT false,
    "elder_consultation" boolean DEFAULT false,
    "community_consultation" boolean DEFAULT false,
    "ai_analysis_consent" boolean DEFAULT false,
    "quote_extraction_consent" boolean DEFAULT false,
    "theme_analysis_consent" boolean DEFAULT false,
    "sharing_consent_level" "public"."sharing_consent_enum",
    "attribution_requirements" "text",
    "ownership_assertion" "text",
    "benefit_sharing_preferences" "jsonb",
    "consent_date" timestamp with time zone NOT NULL,
    "expiry_date" timestamp with time zone,
    "renewal_required" boolean DEFAULT false,
    "withdrawal_instructions" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."consent_management" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."consent_records" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "storyteller_id" "uuid" NOT NULL,
    "consent_type" "text" NOT NULL,
    "consent_given" boolean NOT NULL,
    "consent_level" "text",
    "permissions" "jsonb" DEFAULT '{}'::"jsonb",
    "restrictions" "text"[],
    "expiry_date" timestamp with time zone,
    "consent_method" "text",
    "consent_context" "text",
    "legal_basis" "text",
    "cultural_protocols_followed" boolean DEFAULT false,
    "cultural_notes" "text",
    "witnessed_by" "uuid",
    "recorded_by" "uuid",
    "status" "text" DEFAULT 'active'::"text",
    "withdrawal_date" timestamp with time zone,
    "withdrawal_reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "consent_records_consent_level_check" CHECK (("consent_level" = ANY (ARRAY['full'::"text", 'limited'::"text", 'research_only'::"text", 'organization_only'::"text"]))),
    CONSTRAINT "consent_records_consent_method_check" CHECK (("consent_method" = ANY (ARRAY['verbal'::"text", 'written'::"text", 'digital'::"text", 'implied'::"text"]))),
    CONSTRAINT "consent_records_consent_type_check" CHECK (("consent_type" = ANY (ARRAY['story_sharing'::"text", 'ai_analysis'::"text", 'quote_extraction'::"text", 'research_participation'::"text", 'media_use'::"text", 'contact_permission'::"text"]))),
    CONSTRAINT "consent_records_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'withdrawn'::"text", 'expired'::"text", 'superseded'::"text"])))
);


ALTER TABLE "public"."consent_records" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."email_financial_documents" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "tenant_id" "text" NOT NULL,
    "document_type" "text" NOT NULL,
    "vendor" "text" NOT NULL,
    "amount" numeric(10,2),
    "currency" "text" DEFAULT 'AUD'::"text",
    "transaction_date" "date",
    "gmail_message_id" "text" NOT NULL,
    "account_email" "text" NOT NULL,
    "subject" "text",
    "from_email" "text",
    "confidence" numeric(3,2),
    "extraction_method" "text",
    "raw_extraction" "jsonb",
    "xero_transaction_id" "text",
    "xero_contact_id" "text",
    "reconciliation_status" "text" DEFAULT 'unmatched'::"text",
    "reconciliation_confidence" numeric(3,2),
    "reconciliation_date" timestamp with time zone,
    "reconciliation_notes" "text",
    "is_subscription" boolean DEFAULT false,
    "subscription_frequency" "text",
    "subscription_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "processed_by" "text",
    "target_account_email" "text" DEFAULT 'accounts@act.place'::"text",
    "consolidation_status" "text" DEFAULT 'not_started'::"text",
    "vendor_contact_email" "text",
    "consolidation_notes" "text",
    "next_payment_date" "date",
    "last_payment_date" "date",
    "payment_day_of_month" integer,
    "payment_pattern_confidence" numeric(3,2),
    "category" "text",
    "tags" "jsonb" DEFAULT '[]'::"jsonb",
    "data_quality_score" integer DEFAULT 0,
    "subscription_status" "text" DEFAULT 'active'::"text",
    "cancellation_date" "date",
    "cancellation_reason" "text",
    "renewal_reminder_sent" boolean DEFAULT false,
    "last_renewal_reminder_date" "date",
    "usage_last_checked_date" "date",
    "usage_status" "text" DEFAULT 'unknown'::"text",
    CONSTRAINT "check_consolidation_status" CHECK ((("consolidation_status" IS NULL) OR ("consolidation_status" = ANY (ARRAY['not_started'::"text", 'vendor_contacted'::"text", 'awaiting_confirmation'::"text", 'completed'::"text", 'skipped'::"text"])))),
    CONSTRAINT "check_payment_confidence" CHECK ((("payment_pattern_confidence" IS NULL) OR (("payment_pattern_confidence" >= (0)::numeric) AND ("payment_pattern_confidence" <= (1)::numeric)))),
    CONSTRAINT "check_subscription_status" CHECK ((("subscription_status" IS NULL) OR ("subscription_status" = ANY (ARRAY['active'::"text", 'cancelled'::"text", 'paused'::"text", 'trial'::"text", 'past_due'::"text", 'unknown'::"text"])))),
    CONSTRAINT "check_usage_status" CHECK ((("usage_status" IS NULL) OR ("usage_status" = ANY (ARRAY['active'::"text", 'inactive'::"text", 'unknown'::"text"])))),
    CONSTRAINT "email_financial_documents_category_check" CHECK (("category" = ANY (ARRAY['Software/SaaS'::"text", 'Communication'::"text", 'Cloud Storage'::"text", 'Finance/Accounting'::"text", 'Travel'::"text", 'Design/Creative'::"text", 'Marketing'::"text", 'Infrastructure/Hosting'::"text", 'AI/ML Tools'::"text", 'E-commerce'::"text", 'Analytics'::"text", 'Development'::"text", 'Other'::"text", 'saas'::"text", 'infrastructure'::"text", 'design'::"text", 'marketing'::"text", 'communication'::"text", 'productivity'::"text", 'development'::"text", 'business'::"text", 'entertainment'::"text", 'other'::"text"]))),
    CONSTRAINT "email_financial_documents_confidence_check" CHECK ((("confidence" >= (0)::numeric) AND ("confidence" <= (1)::numeric))),
    CONSTRAINT "email_financial_documents_consolidation_status_check" CHECK (("consolidation_status" = ANY (ARRAY['not_started'::"text", 'vendor_contacted'::"text", 'awaiting_confirmation'::"text", 'completed'::"text", 'skipped'::"text"]))),
    CONSTRAINT "email_financial_documents_document_type_check" CHECK (("document_type" = ANY (ARRAY['subscription_receipt'::"text", 'invoice'::"text", 'payment_confirmation'::"text", 'refund'::"text", 'statement'::"text", 'other'::"text"]))),
    CONSTRAINT "email_financial_documents_extraction_method_check" CHECK (("extraction_method" = ANY (ARRAY['ai'::"text", 'structured_data'::"text", 'manual'::"text"]))),
    CONSTRAINT "email_financial_documents_payment_pattern_confidence_check" CHECK ((("payment_pattern_confidence" >= (0)::numeric) AND ("payment_pattern_confidence" <= (1)::numeric))),
    CONSTRAINT "email_financial_documents_reconciliation_status_check" CHECK (("reconciliation_status" = ANY (ARRAY['unmatched'::"text", 'auto_matched'::"text", 'manual_review'::"text", 'confirmed'::"text", 'disputed'::"text"]))),
    CONSTRAINT "email_financial_documents_subscription_frequency_check" CHECK ((("subscription_frequency" IS NULL) OR ("subscription_frequency" = ANY (ARRAY['daily'::"text", 'weekly'::"text", 'biweekly'::"text", 'monthly'::"text", 'quarterly'::"text", 'yearly'::"text", 'unknown'::"text"]))))
);


ALTER TABLE "public"."email_financial_documents" OWNER TO "postgres";


COMMENT ON TABLE "public"."email_financial_documents" IS 'Unified storage for all financial documents extracted from ACT Workspace emails. Supports subscriptions, invoices, receipts, payments, refunds, and statements with automatic Xero reconciliation.';



COMMENT ON COLUMN "public"."email_financial_documents"."confidence" IS 'AI extraction confidence score (0.0 to 1.0). Auto-reconcile if >=0.80 and amount <=250.';



COMMENT ON COLUMN "public"."email_financial_documents"."reconciliation_status" IS 'Reconciliation workflow: unmatched â†’ auto_matched/manual_review â†’ confirmed/disputed';



COMMENT ON COLUMN "public"."email_financial_documents"."target_account_email" IS 'Email account to consolidate this subscription to';



COMMENT ON COLUMN "public"."email_financial_documents"."consolidation_status" IS 'Progress of moving subscription to target account email';



COMMENT ON COLUMN "public"."email_financial_documents"."vendor_contact_email" IS 'Vendor contact email for billing changes';



COMMENT ON COLUMN "public"."email_financial_documents"."next_payment_date" IS 'Predicted date of next payment based on historical pattern analysis';



COMMENT ON COLUMN "public"."email_financial_documents"."last_payment_date" IS 'Most recent payment date from email receipts';



COMMENT ON COLUMN "public"."email_financial_documents"."payment_day_of_month" IS 'Most common day of month for this subscription (e.g., 15 for 15th)';



COMMENT ON COLUMN "public"."email_financial_documents"."payment_pattern_confidence" IS 'Confidence score (0-1) for payment prediction based on data consistency and volume';



COMMENT ON COLUMN "public"."email_financial_documents"."category" IS 'Subscription category for organization (saas, infrastructure, design, etc.)';



COMMENT ON COLUMN "public"."email_financial_documents"."tags" IS 'User-defined tags for flexible organization (Essential, Team, Personal, etc.)';



COMMENT ON COLUMN "public"."email_financial_documents"."subscription_status" IS 'Current lifecycle status of the subscription';



COMMENT ON COLUMN "public"."email_financial_documents"."usage_status" IS 'Whether the subscription shows recent usage/activity';



CREATE OR REPLACE VIEW "public"."consolidation_progress" AS
 SELECT "tenant_id",
    "account_email",
    "consolidation_status",
    "count"(*) AS "subscription_count",
    "sum"(
        CASE
            WHEN ("subscription_frequency" = 'monthly'::"text") THEN ("amount" * (12)::numeric)
            ELSE "amount"
        END) AS "annual_value"
   FROM "public"."email_financial_documents"
  WHERE ("is_subscription" = true)
  GROUP BY "tenant_id", "account_email", "consolidation_status"
  ORDER BY "account_email", "consolidation_status";


ALTER VIEW "public"."consolidation_progress" OWNER TO "postgres";


COMMENT ON VIEW "public"."consolidation_progress" IS 'Tracks progress of consolidating subscriptions to target email account';



CREATE TABLE IF NOT EXISTS "public"."contact_cadence_metrics" (
    "contact_id" "text" NOT NULL,
    "last_interaction" timestamp with time zone,
    "days_since_last" integer,
    "touchpoints_last_7" integer DEFAULT 0,
    "touchpoints_last_30" integer DEFAULT 0,
    "touchpoints_last_90" integer DEFAULT 0,
    "total_touchpoints" integer DEFAULT 0,
    "active_sources" "text"[] DEFAULT ARRAY[]::"text"[],
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."contact_cadence_metrics" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."contact_communications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ghl_contact_id" "text" NOT NULL,
    "comm_type" "text" NOT NULL,
    "direction" "text" NOT NULL,
    "subject" "text",
    "summary" "text",
    "full_content" "text",
    "sentiment_score" double precision,
    "topics" "text"[],
    "action_items" "text"[],
    "occurred_at" timestamp with time zone NOT NULL,
    "source" "text" NOT NULL,
    "source_id" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "contact_communications_comm_type_check" CHECK (("comm_type" = ANY (ARRAY['email'::"text", 'call'::"text", 'meeting'::"text", 'sms'::"text", 'chat'::"text", 'note'::"text"]))),
    CONSTRAINT "contact_communications_direction_check" CHECK (("direction" = ANY (ARRAY['inbound'::"text", 'outbound'::"text", 'internal'::"text"]))),
    CONSTRAINT "contact_communications_sentiment_score_check" CHECK ((("sentiment_score" >= ('-1'::integer)::double precision) AND ("sentiment_score" <= (1)::double precision))),
    CONSTRAINT "contact_communications_source_check" CHECK (("source" = ANY (ARRAY['ghl'::"text", 'gmail'::"text", 'calendar'::"text", 'manual'::"text"])))
);


ALTER TABLE "public"."contact_communications" OWNER TO "postgres";


COMMENT ON TABLE "public"."contact_communications" IS 'History of all communications with contacts from GHL, Gmail, Calendar';



CREATE TABLE IF NOT EXISTS "public"."contact_edges" (
    "id" bigint NOT NULL,
    "contact_a_id" bigint NOT NULL,
    "contact_b_id" bigint NOT NULL,
    "relationship_type" "text" NOT NULL,
    "strength" numeric(3,2) DEFAULT 1.0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "contact_edges_check" CHECK (("contact_a_id" <> "contact_b_id")),
    CONSTRAINT "contact_edges_relationship_type_check" CHECK (("relationship_type" = ANY (ARRAY['colleague'::"text", 'client'::"text", 'referral'::"text", 'mentor'::"text", 'friend'::"text", 'family'::"text"]))),
    CONSTRAINT "contact_edges_strength_check" CHECK ((("strength" >= 0.0) AND ("strength" <= 5.0)))
);


ALTER TABLE "public"."contact_edges" OWNER TO "postgres";


COMMENT ON TABLE "public"."contact_edges" IS 'Relationship graph between LinkedIn contacts';



CREATE SEQUENCE IF NOT EXISTS "public"."contact_edges_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."contact_edges_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."contact_edges_id_seq" OWNED BY "public"."contact_edges"."id";



CREATE TABLE IF NOT EXISTS "public"."contact_enrichments" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "contact_id" "uuid" NOT NULL,
    "enrichment" "jsonb" DEFAULT '{}'::"jsonb",
    "mode" "text" DEFAULT 'ai'::"text",
    "email_suggestions" "text"[] DEFAULT ARRAY[]::"text"[],
    "collaboration_potential" integer DEFAULT 50,
    "reasoning" "text",
    "project_alignment" "text"[] DEFAULT ARRAY[]::"text"[],
    "outreach_strategy" "jsonb" DEFAULT '{}'::"jsonb",
    "risk_factors" "text"[] DEFAULT ARRAY[]::"text"[],
    "value_proposition" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."contact_enrichments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."contact_intelligence" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "contact_id" "uuid" NOT NULL,
    "intelligence" "jsonb" DEFAULT '{}'::"jsonb",
    "collaboration_score" integer DEFAULT 50,
    "response_rate" integer DEFAULT 70,
    "influence_score" integer DEFAULT 50,
    "last_interaction" timestamp with time zone,
    "interaction_count" integer DEFAULT 0,
    "project_matches" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."contact_intelligence" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."contact_intelligence_insights" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "contact_id" "text" NOT NULL,
    "source" "text" DEFAULT 'linkedin'::"text" NOT NULL,
    "headline" "text",
    "current_company" "text",
    "current_role" "text",
    "last_post_title" "text",
    "last_post_url" "text",
    "last_post_published_at" timestamp with time zone,
    "highlights" "jsonb" DEFAULT '[]'::"jsonb",
    "enriched_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."contact_intelligence_insights" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."contact_intelligence_scores" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "person_id" "uuid" NOT NULL,
    "influence_score" integer DEFAULT 0,
    "accessibility_score" integer DEFAULT 0,
    "alignment_score" integer DEFAULT 0,
    "timing_score" integer DEFAULT 0,
    "strategic_value_score" integer DEFAULT 0,
    "composite_score" integer DEFAULT 0,
    "engagement_readiness" integer DEFAULT 0,
    "response_likelihood" integer DEFAULT 0,
    "last_calculated" timestamp with time zone DEFAULT "now"(),
    "calculation_method" "text" DEFAULT 'ai_analysis'::"text",
    "confidence_level" numeric(3,2) DEFAULT 0.5,
    CONSTRAINT "contact_intelligence_scores_accessibility_score_check" CHECK ((("accessibility_score" >= 0) AND ("accessibility_score" <= 100))),
    CONSTRAINT "contact_intelligence_scores_alignment_score_check" CHECK ((("alignment_score" >= 0) AND ("alignment_score" <= 100))),
    CONSTRAINT "contact_intelligence_scores_composite_score_check" CHECK ((("composite_score" >= 0) AND ("composite_score" <= 100))),
    CONSTRAINT "contact_intelligence_scores_engagement_readiness_check" CHECK ((("engagement_readiness" >= 0) AND ("engagement_readiness" <= 100))),
    CONSTRAINT "contact_intelligence_scores_influence_score_check" CHECK ((("influence_score" >= 0) AND ("influence_score" <= 100))),
    CONSTRAINT "contact_intelligence_scores_response_likelihood_check" CHECK ((("response_likelihood" >= 0) AND ("response_likelihood" <= 100))),
    CONSTRAINT "contact_intelligence_scores_strategic_value_score_check" CHECK ((("strategic_value_score" >= 0) AND ("strategic_value_score" <= 100))),
    CONSTRAINT "contact_intelligence_scores_timing_score_check" CHECK ((("timing_score" >= 0) AND ("timing_score" <= 100)))
);


ALTER TABLE "public"."contact_intelligence_scores" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."contact_interactions" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "contact_id" "uuid" NOT NULL,
    "interaction_type" "text" NOT NULL,
    "interaction_date" timestamp with time zone DEFAULT "now"(),
    "subject" "text",
    "description" "text",
    "outcome" "text",
    "sentiment" "text",
    "follow_up_required" boolean DEFAULT false,
    "follow_up_date" timestamp with time zone,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "contact_interactions_interaction_type_check" CHECK (("interaction_type" = ANY (ARRAY['email'::"text", 'meeting'::"text", 'call'::"text", 'linkedin'::"text", 'other'::"text"]))),
    CONSTRAINT "contact_interactions_sentiment_check" CHECK (("sentiment" = ANY (ARRAY['positive'::"text", 'neutral'::"text", 'negative'::"text"])))
);


ALTER TABLE "public"."contact_interactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."contact_invites" (
    "id" bigint NOT NULL,
    "contact_id" bigint NOT NULL,
    "opportunity_id" bigint NOT NULL,
    "invited_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "status" "text" DEFAULT 'sent'::"text" NOT NULL,
    "response_date" timestamp with time zone,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "contact_invites_status_check" CHECK (("status" = ANY (ARRAY['sent'::"text", 'responded'::"text", 'declined'::"text", 'accepted'::"text", 'no_response'::"text"])))
);


ALTER TABLE "public"."contact_invites" OWNER TO "postgres";


COMMENT ON TABLE "public"."contact_invites" IS 'History of contact invitations for opportunities';



CREATE SEQUENCE IF NOT EXISTS "public"."contact_invites_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."contact_invites_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."contact_invites_id_seq" OWNED BY "public"."contact_invites"."id";



CREATE TABLE IF NOT EXISTS "public"."contact_project_links" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "entity_id" "uuid",
    "project_code" "text" NOT NULL,
    "source" "text" DEFAULT 'ghl'::"text",
    "confidence" numeric DEFAULT 1.0,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."contact_project_links" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."contact_review_decisions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "email" "text" NOT NULL,
    "normalized_email" "text" GENERATED ALWAYS AS ("lower"(TRIM(BOTH FROM "email"))) STORED,
    "name" "text",
    "domain" "text",
    "decision" "text" DEFAULT 'pending'::"text" NOT NULL,
    "suggested_tags" "text"[] DEFAULT '{}'::"text"[],
    "approved_tags" "text"[] DEFAULT '{}'::"text"[],
    "source_context" "jsonb" DEFAULT '{}'::"jsonb",
    "ghl_contact_id" "text",
    "reviewed_at" timestamp with time zone,
    "reviewed_by" "text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."contact_review_decisions" OWNER TO "postgres";


COMMENT ON TABLE "public"."contact_review_decisions" IS 'Review-first workflow for importing email contacts to GHL';



CREATE TABLE IF NOT EXISTS "public"."contact_support_preferences" (
    "contact_id" "text" NOT NULL,
    "project_id" "text" NOT NULL,
    "status" "text" NOT NULL,
    "notes" "text",
    "pinned_rank" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "contact_support_preferences_status_check" CHECK (("status" = ANY (ARRAY['pinned'::"text", 'ignored'::"text"])))
);


ALTER TABLE "public"."contact_support_preferences" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."contact_support_recommendations" (
    "contact_id" "text" NOT NULL,
    "recommendations" "jsonb" DEFAULT '[]'::"jsonb",
    "pinned_count" integer DEFAULT 0,
    "total_recommendations" integer DEFAULT 0,
    "last_generated" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."contact_support_recommendations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."content_link_suggestions" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "source_type" "text" NOT NULL,
    "source_id" "uuid" NOT NULL,
    "target_type" "text" NOT NULL,
    "target_id" "uuid" NOT NULL,
    "suggested_role" "text",
    "confidence" numeric(3,2),
    "reasoning" "text" NOT NULL,
    "evidence" "jsonb" DEFAULT '{}'::"jsonb",
    "status" "text" DEFAULT 'pending'::"text",
    "reviewed_by" "uuid",
    "reviewed_at" timestamp without time zone,
    "auto_applied" boolean DEFAULT false,
    "applied_at" timestamp without time zone,
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"(),
    CONSTRAINT "content_link_suggestions_confidence_check" CHECK ((("confidence" >= (0)::numeric) AND ("confidence" <= (1)::numeric))),
    CONSTRAINT "content_link_suggestions_source_type_check" CHECK (("source_type" = ANY (ARRAY['profile'::"text", 'organization'::"text", 'program'::"text", 'service'::"text", 'story'::"text"]))),
    CONSTRAINT "content_link_suggestions_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text", 'auto-applied'::"text"]))),
    CONSTRAINT "content_link_suggestions_target_type_check" CHECK (("target_type" = ANY (ARRAY['profile'::"text", 'organization'::"text", 'program'::"text", 'service'::"text", 'story'::"text"])))
);


ALTER TABLE "public"."content_link_suggestions" OWNER TO "postgres";


COMMENT ON TABLE "public"."content_link_suggestions" IS 'Suggested links between content with confidence scores for auto-linking';



COMMENT ON COLUMN "public"."content_link_suggestions"."confidence" IS 'Confidence score 0.00-1.00. â‰¥0.90 = auto-apply, 0.60-0.89 = review, <0.60 = related content';



CREATE TABLE IF NOT EXISTS "public"."conversation_context" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "session_id" "text" NOT NULL,
    "user_id" "text",
    "interface" "text" NOT NULL,
    "site" "text" DEFAULT 'act-farm'::"text",
    "history" "jsonb" DEFAULT '[]'::"jsonb",
    "intent_detected" "text",
    "entities_mentioned" "jsonb" DEFAULT '[]'::"jsonb",
    "context_summary" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "expires_at" timestamp with time zone DEFAULT ("now"() + '7 days'::interval),
    CONSTRAINT "conversation_context_interface_check" CHECK (("interface" = ANY (ARRAY['chatbot'::"text", 'voice'::"text", 'claude_code'::"text", 'notion_ai'::"text"])))
);


ALTER TABLE "public"."conversation_context" OWNER TO "postgres";


COMMENT ON TABLE "public"."conversation_context" IS 'Chatbot and voice assistant session memory with 7-day expiry';



CREATE OR REPLACE VIEW "public"."coordinating_tasks" AS
 SELECT "id",
    "agent_id" AS "parent_agent",
    "title",
    "coordination_status",
    "array_length"("child_proposal_ids", 1) AS "child_count",
    ( SELECT "count"(*) AS "count"
           FROM "public"."agent_proposals" "c"
          WHERE (("c"."parent_proposal_id" = "p"."id") AND ("c"."status" = 'completed'::"text"))) AS "completed_children",
    ( SELECT "count"(*) AS "count"
           FROM "public"."agent_proposals" "c"
          WHERE (("c"."parent_proposal_id" = "p"."id") AND ("c"."status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'executing'::"text"])))) AS "pending_children",
    "created_at"
   FROM "public"."agent_proposals" "p"
  WHERE ("coordination_status" = ANY (ARRAY['coordinating'::"text", 'waiting'::"text"]))
  ORDER BY "created_at" DESC;


ALTER VIEW "public"."coordinating_tasks" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."cultural_liaisons" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "email" "text" NOT NULL,
    "phone" "text",
    "communities" "text"[] NOT NULL,
    "regions" "text"[],
    "review_types" "text"[] DEFAULT ARRAY['voice_note'::"text", 'story'::"text", 'project_knowledge'::"text"],
    "max_weekly_reviews" integer DEFAULT 10,
    "preferred_notification_channel" "text" DEFAULT 'email'::"text",
    "is_active" boolean DEFAULT true,
    "last_assigned_at" timestamp with time zone,
    "reviews_this_week" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."cultural_liaisons" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."cultural_protocols" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ghl_contact_id" "text",
    "empathy_ledger_user_id" "uuid",
    "cultural_nation" "text",
    "elder_status" boolean DEFAULT false,
    "elder_consent" "jsonb",
    "sacred_knowledge_notes" "text",
    "requires_elder_review" boolean DEFAULT false,
    "elder_reviewer_id" "uuid",
    "review_status" "text",
    "review_notes" "text",
    "reviewed_at" timestamp with time zone,
    "ocap_ownership" "text",
    "ocap_control" "text",
    "ocap_access" "text",
    "ocap_possession" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "entity_type" "text",
    "entity_id" "text",
    "sensitivity_level" "text" DEFAULT 'standard'::"text",
    "permitted_uses" "text"[] DEFAULT ARRAY['internal'::"text"],
    "restrictions" "text"[],
    "requires_attribution" boolean DEFAULT false,
    "attribution_text" "text",
    "consent_given_by" "text",
    "consent_date" "date",
    "consent_expires" "date",
    "consent_notes" "text",
    "cultural_liaison_id" "text",
    "community_of_origin" "text",
    "created_by" "text"
);


ALTER TABLE "public"."cultural_protocols" OWNER TO "postgres";


COMMENT ON TABLE "public"."cultural_protocols" IS 'Cultural protocol data - NEVER syncs to GHL, Supabase only';



COMMENT ON COLUMN "public"."cultural_protocols"."elder_consent" IS 'Detailed consent records - NEVER syncs to GHL';



COMMENT ON COLUMN "public"."cultural_protocols"."sacred_knowledge_notes" IS 'Private notes - NEVER shared outside Supabase';



COMMENT ON COLUMN "public"."cultural_protocols"."entity_type" IS 'Type of entity this protocol applies to: contact, story, voice_note, project';



COMMENT ON COLUMN "public"."cultural_protocols"."sensitivity_level" IS 'Sensitivity level: standard, sensitive, sacred, restricted';



CREATE TABLE IF NOT EXISTS "public"."cultural_review_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "item_type" "text" NOT NULL,
    "item_id" "uuid" NOT NULL,
    "item_title" "text",
    "nation_community" "text",
    "region" "text",
    "sensitivity_level" "text" DEFAULT 'standard'::"text",
    "review_reason" "text" NOT NULL,
    "flagged_keywords" "text"[],
    "content_preview" "text",
    "assigned_to" "text",
    "assigned_at" timestamp with time zone,
    "status" "text" DEFAULT 'pending'::"text",
    "priority" "text" DEFAULT 'normal'::"text",
    "reviewer_notes" "text",
    "review_decision" "text",
    "restrictions_applied" "text"[],
    "reviewed_at" timestamp with time zone,
    "reviewed_by" "text",
    "requires_followup" boolean DEFAULT false,
    "followup_date" "date",
    "followup_notes" "text",
    "cultural_protocol_id" "uuid",
    "notification_sent" boolean DEFAULT false,
    "notification_sent_at" timestamp with time zone,
    "notification_channel" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."cultural_review_queue" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."knowledge_versions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "knowledge_id" "text" NOT NULL,
    "version" integer NOT NULL,
    "content" "text" NOT NULL,
    "content_type" "text" NOT NULL,
    "changed_from" "text",
    "reason_for_change" "text" NOT NULL,
    "changed_by" "uuid",
    "approved_by" "uuid",
    "status" "text" DEFAULT 'draft'::"text",
    "active_from" timestamp with time zone,
    "active_until" timestamp with time zone,
    "tags" "text"[],
    "projects" "text"[],
    "domains" "text"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "knowledge_versions_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'active'::"text", 'archived'::"text", 'deprecated'::"text"])))
);


ALTER TABLE "public"."knowledge_versions" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."current_knowledge" AS
 SELECT "knowledge_id",
    "version",
    "content",
    "content_type",
    "tags",
    "projects",
    "active_from",
    "changed_by",
    "reason_for_change"
   FROM "public"."knowledge_versions" "kv"
  WHERE (("status" = 'active'::"text") AND ("active_from" <= "now"()) AND (("active_until" IS NULL) OR ("active_until" > "now"())))
  ORDER BY "knowledge_id", "version" DESC;


ALTER VIEW "public"."current_knowledge" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."data_quality_audit" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "table_name" "text" NOT NULL,
    "record_id" "uuid" NOT NULL,
    "quality_check_type" "text" DEFAULT 'validation'::"text" NOT NULL,
    "quality_score_before" numeric(5,2) DEFAULT 0,
    "quality_score_after" numeric(5,2) DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE "public"."data_quality_audit" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."data_quality_metrics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "table_name" "text" NOT NULL,
    "total_records" integer DEFAULT 0 NOT NULL,
    "complete_records" integer DEFAULT 0 NOT NULL,
    "incomplete_records" integer DEFAULT 0 NOT NULL,
    "duplicate_records" integer DEFAULT 0 NOT NULL,
    "invalid_records" integer DEFAULT 0 NOT NULL,
    "field_completeness" "jsonb" DEFAULT '{}'::"jsonb",
    "data_freshness_score" numeric DEFAULT 0,
    "accuracy_score" numeric DEFAULT 0,
    "consistency_score" numeric DEFAULT 0,
    "quality_score" numeric DEFAULT 0,
    "quality_threshold_met" boolean DEFAULT false,
    "quality_issues" "jsonb" DEFAULT '[]'::"jsonb",
    "analysis_date" "date" NOT NULL,
    "analysis_run_id" "uuid" DEFAULT "gen_random_uuid"(),
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."data_quality_metrics" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."data_sources" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "name" character varying(255) NOT NULL,
    "type" character varying(50) NOT NULL,
    "base_url" "text" NOT NULL,
    "api_endpoint" "text",
    "scraping_config" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "discovery_patterns" "jsonb" DEFAULT '[]'::"jsonb",
    "update_frequency" character varying(20) DEFAULT 'weekly'::character varying,
    "reliability_score" numeric(3,2) DEFAULT 0.5,
    "last_successful_scrape" timestamp with time zone,
    "last_error_message" "text",
    "active" boolean DEFAULT true,
    "rate_limit_ms" integer DEFAULT 1000,
    "max_concurrent_requests" integer DEFAULT 1,
    "respect_robots_txt" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    "updated_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE "public"."data_sources" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."decision_outcomes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "decision_id" "uuid" NOT NULL,
    "outcome_rating" integer NOT NULL,
    "actual_impact" numeric,
    "success_metrics" "jsonb" DEFAULT '{}'::"jsonb",
    "lessons_learned" "text",
    "recorded_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "decision_outcomes_outcome_rating_check" CHECK ((("outcome_rating" >= 1) AND ("outcome_rating" <= 5)))
);


ALTER TABLE "public"."decision_outcomes" OWNER TO "postgres";


COMMENT ON TABLE "public"."decision_outcomes" IS 'Decision outcomes for continuous learning and improvement';



CREATE TABLE IF NOT EXISTS "public"."decisions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" "text" NOT NULL,
    "description" "text" NOT NULL,
    "context" "jsonb" DEFAULT '{}'::"jsonb",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "priority" "text" DEFAULT 'medium'::"text" NOT NULL,
    "category" "text" DEFAULT 'general'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "due_date" timestamp with time zone,
    "financial_impact" numeric,
    "confidence_score" numeric DEFAULT 0.75,
    "ai_recommendation" "text",
    "decision_made" "text",
    "outcome_rating" integer,
    "lessons_learned" "text",
    "related_decisions" "text"[] DEFAULT '{}'::"text"[],
    "skill_pods_consulted" "text"[] DEFAULT '{}'::"text"[],
    "data_sources" "text"[] DEFAULT '{}'::"text"[],
    CONSTRAINT "decisions_confidence_score_check" CHECK ((("confidence_score" >= (0)::numeric) AND ("confidence_score" <= (1)::numeric))),
    CONSTRAINT "decisions_outcome_rating_check" CHECK ((("outcome_rating" >= 1) AND ("outcome_rating" <= 5))),
    CONSTRAINT "decisions_priority_check" CHECK (("priority" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text", 'urgent'::"text"]))),
    CONSTRAINT "decisions_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'in_progress'::"text", 'completed'::"text", 'deferred'::"text"])))
);


ALTER TABLE "public"."decisions" OWNER TO "postgres";


COMMENT ON TABLE "public"."decisions" IS 'Real-time business decisions with AI analysis and tracking';



CREATE OR REPLACE VIEW "public"."decision_analytics" AS
 SELECT "d"."category",
    "d"."priority",
    "d"."status",
    "count"(*) AS "decision_count",
    "avg"("d"."confidence_score") AS "avg_confidence",
    "avg"("o"."outcome_rating") AS "avg_outcome_rating",
    "count"("o"."id") AS "completed_with_outcomes"
   FROM ("public"."decisions" "d"
     LEFT JOIN "public"."decision_outcomes" "o" ON (("d"."id" = "o"."decision_id")))
  GROUP BY "d"."category", "d"."priority", "d"."status";


ALTER VIEW "public"."decision_analytics" OWNER TO "postgres";


COMMENT ON VIEW "public"."decision_analytics" IS 'Analytics view for decision intelligence reporting';



CREATE TABLE IF NOT EXISTS "public"."decision_patterns" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "pattern_name" "text" NOT NULL,
    "pattern_description" "text",
    "decision_type" "text" NOT NULL,
    "input_pattern" "jsonb",
    "typical_reasoning" "text",
    "expected_outcome" "jsonb",
    "occurrence_count" integer DEFAULT 0,
    "success_rate" numeric(5,2),
    "avg_confidence" numeric(3,2),
    "example_decision_ids" "uuid"[],
    "first_seen" timestamp with time zone DEFAULT "now"(),
    "last_seen" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."decision_patterns" OWNER TO "postgres";


COMMENT ON TABLE "public"."decision_patterns" IS 'Common decision patterns for analysis and improvement';



CREATE TABLE IF NOT EXISTS "public"."decision_traces" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "timestamp" timestamp with time zone DEFAULT "now"(),
    "decision_type" "text" NOT NULL,
    "agent_id" "text" NOT NULL,
    "input_context" "jsonb" NOT NULL,
    "input_hash" "text",
    "retrieved_context" "jsonb",
    "retrieval_query" "text",
    "retrieval_count" integer,
    "retrieval_scores" numeric(3,2)[],
    "reasoning" "text",
    "reasoning_model" "text",
    "reasoning_tokens" integer,
    "decision" "jsonb" NOT NULL,
    "decision_summary" "text",
    "alternatives_considered" "jsonb",
    "confidence" numeric(3,2),
    "outcome_status" "text" DEFAULT 'pending'::"text",
    "outcome_notes" "text",
    "outcome_recorded_at" timestamp with time zone,
    "human_feedback" "text",
    "feedback_notes" "text",
    "feedback_by" "text",
    "feedback_at" timestamp with time zone,
    "used_for_training" boolean DEFAULT false,
    "training_weight" numeric(3,2),
    "parent_decision_id" "uuid",
    "audit_log_id" "uuid",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."decision_traces" OWNER TO "postgres";


COMMENT ON TABLE "public"."decision_traces" IS 'Audit trail of agent decisions with reasoning for explainability';



COMMENT ON COLUMN "public"."decision_traces"."reasoning" IS 'Natural language explanation of why this decision was made';



COMMENT ON COLUMN "public"."decision_traces"."confidence" IS 'Agent-reported confidence in decision (0.0 to 1.0)';



COMMENT ON COLUMN "public"."decision_traces"."human_feedback" IS 'Human evaluation: correct, incorrect, needs_improvement';



CREATE OR REPLACE VIEW "public"."delegated_tasks" AS
 SELECT "p"."id",
    "p"."target_agent_id" AS "for_agent",
    "p"."agent_id" AS "from_agent",
    "p"."action_name",
    "p"."title",
    "p"."proposed_action" AS "params",
    "p"."coordination_context" AS "context",
    "parent"."title" AS "parent_task",
    "p"."created_at"
   FROM ("public"."agent_proposals" "p"
     LEFT JOIN "public"."agent_proposals" "parent" ON (("p"."parent_proposal_id" = "parent"."id")))
  WHERE (("p"."parent_proposal_id" IS NOT NULL) AND ("p"."status" = 'pending'::"text"))
  ORDER BY "p"."created_at";


ALTER VIEW "public"."delegated_tasks" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."discovered_subscriptions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "tenant_id" "text" NOT NULL,
    "vendor" "text" NOT NULL,
    "amount" numeric(10,2),
    "currency" "text" DEFAULT 'AUD'::"text",
    "frequency" "text",
    "status" "text" DEFAULT 'active'::"text",
    "cancel_reason" "text",
    "notes" "text",
    "confidence" numeric(3,2),
    "signals" "jsonb",
    "gmail_message_id" "text",
    "xero_contact_id" "text",
    "notion_page_id" "text",
    "first_detected" timestamp with time zone DEFAULT "now"(),
    "last_scanned" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "account_email" "text",
    "annual_cost_cached" numeric(10,2),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "migration_status" "text" DEFAULT 'not_started'::"text",
    "migration_priority" integer DEFAULT 0,
    "vendor_contact_email" "text",
    "vendor_contact_source" "text",
    "contacted_at" timestamp with time zone,
    "confirmed_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "migration_notes" "text",
    CONSTRAINT "discovered_subscriptions_confidence_check" CHECK ((("confidence" >= (0)::numeric) AND ("confidence" <= (1)::numeric))),
    CONSTRAINT "discovered_subscriptions_frequency_check" CHECK (("frequency" = ANY (ARRAY['monthly'::"text", 'yearly'::"text", 'quarterly'::"text", 'irregular'::"text", 'unknown'::"text"]))),
    CONSTRAINT "discovered_subscriptions_migration_priority_check" CHECK ((("migration_priority" >= 0) AND ("migration_priority" <= 100))),
    CONSTRAINT "discovered_subscriptions_migration_status_check" CHECK (("migration_status" = ANY (ARRAY['not_started'::"text", 'pending_contact'::"text", 'contacted'::"text", 'vendor_confirmed'::"text", 'completed'::"text", 'skipped'::"text"]))),
    CONSTRAINT "discovered_subscriptions_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'canceled'::"text", 'paused'::"text", 'pending_review'::"text"]))),
    CONSTRAINT "discovered_subscriptions_vendor_contact_source_check" CHECK (("vendor_contact_source" = ANY (ARRAY['gmail_from'::"text", 'xero_contact'::"text", 'web_scrape'::"text", 'manual'::"text"])))
);


ALTER TABLE "public"."discovered_subscriptions" OWNER TO "postgres";


COMMENT ON COLUMN "public"."discovered_subscriptions"."account_email" IS 'Which @act.place email account discovered this subscription (multi-account scanning)';



COMMENT ON COLUMN "public"."discovered_subscriptions"."annual_cost_cached" IS 'Cached annual cost estimate for quick analytics queries';



COMMENT ON COLUMN "public"."discovered_subscriptions"."migration_status" IS 'Current state in migration workflow';



COMMENT ON COLUMN "public"."discovered_subscriptions"."migration_priority" IS 'Priority score (0-100) based on amount, recency, confidence';



COMMENT ON COLUMN "public"."discovered_subscriptions"."vendor_contact_email" IS 'Discovered vendor billing email';



COMMENT ON COLUMN "public"."discovered_subscriptions"."vendor_contact_source" IS 'Source of vendor email (gmail_from, xero_contact, manual)';



CREATE TABLE IF NOT EXISTS "public"."donations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ghl_contact_id" "text",
    "amount" numeric(12,2) NOT NULL,
    "currency" "text" DEFAULT 'AUD'::"text",
    "donation_date" timestamp with time zone NOT NULL,
    "donation_method" "text",
    "frequency" "text" DEFAULT 'one_time'::"text",
    "project" "text",
    "stripe_payment_id" "text",
    "stripe_customer_id" "text",
    "receipt_sent" boolean DEFAULT false,
    "receipt_sent_at" timestamp with time zone,
    "synced_to_ghl" boolean DEFAULT false,
    "ghl_opportunity_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."donations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ecosystem_projects" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "slug" "text" NOT NULL,
    "name" "text" NOT NULL,
    "tier" integer NOT NULL,
    "url" "text" NOT NULL,
    "description" "text",
    "purpose" "text",
    "tech_stack" "text"[] DEFAULT '{}'::"text"[],
    "git_repo" "text",
    "key_contacts" "uuid"[] DEFAULT '{}'::"uuid"[],
    "data_sources" "text"[] DEFAULT '{}'::"text"[],
    "health_status" "text" DEFAULT 'unknown'::"text",
    "last_health_check" timestamp with time zone,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "ecosystem_projects_health_status_check" CHECK (("health_status" = ANY (ARRAY['unknown'::"text", 'healthy'::"text", 'degraded'::"text", 'down'::"text"]))),
    CONSTRAINT "ecosystem_projects_tier_check" CHECK (("tier" = ANY (ARRAY[1, 2, 3])))
);


ALTER TABLE "public"."ecosystem_projects" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ecosystem_sites" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "url" "text" NOT NULL,
    "description" "text",
    "category" "text",
    "status" "text" DEFAULT 'unknown'::"text",
    "last_check_at" timestamp with time zone,
    "response_time_ms" integer,
    "icon_url" "text",
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "vercel_project_id" "text",
    "vercel_project_name" "text",
    "github_repo" "text",
    "health_score" integer DEFAULT 0,
    "health_trend" "text" DEFAULT 'stable'::"text",
    "last_deployment_at" timestamp with time zone,
    "ssl_expires_at" timestamp with time zone
);


ALTER TABLE "public"."ecosystem_sites" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."elder_review_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "verification_id" "uuid",
    "content_type" "text" NOT NULL,
    "content" "text" NOT NULL,
    "project_slug" "text",
    "status" "text" DEFAULT 'pending'::"text",
    "assigned_to" "uuid",
    "assigned_at" timestamp with time zone,
    "cultural_topics" "text"[],
    "communities_involved" "text"[],
    "sensitivity_level" "text",
    "reviewed_by" "uuid",
    "reviewed_at" timestamp with time zone,
    "review_notes" "text",
    "suggested_changes" "text",
    "submitted_by" "uuid",
    "submitted_at" timestamp with time zone DEFAULT "now"(),
    "priority" integer DEFAULT 3,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "elder_review_queue_priority_check" CHECK ((("priority" >= 1) AND ("priority" <= 5))),
    CONSTRAINT "elder_review_queue_sensitivity_level_check" CHECK (("sensitivity_level" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text", 'sacred'::"text"]))),
    CONSTRAINT "elder_review_queue_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'in_review'::"text", 'approved'::"text", 'rejected'::"text", 'needs_revision'::"text"])))
);


ALTER TABLE "public"."elder_review_queue" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."entity_identifiers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "entity_id" "uuid" NOT NULL,
    "identifier_type" "text" NOT NULL,
    "identifier_value" "text" NOT NULL,
    "normalized_value" "text",
    "source" "text" NOT NULL,
    "source_record_id" "text",
    "source_confidence" numeric(3,2) DEFAULT 1.00,
    "is_primary" boolean DEFAULT false,
    "is_verified" boolean DEFAULT false,
    "verified_at" timestamp with time zone,
    "last_seen_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."entity_identifiers" OWNER TO "postgres";


COMMENT ON TABLE "public"."entity_identifiers" IS 'All known identifiers (emails, phones, IDs) for each entity';



CREATE OR REPLACE VIEW "public"."enrichment_ready_contacts" AS
 SELECT "id" AS "entity_id",
    "canonical_name" AS "name",
    "canonical_email" AS "email",
    "canonical_company" AS "company",
    "canonical_phone" AS "phone",
    "tags",
    "projects",
    "engagement_status",
    ( SELECT "entity_identifiers"."identifier_value"
           FROM "public"."entity_identifiers"
          WHERE (("entity_identifiers"."entity_id" = "ce"."id") AND ("entity_identifiers"."identifier_type" = 'ghl_id'::"text"))
         LIMIT 1) AS "ghl_id",
    ( SELECT "entity_identifiers"."identifier_value"
           FROM "public"."entity_identifiers"
          WHERE (("entity_identifiers"."entity_id" = "ce"."id") AND ("entity_identifiers"."identifier_type" = 'linkedin_id'::"text"))
         LIMIT 1) AS "linkedin_id",
    ( SELECT "entity_identifiers"."identifier_value"
           FROM "public"."entity_identifiers"
          WHERE (("entity_identifiers"."entity_id" = "ce"."id") AND ("entity_identifiers"."identifier_type" = 'linkedin_url'::"text"))
         LIMIT 1) AS "linkedin_url",
    ( SELECT "array_agg"("contact_project_links"."project_code") AS "array_agg"
           FROM "public"."contact_project_links"
          WHERE ("contact_project_links"."entity_id" = "ce"."id")) AS "linked_projects",
        CASE
            WHEN ("canonical_email" IS NOT NULL) THEN true
            ELSE false
        END AS "has_email",
        CASE
            WHEN (EXISTS ( SELECT 1
               FROM "public"."entity_identifiers"
              WHERE (("entity_identifiers"."entity_id" = "ce"."id") AND ("entity_identifiers"."identifier_type" = 'linkedin_id'::"text")))) THEN true
            ELSE false
        END AS "has_linkedin",
        CASE
            WHEN (EXISTS ( SELECT 1
               FROM "public"."entity_identifiers"
              WHERE (("entity_identifiers"."entity_id" = "ce"."id") AND ("entity_identifiers"."identifier_type" = 'ghl_id'::"text")))) THEN true
            ELSE false
        END AS "has_ghl",
    ((((((
        CASE
            WHEN ("canonical_email" IS NOT NULL) THEN 25
            ELSE 0
        END +
        CASE
            WHEN ("canonical_phone" IS NOT NULL) THEN 15
            ELSE 0
        END) +
        CASE
            WHEN ("canonical_company" IS NOT NULL) THEN 15
            ELSE 0
        END) +
        CASE
            WHEN (EXISTS ( SELECT 1
               FROM "public"."entity_identifiers"
              WHERE (("entity_identifiers"."entity_id" = "ce"."id") AND ("entity_identifiers"."identifier_type" = 'linkedin_id'::"text")))) THEN 15
            ELSE 0
        END) +
        CASE
            WHEN (EXISTS ( SELECT 1
               FROM "public"."entity_identifiers"
              WHERE (("entity_identifiers"."entity_id" = "ce"."id") AND ("entity_identifiers"."identifier_type" = 'ghl_id'::"text")))) THEN 10
            ELSE 0
        END) +
        CASE
            WHEN (("tags" IS NOT NULL) AND ("array_length"("tags", 1) > 0)) THEN 10
            ELSE 0
        END) +
        CASE
            WHEN (EXISTS ( SELECT 1
               FROM "public"."contact_project_links"
              WHERE ("contact_project_links"."entity_id" = "ce"."id"))) THEN 10
            ELSE 0
        END) AS "data_quality_score",
    "enrichment_source",
    "enriched_at",
    "created_at",
    "updated_at"
   FROM "public"."canonical_entities" "ce"
  WHERE (("canonical_name" IS NOT NULL) AND (TRIM(BOTH FROM "canonical_name") <> ''::"text"))
  ORDER BY
        CASE
            WHEN ("canonical_email" IS NOT NULL) THEN 0
            ELSE 1
        END, "canonical_name";


ALTER VIEW "public"."enrichment_ready_contacts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."enrichment_reviews" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_slug" "text" NOT NULL,
    "project_title" "text",
    "enrichment_type" "text" NOT NULL,
    "ai_generated" "jsonb" NOT NULL,
    "original_data" "jsonb",
    "confidence" numeric(3,2),
    "reasoning" "text",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "reviewed_by" "uuid",
    "reviewed_at" timestamp with time zone,
    "reviewer_notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "enrichment_reviews_confidence_check" CHECK ((("confidence" >= (0)::numeric) AND ("confidence" <= (1)::numeric))),
    CONSTRAINT "enrichment_reviews_enrichment_type_check" CHECK (("enrichment_type" = ANY (ARRAY['notion'::"text", 'blog_links'::"text", 'related_projects'::"text", 'description'::"text", 'media_suggestions'::"text"]))),
    CONSTRAINT "enrichment_reviews_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text", 'needs_revision'::"text"])))
);


ALTER TABLE "public"."enrichment_reviews" OWNER TO "postgres";


COMMENT ON TABLE "public"."enrichment_reviews" IS 'Stores AI-generated content for human verification before going live';



CREATE TABLE IF NOT EXISTS "public"."entities" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "primary_email" "text",
    "first_name" "text",
    "last_name" "text",
    "display_name" "text",
    "company" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."entities" OWNER TO "postgres";


COMMENT ON TABLE "public"."entities" IS 'Canonical person records for entity resolution across systems';



CREATE TABLE IF NOT EXISTS "public"."entity_mappings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "entity_id" "uuid" NOT NULL,
    "source_system" "text" NOT NULL,
    "source_id" "text" NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "entity_mappings_source_system_check" CHECK (("source_system" = ANY (ARRAY['ghl'::"text", 'calendar'::"text", 'email'::"text", 'notion'::"text", 'xero'::"text", 'linkedin'::"text"])))
);


ALTER TABLE "public"."entity_mappings" OWNER TO "postgres";


COMMENT ON TABLE "public"."entity_mappings" IS 'Links canonical entities to source system IDs';



CREATE TABLE IF NOT EXISTS "public"."entity_merge_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "surviving_entity_id" "uuid" NOT NULL,
    "merged_entity_id" "uuid" NOT NULL,
    "merged_entity_snapshot" "jsonb" NOT NULL,
    "merge_reason" "text",
    "match_confidence" numeric(3,2),
    "match_details" "jsonb",
    "merged_by" "text",
    "reviewed" boolean DEFAULT false,
    "reviewed_by" "text",
    "reviewed_at" timestamp with time zone,
    "can_unmerge" boolean DEFAULT true,
    "unmerged" boolean DEFAULT false,
    "unmerged_at" timestamp with time zone,
    "merged_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."entity_merge_log" OWNER TO "postgres";


COMMENT ON TABLE "public"."entity_merge_log" IS 'Audit log of entity merge decisions with undo capability';



CREATE TABLE IF NOT EXISTS "public"."entity_potential_matches" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "entity_a_id" "uuid" NOT NULL,
    "entity_b_id" "uuid" NOT NULL,
    "match_score" numeric(3,2) NOT NULL,
    "match_reasons" "jsonb" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text",
    "reviewed_by" "text",
    "reviewed_at" timestamp with time zone,
    "review_notes" "text",
    "detected_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "entity_potential_matches_check" CHECK (("entity_a_id" < "entity_b_id"))
);


ALTER TABLE "public"."entity_potential_matches" OWNER TO "postgres";


COMMENT ON TABLE "public"."entity_potential_matches" IS 'Candidate duplicates detected by matching algorithms';



CREATE TABLE IF NOT EXISTS "public"."entity_relationships" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "entity_type" "text" NOT NULL,
    "entity_id" "text" NOT NULL,
    "related_entity_type" "text" NOT NULL,
    "related_entity_id" "text" NOT NULL,
    "relationship_type" "text",
    "strength_score" double precision DEFAULT 0.5,
    "last_interaction" timestamp with time zone,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "entity_relationships_entity_type_check" CHECK (("entity_type" = ANY (ARRAY['contact'::"text", 'project'::"text", 'opportunity'::"text", 'issue'::"text", 'document'::"text", 'user'::"text"]))),
    CONSTRAINT "entity_relationships_related_entity_type_check" CHECK (("related_entity_type" = ANY (ARRAY['contact'::"text", 'project'::"text", 'opportunity'::"text", 'issue'::"text", 'document'::"text", 'user'::"text"]))),
    CONSTRAINT "entity_relationships_relationship_type_check" CHECK (("relationship_type" = ANY (ARRAY['works_on'::"text", 'knows'::"text", 'owns'::"text", 'related_to'::"text", 'depends_on'::"text", 'blocks'::"text", 'parent_of'::"text", 'child_of'::"text", 'partner'::"text", 'client'::"text", 'collaborator'::"text", 'community'::"text"]))),
    CONSTRAINT "entity_relationships_strength_score_check" CHECK ((("strength_score" >= (0)::double precision) AND ("strength_score" <= (1)::double precision)))
);


ALTER TABLE "public"."entity_relationships" OWNER TO "postgres";


COMMENT ON TABLE "public"."entity_relationships" IS 'Tracks relationships between entities (contacts, projects, etc.) with strength scoring';



CREATE TABLE IF NOT EXISTS "public"."event_registrations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "event_id" "uuid" NOT NULL,
    "email" "text" NOT NULL,
    "full_name" "text" NOT NULL,
    "organization" "text",
    "phone" "text",
    "dietary_requirements" "text",
    "accessibility_needs" "text",
    "plus_one" boolean DEFAULT false,
    "ghl_contact_id" "text",
    "registration_status" "text" DEFAULT 'registered'::"text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "event_registrations_registration_status_check" CHECK (("registration_status" = ANY (ARRAY['registered'::"text", 'confirmed'::"text", 'cancelled'::"text", 'attended'::"text", 'no_show'::"text"])))
);


ALTER TABLE "public"."event_registrations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" "text" NOT NULL,
    "slug" "text",
    "description" "text",
    "event_type" "text",
    "start_date" timestamp with time zone NOT NULL,
    "end_date" timestamp with time zone,
    "location_name" "text",
    "location_address" "text",
    "location_state" "text",
    "latitude" numeric(10,8),
    "longitude" numeric(11,8),
    "node_id" "uuid",
    "registration_url" "text",
    "ghl_event_id" "text",
    "max_attendees" integer,
    "current_attendees" integer DEFAULT 0,
    "is_public" boolean DEFAULT true,
    "is_featured" boolean DEFAULT false,
    "image_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "video_url" "text",
    "gallery_urls" "text"[],
    CONSTRAINT "events_event_type_check" CHECK (("event_type" = ANY (ARRAY['launch'::"text", 'workshop'::"text", 'conference'::"text", 'webinar'::"text", 'meeting'::"text", 'exhibition'::"text"])))
);


ALTER TABLE "public"."events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."events_old_backup" (
    "id" integer NOT NULL,
    "title" character varying(255) NOT NULL,
    "date" timestamp without time zone NOT NULL,
    "time" character varying(100) NOT NULL,
    "location" character varying(255) NOT NULL,
    "category" "public"."event_category" NOT NULL,
    "description" "text" NOT NULL,
    "contactEmail" character varying(320) NOT NULL,
    "status" "public"."event_status" DEFAULT 'pending'::"public"."event_status" NOT NULL,
    "submittedBy" character varying(255),
    "createdAt" timestamp without time zone DEFAULT "now"() NOT NULL,
    "updatedAt" timestamp without time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."events_old_backup" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."events_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."events_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."events_id_seq" OWNED BY "public"."events_old_backup"."id";



CREATE TABLE IF NOT EXISTS "public"."exa_api_usage" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "period_month" "date" NOT NULL,
    "total_requests" integer DEFAULT 0 NOT NULL,
    "successful_requests" integer DEFAULT 0 NOT NULL,
    "failed_requests" integer DEFAULT 0 NOT NULL,
    "free_tier_limit" integer DEFAULT 1000 NOT NULL,
    "free_tier_remaining" integer DEFAULT 1000 NOT NULL,
    "free_tier_exceeded" boolean DEFAULT false,
    "linkedin_requests" integer DEFAULT 0,
    "company_requests" integer DEFAULT 0,
    "media_requests" integer DEFAULT 0,
    "network_discovery_requests" integer DEFAULT 0,
    "estimated_cost_usd" numeric(10,2) DEFAULT 0.00,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."exa_api_usage" OWNER TO "postgres";


COMMENT ON TABLE "public"."exa_api_usage" IS 'Track Exa.ai API usage against free tier limits (1,000/month)';



COMMENT ON COLUMN "public"."exa_api_usage"."free_tier_remaining" IS 'Requests remaining in free tier (resets monthly)';



CREATE TABLE IF NOT EXISTS "public"."exa_company_intelligence" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "company_name" "text" NOT NULL,
    "industry" "text",
    "company_size" "text",
    "headquarters_location" "text",
    "founded_year" integer,
    "description" "text",
    "website" "text",
    "leadership" "jsonb" DEFAULT '[]'::"jsonb",
    "recent_news" "jsonb" DEFAULT '[]'::"jsonb",
    "funding_info" "jsonb",
    "twitter_handle" "text",
    "linkedin_company_url" "text",
    "exa_raw_data" "jsonb",
    "enriched_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "confidence_score" numeric(3,2),
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "exa_company_intelligence_confidence_score_check" CHECK ((("confidence_score" >= (0)::numeric) AND ("confidence_score" <= (1)::numeric)))
);


ALTER TABLE "public"."exa_company_intelligence" OWNER TO "postgres";


COMMENT ON TABLE "public"."exa_company_intelligence" IS 'Company/organization intelligence gathered via Exa.ai';



CREATE TABLE IF NOT EXISTS "public"."exa_enrichment_queue" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "person_id" "uuid" NOT NULL,
    "campaign_type" "text",
    "campaign_id" "uuid",
    "priority" integer DEFAULT 50 NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "retry_count" integer DEFAULT 0 NOT NULL,
    "error_message" "text",
    "enrich_linkedin" boolean DEFAULT true,
    "enrich_company" boolean DEFAULT true,
    "enrich_media" boolean DEFAULT true,
    "enrich_network" boolean DEFAULT false,
    "queued_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "exa_requests_used" integer DEFAULT 0,
    "estimated_cost_requests" integer DEFAULT 3,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "exa_enrichment_queue_campaign_type_check" CHECK (("campaign_type" = ANY (ARRAY['goods-on-country'::"text", 'justice-hub'::"text", 'general'::"text"]))),
    CONSTRAINT "exa_enrichment_queue_priority_check" CHECK ((("priority" >= 0) AND ("priority" <= 100))),
    CONSTRAINT "exa_enrichment_queue_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text", 'skipped'::"text"])))
);


ALTER TABLE "public"."exa_enrichment_queue" OWNER TO "postgres";


COMMENT ON TABLE "public"."exa_enrichment_queue" IS 'Queue for manual-triggered Exa enrichment (campaign-specific)';



COMMENT ON COLUMN "public"."exa_enrichment_queue"."campaign_type" IS 'goods-on-country or justice-hub - focuses enrichment on specific campaign needs';



COMMENT ON COLUMN "public"."exa_enrichment_queue"."estimated_cost_requests" IS 'Estimated Exa API requests needed (LinkedIn + Company + Media â‰ˆ 3 requests)';



CREATE TABLE IF NOT EXISTS "public"."exa_linkedin_profiles" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "person_id" "uuid" NOT NULL,
    "linkedin_url" "text",
    "headline" "text",
    "summary" "text",
    "current_position" "text",
    "current_company" "text",
    "location" "text",
    "experience" "jsonb" DEFAULT '[]'::"jsonb",
    "education" "jsonb" DEFAULT '[]'::"jsonb",
    "skills" "text"[] DEFAULT '{}'::"text"[],
    "exa_raw_data" "jsonb",
    "enriched_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "confidence_score" numeric(3,2),
    "source_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "exa_linkedin_profiles_confidence_score_check" CHECK ((("confidence_score" >= (0)::numeric) AND ("confidence_score" <= (1)::numeric)))
);


ALTER TABLE "public"."exa_linkedin_profiles" OWNER TO "postgres";


COMMENT ON TABLE "public"."exa_linkedin_profiles" IS 'LinkedIn profile data enriched via Exa.ai neural search';



CREATE TABLE IF NOT EXISTS "public"."exa_media_mentions" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "person_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "url" "text" NOT NULL,
    "published_date" timestamp with time zone,
    "source_domain" "text",
    "excerpt" "text",
    "full_text" "text",
    "mention_type" "text",
    "sentiment" "text",
    "relevance_score" numeric(3,2),
    "topics" "text"[] DEFAULT '{}'::"text"[],
    "discovered_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "exa_media_mentions_mention_type_check" CHECK (("mention_type" = ANY (ARRAY['article'::"text", 'interview'::"text", 'quote'::"text", 'mention'::"text", 'byline'::"text"]))),
    CONSTRAINT "exa_media_mentions_relevance_score_check" CHECK ((("relevance_score" >= (0)::numeric) AND ("relevance_score" <= (1)::numeric))),
    CONSTRAINT "exa_media_mentions_sentiment_check" CHECK (("sentiment" = ANY (ARRAY['positive'::"text", 'neutral'::"text", 'negative'::"text", 'mixed'::"text"])))
);


ALTER TABLE "public"."exa_media_mentions" OWNER TO "postgres";


COMMENT ON TABLE "public"."exa_media_mentions" IS 'Media mentions, articles, interviews found via Exa.ai';



CREATE TABLE IF NOT EXISTS "public"."facility_partnerships" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "facility_id" "uuid",
    "partner_type" "text" NOT NULL,
    "organization_id" "uuid",
    "program_id" "uuid",
    "service_id" "uuid",
    "partnership_type" "text" NOT NULL,
    "is_active" boolean DEFAULT true,
    "start_date" "date",
    "end_date" "date",
    "participants_served" integer,
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "facility_partnerships_partner_type_check" CHECK (("partner_type" = ANY (ARRAY['organization'::"text", 'community_program'::"text", 'service'::"text"]))),
    CONSTRAINT "facility_partnerships_partnership_type_check" CHECK (("partnership_type" = ANY (ARRAY['in_facility_program'::"text", 'post_release_support'::"text", 'bail_support'::"text", 'family_connection'::"text", 'education_provider'::"text", 'health_provider'::"text", 'legal_support'::"text", 'cultural_program'::"text", 'mentoring'::"text", 'housing_support'::"text", 'employment_support'::"text", 'advocacy'::"text", 'other'::"text"]))),
    CONSTRAINT "valid_partner" CHECK (((((("organization_id" IS NOT NULL))::integer + (("program_id" IS NOT NULL))::integer) + (("service_id" IS NOT NULL))::integer) = 1))
);


ALTER TABLE "public"."facility_partnerships" OWNER TO "postgres";


COMMENT ON TABLE "public"."facility_partnerships" IS 'Links between detention facilities and community organizations/programs/services';



CREATE TABLE IF NOT EXISTS "public"."facility_statistics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "facility_id" "uuid",
    "period_start" "date" NOT NULL,
    "period_end" "date" NOT NULL,
    "reporting_period" "text",
    "average_daily_population" integer,
    "peak_population" integer,
    "total_admissions" integer,
    "total_releases" integer,
    "indigenous_percentage" numeric(5,2),
    "female_percentage" numeric(5,2),
    "remand_percentage" numeric(5,2),
    "age_10_13_count" integer,
    "age_14_15_count" integer,
    "age_16_17_count" integer,
    "incidents_count" integer,
    "assaults_count" integer,
    "self_harm_count" integer,
    "escapes_count" integer,
    "education_participation_percentage" numeric(5,2),
    "program_completion_count" integer,
    "data_source" "text",
    "source_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."facility_statistics" OWNER TO "postgres";


COMMENT ON TABLE "public"."facility_statistics" IS 'Time-series statistics for each facility (population, demographics, incidents)';



CREATE TABLE IF NOT EXISTS "public"."fellows" (
    "id" integer NOT NULL,
    "full_name" "text" NOT NULL,
    "role_title" "text",
    "fellow_status" "text" DEFAULT 'active'::"text",
    "areas_of_expertise" "text"[],
    "created_at" timestamp without time zone DEFAULT "now"(),
    "additional_data" "jsonb",
    "organization" "text",
    "bio" "text",
    "city" "text",
    "state" "text",
    "country" "text" DEFAULT 'Australia'::"text",
    "linkedin_url" "text",
    "website_url" "text",
    "cohort_year" integer,
    "email" "text",
    "fellowship_goals" "jsonb",
    "impact_areas" "text"[]
);


ALTER TABLE "public"."fellows" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."fellows_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."fellows_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."fellows_id_seq" OWNED BY "public"."fellows"."id";



CREATE OR REPLACE VIEW "public"."financial_by_account" AS
 SELECT "account_email",
    "document_type",
    "count"(*) AS "document_count",
    "sum"("amount") AS "total_amount",
    "avg"("confidence") AS "avg_confidence",
    "sum"(
        CASE
            WHEN ("reconciliation_status" = 'auto_matched'::"text") THEN 1
            ELSE 0
        END) AS "auto_matched_count"
   FROM "public"."email_financial_documents"
  GROUP BY "account_email", "document_type";


ALTER VIEW "public"."financial_by_account" OWNER TO "postgres";


COMMENT ON VIEW "public"."financial_by_account" IS 'Aggregated financial metrics grouped by account email and document type.';



CREATE OR REPLACE VIEW "public"."financial_monthly_summary" AS
 SELECT "date_trunc"('month'::"text", ("transaction_date")::timestamp with time zone) AS "month",
    "account_email",
    "document_type",
    "count"(*) AS "transaction_count",
    "sum"("amount") AS "total_amount",
    "avg"("confidence") AS "avg_confidence"
   FROM "public"."email_financial_documents"
  WHERE ("transaction_date" IS NOT NULL)
  GROUP BY ("date_trunc"('month'::"text", ("transaction_date")::timestamp with time zone)), "account_email", "document_type"
  ORDER BY ("date_trunc"('month'::"text", ("transaction_date")::timestamp with time zone)) DESC, "account_email", "document_type";


ALTER VIEW "public"."financial_monthly_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."financial_project_summaries" (
    "project_id" "uuid" NOT NULL,
    "notion_project_id" "text",
    "project_name" "text",
    "total_actual" numeric DEFAULT 0,
    "total_potential" numeric DEFAULT 0,
    "runway_days" integer,
    "top_funders" "jsonb" DEFAULT '[]'::"jsonb",
    "concentration_risk" boolean DEFAULT false,
    "last_updated" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."financial_project_summaries" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."financial_summary" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "reported_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "total_revenue" numeric(14,2) DEFAULT 0 NOT NULL,
    "community_share" numeric(14,2) DEFAULT 0 NOT NULL,
    "community_percentage" numeric(5,2) DEFAULT 0 NOT NULL,
    "operating_expenses" numeric(14,2) DEFAULT 0 NOT NULL,
    "net_available_for_communities" numeric(14,2) DEFAULT 0 NOT NULL,
    "income" numeric(14,2) DEFAULT 0 NOT NULL,
    "expenses" numeric(14,2) DEFAULT 0 NOT NULL,
    "net_income" numeric(14,2) DEFAULT 0 NOT NULL,
    "transaction_count" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."financial_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ghl_contacts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ghl_id" "text" NOT NULL,
    "ghl_location_id" "text" NOT NULL,
    "first_name" "text",
    "last_name" "text",
    "full_name" "text" GENERATED ALWAYS AS (((COALESCE("first_name", ''::"text") || ' '::"text") || COALESCE("last_name", ''::"text"))) STORED,
    "email" "text",
    "phone" "text",
    "company_name" "text",
    "tags" "text"[] DEFAULT '{}'::"text"[],
    "custom_fields" "jsonb" DEFAULT '{}'::"jsonb",
    "projects" "text"[] DEFAULT '{}'::"text"[],
    "engagement_status" "text" DEFAULT 'lead'::"text",
    "first_contact_date" timestamp with time zone,
    "last_contact_date" timestamp with time zone,
    "ghl_created_at" timestamp with time zone,
    "ghl_updated_at" timestamp with time zone,
    "last_synced_at" timestamp with time zone DEFAULT "now"(),
    "sync_status" "text" DEFAULT 'pending'::"text",
    "sync_error" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "stories_count" integer DEFAULT 0,
    "published_stories" integer DEFAULT 0,
    "is_storyteller" boolean DEFAULT false,
    "is_elder" boolean DEFAULT false,
    "empathy_ledger_id" "uuid",
    "el_last_synced_at" timestamp with time zone
);


ALTER TABLE "public"."ghl_contacts" OWNER TO "postgres";


COMMENT ON TABLE "public"."ghl_contacts" IS 'GHL contacts synced bidirectionally - NO sensitive cultural data';



COMMENT ON COLUMN "public"."ghl_contacts"."stories_count" IS 'Total stories from Empathy Ledger v2';



COMMENT ON COLUMN "public"."ghl_contacts"."published_stories" IS 'Published stories from Empathy Ledger v2';



COMMENT ON COLUMN "public"."ghl_contacts"."is_storyteller" IS 'Contact is an Empathy Ledger storyteller';



COMMENT ON COLUMN "public"."ghl_contacts"."is_elder" IS 'Contact is designated as an Elder';



COMMENT ON COLUMN "public"."ghl_contacts"."empathy_ledger_id" IS 'UUID link to EL v2 storytellers table';



CREATE TABLE IF NOT EXISTS "public"."ghl_engagement_metrics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "contact_id" "uuid",
    "person_id" "uuid",
    "ghl_contact_id" "text",
    "pipeline_type" "text",
    "current_stage" "text",
    "act_energy_percent" integer,
    "last_engagement" timestamp with time zone,
    "engagement_count" integer DEFAULT 0,
    "obsolescence_achieved" boolean DEFAULT false,
    "trajectory_to_orbit" "text",
    "project_match_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "ghl_engagement_metrics_act_energy_percent_check" CHECK (("act_energy_percent" = ANY (ARRAY[100, 60, 20, 0]))),
    CONSTRAINT "ghl_engagement_metrics_check" CHECK ((("contact_id" IS NOT NULL) OR ("person_id" IS NOT NULL))),
    CONSTRAINT "ghl_engagement_metrics_pipeline_type_check" CHECK (("pipeline_type" = ANY (ARRAY['community'::"text", 'partnership'::"text", 'indigenous'::"text", 'alma_youth_justice'::"text"])))
);


ALTER TABLE "public"."ghl_engagement_metrics" OWNER TO "postgres";


COMMENT ON TABLE "public"."ghl_engagement_metrics" IS 'Tracks Beautiful Obsolescence progress via GoHighLevel pipelines.
act_energy_percent shows journey from 100% ACT support â†’ 0% (complete independence).
obsolescence_achieved = true when community no longer needs ACT (MISSION SUCCESS!).';



COMMENT ON COLUMN "public"."ghl_engagement_metrics"."act_energy_percent" IS 'Beautiful Obsolescence tracker (Rocket Booster Model):
100% = Ignition (fully ACT-supported)
 60% = Thrust (60% ACT / 40% community)
 20% = Trajectory (20% ACT / 80% community)
  0% = Orbit (100% community-owned, ACT obsolete)';



CREATE TABLE IF NOT EXISTS "public"."ghl_opportunities" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ghl_id" "text" NOT NULL,
    "ghl_contact_id" "text",
    "ghl_pipeline_id" "text" NOT NULL,
    "ghl_stage_id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "pipeline_name" "text",
    "stage_name" "text",
    "status" "text",
    "monetary_value" numeric(12,2),
    "custom_fields" "jsonb" DEFAULT '{}'::"jsonb",
    "assigned_to" "text",
    "ghl_created_at" timestamp with time zone,
    "ghl_updated_at" timestamp with time zone,
    "last_synced_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "project_code" "text",
    "xero_invoice_id" "text",
    "received_date" timestamp with time zone,
    "acquittal_due_date" timestamp with time zone,
    "acquittal_status" "text" DEFAULT 'pending'::"text"
);


ALTER TABLE "public"."ghl_opportunities" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ghl_pipelines" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ghl_id" "text" NOT NULL,
    "ghl_location_id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "stages" "jsonb" DEFAULT '[]'::"jsonb",
    "last_synced_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."ghl_pipelines" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ghl_sync_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "operation" "text" NOT NULL,
    "entity_type" "text" NOT NULL,
    "entity_id" "text",
    "direction" "text" NOT NULL,
    "status" "text" NOT NULL,
    "error_message" "text",
    "records_processed" integer DEFAULT 0,
    "records_created" integer DEFAULT 0,
    "records_updated" integer DEFAULT 0,
    "records_skipped" integer DEFAULT 0,
    "records_failed" integer DEFAULT 0,
    "started_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    "duration_ms" integer,
    "triggered_by" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."ghl_sync_log" OWNER TO "postgres";


COMMENT ON TABLE "public"."ghl_sync_log" IS 'Log of all GHL sync operations for debugging';



CREATE TABLE IF NOT EXISTS "public"."ghl_tags" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ghl_location_id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "category" "text",
    "color" "text",
    "last_synced_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."ghl_tags" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gmail_auth_tokens" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "user_email" "text" NOT NULL,
    "access_token" "text" NOT NULL,
    "refresh_token" "text",
    "expiry_date" bigint,
    "scope" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."gmail_auth_tokens" OWNER TO "postgres";


COMMENT ON TABLE "public"."gmail_auth_tokens" IS 'OAuth tokens for Gmail API access';



CREATE TABLE IF NOT EXISTS "public"."gmail_contacts" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "email" "text" NOT NULL,
    "name" "text",
    "domain" "text",
    "last_interaction" timestamp with time zone,
    "discovered_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."gmail_contacts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gmail_messages" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "gmail_id" "text" NOT NULL,
    "thread_id" "text" NOT NULL,
    "user_email" "text" NOT NULL,
    "subject" "text",
    "snippet" "text",
    "from_email" "text",
    "from_name" "text",
    "to_emails" "text"[],
    "cc_emails" "text"[],
    "bcc_emails" "text"[],
    "sent_date" timestamp with time zone,
    "received_date" timestamp with time zone,
    "body_text" "text",
    "body_html" "text",
    "labels" "text"[],
    "importance" "text" DEFAULT 'medium'::"text",
    "has_attachments" boolean DEFAULT false,
    "attachment_count" integer DEFAULT 0,
    "attachment_names" "text"[],
    "attachment_total_size" bigint DEFAULT 0,
    "keywords" "text"[],
    "is_read" boolean DEFAULT false,
    "is_starred" boolean DEFAULT false,
    "is_archived" boolean DEFAULT false,
    "is_trashed" boolean DEFAULT false,
    "is_spam" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "synced_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "gmail_messages_importance_check" CHECK (("importance" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text"])))
);


ALTER TABLE "public"."gmail_messages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gmail_sync_state" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "account_id" "uuid",
    "last_history_id" "text",
    "last_sync_at" timestamp with time zone,
    "next_sync_at" timestamp with time zone,
    "status" "text" DEFAULT 'pending'::"text",
    "items_found" integer DEFAULT 0,
    "items_extracted" integer DEFAULT 0,
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "gmail_sync_state_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'running'::"text", 'completed'::"text", 'error'::"text"])))
);


ALTER TABLE "public"."gmail_sync_state" OWNER TO "postgres";


COMMENT ON TABLE "public"."gmail_sync_state" IS 'Tracks Gmail sync state for incremental scanning';



CREATE TABLE IF NOT EXISTS "public"."knowledge_extraction_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "source_type" "text" NOT NULL,
    "source_id" "text" NOT NULL,
    "source_url" "text",
    "source_metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "raw_content" "text" NOT NULL,
    "raw_title" "text",
    "extracted_knowledge" "text",
    "suggested_title" "text",
    "suggested_type" "text",
    "suggested_excerpt" "text",
    "suggested_projects" "text"[],
    "suggested_domains" "text"[],
    "suggested_tags" "text"[],
    "suggested_parent_ids" "jsonb",
    "confidence_score" numeric(3,2),
    "status" "text" DEFAULT 'pending'::"text",
    "reviewed_by" "uuid",
    "reviewed_at" timestamp with time zone,
    "review_notes" "text",
    "wiki_page_id" "uuid",
    "extracted_at" timestamp with time zone DEFAULT "now"(),
    "extraction_model" "text" DEFAULT 'mistral-7b'::"text",
    "extraction_prompt" "text",
    "priority" integer DEFAULT 3,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "content_embedding" "public"."vector"(1536),
    "thread_id" "text",
    CONSTRAINT "knowledge_extraction_queue_confidence_score_check" CHECK ((("confidence_score" >= (0)::numeric) AND ("confidence_score" <= (1)::numeric))),
    CONSTRAINT "knowledge_extraction_queue_priority_check" CHECK ((("priority" >= 1) AND ("priority" <= 5))),
    CONSTRAINT "knowledge_extraction_queue_source_type_check" CHECK (("source_type" = ANY (ARRAY['notion'::"text", 'gmail'::"text", 'calendar'::"text", 'ghl'::"text", 'whatsapp'::"text", 'slack'::"text", 'drive'::"text"]))),
    CONSTRAINT "knowledge_extraction_queue_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'in_review'::"text", 'approved'::"text", 'rejected'::"text", 'merged'::"text"]))),
    CONSTRAINT "knowledge_extraction_queue_suggested_type_check" CHECK (("suggested_type" = ANY (ARRAY['principle'::"text", 'method'::"text", 'practice'::"text", 'procedure'::"text", 'guide'::"text", 'template'::"text"])))
);


ALTER TABLE "public"."knowledge_extraction_queue" OWNER TO "postgres";


COMMENT ON COLUMN "public"."knowledge_extraction_queue"."content_embedding" IS 'OpenAI text-embedding-3-small (1536 dimensions) - used for semantic similarity confidence scoring';



CREATE OR REPLACE VIEW "public"."gmail_sync_stats" AS
 SELECT "t"."user_email",
    "s"."last_sync_at",
    "s"."last_history_id",
    "s"."status",
    "s"."items_found" AS "last_scan_found",
    "s"."items_extracted" AS "last_scan_extracted",
    "count"("q"."id") AS "total_in_queue",
    "count"("q"."id") FILTER (WHERE ("q"."status" = 'pending'::"text")) AS "pending_review",
    "count"("q"."id") FILTER (WHERE ("q"."status" = 'approved'::"text")) AS "approved",
    "max"("q"."created_at") AS "latest_extraction"
   FROM (("public"."gmail_auth_tokens" "t"
     LEFT JOIN "public"."gmail_sync_state" "s" ON (("s"."account_id" = "t"."id")))
     LEFT JOIN "public"."knowledge_extraction_queue" "q" ON ((("q"."source_type" = 'gmail'::"text") AND (("q"."source_metadata" ->> 'account_id'::"text") = ("t"."id")::"text"))))
  GROUP BY "t"."id", "t"."user_email", "s"."last_sync_at", "s"."last_history_id", "s"."status", "s"."items_found", "s"."items_extracted";


ALTER VIEW "public"."gmail_sync_stats" OWNER TO "postgres";


COMMENT ON VIEW "public"."gmail_sync_stats" IS 'Statistics for Gmail knowledge extraction';



CREATE TABLE IF NOT EXISTS "public"."gmail_sync_status" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "user_email" "text" NOT NULL,
    "sync_status" "text" DEFAULT 'idle'::"text",
    "last_sync" timestamp with time zone,
    "next_sync" timestamp with time zone,
    "total_messages" integer DEFAULT 0,
    "synced_messages" integer DEFAULT 0,
    "error_count" integer DEFAULT 0,
    "error_message" "text",
    "last_error" timestamp with time zone,
    "sync_duration_ms" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "gmail_sync_status_sync_status_check" CHECK (("sync_status" = ANY (ARRAY['idle'::"text", 'syncing'::"text", 'completed'::"text", 'error'::"text"])))
);


ALTER TABLE "public"."gmail_sync_status" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."goal_metrics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "goal_id" "uuid" NOT NULL,
    "metric_name" "text" NOT NULL,
    "metric_type" "text" DEFAULT 'number'::"text" NOT NULL,
    "target_value" numeric,
    "current_value" numeric DEFAULT 0,
    "unit" "text",
    "value_history" "jsonb" DEFAULT '[]'::"jsonb",
    "progress_percentage" numeric GENERATED ALWAYS AS (
CASE
    WHEN (("target_value" IS NULL) OR ("target_value" = (0)::numeric)) THEN (0)::numeric
    ELSE LEAST((100)::numeric, "round"((("current_value" / "target_value") * (100)::numeric), 2))
END) STORED,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."goal_metrics" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."goal_updates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "goal_id" "uuid" NOT NULL,
    "field_changed" "text" NOT NULL,
    "old_value" "text",
    "new_value" "text",
    "source" "text" DEFAULT 'dashboard'::"text" NOT NULL,
    "updated_by" "text",
    "comment" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."goal_updates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."goals_2026" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "notion_id" "text" NOT NULL,
    "title" "text" NOT NULL,
    "type" "text" NOT NULL,
    "lane" "text",
    "status" "text" DEFAULT 'Not started'::"text",
    "owner" "jsonb" DEFAULT '[]'::"jsonb",
    "key_results" "text",
    "start_date" "date",
    "due_date" "date",
    "parent_goal_id" "text",
    "pillar_id" "text",
    "project_id" "text",
    "synced_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "progress_percentage" integer DEFAULT 0,
    "last_updated_by" "text",
    "last_update_source" "text" DEFAULT 'notion_sync'::"text"
);


ALTER TABLE "public"."goals_2026" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."goal_progress_summary" AS
 SELECT "id",
    "title",
    "type",
    "lane",
    "status",
    "progress_percentage",
    "owner",
    "due_date",
    ( SELECT "count"(*) AS "count"
           FROM "public"."goal_updates"
          WHERE ("goal_updates"."goal_id" = "g"."id")) AS "update_count",
    ( SELECT "max"("goal_updates"."created_at") AS "max"
           FROM "public"."goal_updates"
          WHERE ("goal_updates"."goal_id" = "g"."id")) AS "last_update_at",
    ( SELECT "count"(*) AS "count"
           FROM "public"."goal_metrics"
          WHERE ("goal_metrics"."goal_id" = "g"."id")) AS "metric_count",
    ( SELECT "avg"("goal_metrics"."progress_percentage") AS "avg"
           FROM "public"."goal_metrics"
          WHERE ("goal_metrics"."goal_id" = "g"."id")) AS "avg_metric_progress"
   FROM "public"."goals_2026" "g";


ALTER VIEW "public"."goal_progress_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."grant_financial_tracking" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "opportunity_id" "uuid",
    "project_code" "text" NOT NULL,
    "grant_name" "text" NOT NULL,
    "monetary_value" numeric,
    "status" "text" DEFAULT 'research'::"text",
    "submitted_date" timestamp with time zone,
    "approved_date" timestamp with time zone,
    "received_date" timestamp with time zone,
    "acquitted_date" timestamp with time zone,
    "xero_invoice_id" "text",
    "xero_invoice_number" "text",
    "bank_transaction_id" "text",
    "acquittal_due_date" timestamp with time zone,
    "acquittal_status" "text" DEFAULT 'pending'::"text",
    "acquittal_notes" "text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."grant_financial_tracking" OWNER TO "postgres";


COMMENT ON TABLE "public"."grant_financial_tracking" IS 'Tracks grants through their lifecycle from research to acquittal, linking GHL opportunities to Xero invoices';



CREATE TABLE IF NOT EXISTS "public"."grant_opportunities" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "amount_min" integer DEFAULT 0,
    "amount_max" integer DEFAULT 0,
    "deadline" "date",
    "source" "text" NOT NULL,
    "relevance_score" integer DEFAULT 50,
    "application_status" "text" DEFAULT 'not_applied'::"text",
    "url" "text",
    "requirements" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."grant_opportunities" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."harvest_businesses" (
    "id" integer NOT NULL,
    "name" "text" NOT NULL,
    "category" "text" NOT NULL,
    "description" "text" NOT NULL,
    "address" "text",
    "phone" "text",
    "email" "text",
    "website" "text",
    "facebook" "text",
    "instagram" "text",
    "imageUrl" "text",
    "submittedBy" "text",
    "submitterEmail" "text" NOT NULL,
    "userOpenId" "text",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "harvest_businesses_category_check" CHECK (("category" = ANY (ARRAY['markets'::"text", 'arts'::"text", 'accommodation'::"text", 'services'::"text", 'food'::"text", 'wellness'::"text", 'retail'::"text", 'other'::"text"]))),
    CONSTRAINT "harvest_businesses_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text"])))
);


ALTER TABLE "public"."harvest_businesses" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."harvest_businesses_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."harvest_businesses_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."harvest_businesses_id_seq" OWNED BY "public"."harvest_businesses"."id";



CREATE TABLE IF NOT EXISTS "public"."harvest_events" (
    "id" integer NOT NULL,
    "title" "text" NOT NULL,
    "date" "date" NOT NULL,
    "time" "text" NOT NULL,
    "location" "text" NOT NULL,
    "category" "text" NOT NULL,
    "description" "text" NOT NULL,
    "contactEmail" "text" NOT NULL,
    "submittedBy" "text",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "harvest_events_category_check" CHECK (("category" = ANY (ARRAY['market'::"text", 'community'::"text", 'arts'::"text", 'workshop'::"text", 'music'::"text"]))),
    CONSTRAINT "harvest_events_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text"])))
);


ALTER TABLE "public"."harvest_events" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."harvest_events_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."harvest_events_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."harvest_events_id_seq" OWNED BY "public"."harvest_events"."id";



CREATE TABLE IF NOT EXISTS "public"."health_alerts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "site_id" "uuid" NOT NULL,
    "alert_type" "text" NOT NULL,
    "severity" "text" DEFAULT 'warning'::"text" NOT NULL,
    "message" "text" NOT NULL,
    "previous_score" integer,
    "current_score" integer,
    "acknowledged" boolean DEFAULT false,
    "acknowledged_by" "text",
    "acknowledged_at" timestamp with time zone,
    "resolved" boolean DEFAULT false,
    "resolved_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."health_alerts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."historical_inquiries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" "text" NOT NULL,
    "inquiry_type" "text",
    "jurisdiction" "text",
    "year_published" integer,
    "year_started" integer,
    "summary" "text",
    "source_url" "text",
    "pdf_url" "text",
    "key_findings" "jsonb" DEFAULT '[]'::"jsonb",
    "recommendations_count" integer,
    "implementation_status" "text",
    "related_intervention_ids" "uuid"[] DEFAULT '{}'::"uuid"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "historical_inquiries_inquiry_type_check" CHECK (("inquiry_type" = ANY (ARRAY['royal_commission'::"text", 'parliamentary'::"text", 'government_review'::"text", 'judicial'::"text", 'coronial'::"text", 'ombudsman'::"text"])))
);


ALTER TABLE "public"."historical_inquiries" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ignored_email_patterns" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "pattern_type" "text" NOT NULL,
    "pattern" "text" NOT NULL,
    "reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."ignored_email_patterns" OWNER TO "postgres";


COMMENT ON TABLE "public"."ignored_email_patterns" IS 'Known patterns to filter out (newsletters, system emails, marketing)';



CREATE TABLE IF NOT EXISTS "public"."impact_evidence" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "storyteller_id" "uuid",
    "impact_type" "public"."impact_type_enum" NOT NULL,
    "impact_scope" "public"."impact_scope_enum" NOT NULL,
    "outcome_description" "text",
    "people_affected" integer,
    "duration_of_impact" character varying(100),
    "measurable_outcomes" "jsonb",
    "story_evidence" "text",
    "testimonial_quotes" "text"[],
    "behavior_changes_described" "text",
    "evidence_strength" "public"."evidence_strength_enum",
    "verification_method" character varying(200),
    "external_validation" boolean DEFAULT false,
    "sustainability_indicators" "jsonb",
    "replication_potential" numeric(3,2),
    "scaling_opportunities" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."impact_evidence" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."impact_stories" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "storyteller_id" "uuid",
    "story_title" "text" NOT NULL,
    "impact_description" "text" NOT NULL,
    "beneficiaries_mentioned" "text"[] DEFAULT '{}'::"text"[],
    "scale_indicators" "text"[] DEFAULT '{}'::"text"[],
    "outcome_quotes" "text"[] DEFAULT '{}'::"text"[],
    "timeframe_mentioned" "text",
    "story_source" "uuid",
    "related_story" "uuid",
    "amplification_consent" boolean DEFAULT true,
    "visibility_level" "text" DEFAULT 'community'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."impact_stories" OWNER TO "postgres";


COMMENT ON TABLE "public"."impact_stories" IS 'Storyteller impact narratives extracted from their authentic expressions';



CREATE TABLE IF NOT EXISTS "public"."intelligence_briefings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "generated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "summary" "text" NOT NULL,
    "highlights" "jsonb" DEFAULT '[]'::"jsonb",
    "metrics" "jsonb" DEFAULT '{}'::"jsonb",
    "created_by" "text" DEFAULT 'synthesis-agent'::"text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."intelligence_briefings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."intelligence_geo_alerts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "region" "text" NOT NULL,
    "stage" "text",
    "severity" "text" DEFAULT 'medium'::"text",
    "projects" "jsonb" DEFAULT '[]'::"jsonb",
    "recommendation" "text",
    "triggered_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."intelligence_geo_alerts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."intelligence_refusals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "agent" "text" NOT NULL,
    "prompt" "text" NOT NULL,
    "reason" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."intelligence_refusals" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."interactions" (
    "id" bigint NOT NULL,
    "contact_id" bigint NOT NULL,
    "interaction_type" "text" NOT NULL,
    "interaction_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "quality_score" numeric(3,2),
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "interactions_interaction_type_check" CHECK (("interaction_type" = ANY (ARRAY['email'::"text", 'call'::"text", 'meeting'::"text", 'message'::"text", 'linkedin_message'::"text", 'referral'::"text"]))),
    CONSTRAINT "interactions_quality_score_check" CHECK ((("quality_score" >= 1.0) AND ("quality_score" <= 5.0)))
);


ALTER TABLE "public"."interactions" OWNER TO "postgres";


COMMENT ON TABLE "public"."interactions" IS 'Tracks engagement history between users and LinkedIn contacts';



CREATE SEQUENCE IF NOT EXISTS "public"."interactions_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."interactions_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."interactions_id_seq" OWNED BY "public"."interactions"."id";



CREATE TABLE IF NOT EXISTS "public"."international_invitations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "program_id" "uuid",
    "invitee_name" "text" NOT NULL,
    "invitee_role" "text",
    "invitee_email" "text",
    "invitation_status" "text" DEFAULT 'draft'::"text",
    "invitation_date" "date",
    "visit_purpose" "text",
    "proposed_dates" "text",
    "hosting_organization" "text",
    "visit_completed" boolean DEFAULT false,
    "visit_report" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "international_invitations_invitation_status_check" CHECK (("invitation_status" = ANY (ARRAY['draft'::"text", 'sent'::"text", 'accepted'::"text", 'declined'::"text", 'completed'::"text"])))
);


ALTER TABLE "public"."international_invitations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."international_programs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "country" "text" NOT NULL,
    "region" "public"."global_region" NOT NULL,
    "city_location" "text",
    "program_type" "public"."program_type"[] DEFAULT '{}'::"public"."program_type"[] NOT NULL,
    "description" "text" NOT NULL,
    "approach_summary" "text" NOT NULL,
    "target_population" "text",
    "year_established" integer,
    "key_outcomes" "jsonb" DEFAULT '[]'::"jsonb",
    "recidivism_rate" numeric(5,2),
    "recidivism_comparison" "text",
    "evidence_strength" "public"."evidence_strength",
    "research_citations" "jsonb" DEFAULT '[]'::"jsonb",
    "cost_benefit_ratio" "text",
    "scale" "text",
    "population_served" integer,
    "australian_adaptations" "text"[],
    "visit_status" "text",
    "visit_date" "date",
    "visit_notes" "text",
    "collaboration_opportunities" "text",
    "featured_image_url" "text",
    "website_url" "text",
    "contact_email" "text",
    "documents" "jsonb" DEFAULT '[]'::"jsonb",
    "related_story_ids" "uuid"[],
    "related_program_ids" "uuid"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "status" "text" DEFAULT 'published'::"text",
    CONSTRAINT "international_programs_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'published'::"text", 'archived'::"text"])))
);


ALTER TABLE "public"."international_programs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."justice_matrix_campaigns" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "country_region" "text" NOT NULL,
    "campaign_name" "text" NOT NULL,
    "lead_organizations" "text",
    "goals" "text",
    "notable_tactics" "text",
    "outcome_status" "text",
    "campaign_link" "text",
    "start_year" integer,
    "end_year" integer,
    "is_ongoing" boolean DEFAULT true,
    "campaign_type" "text",
    "source" "text" DEFAULT 'partner_contribution'::"text",
    "contributor_org" "text",
    "verified" boolean DEFAULT false,
    "verified_by" "text",
    "verified_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "lat" numeric(10,7),
    "lng" numeric(10,7),
    "country_code" character varying(3),
    "categories" "text"[] DEFAULT '{}'::"text"[],
    "featured" boolean DEFAULT false,
    "featured_at" timestamp with time zone
);


ALTER TABLE "public"."justice_matrix_campaigns" OWNER TO "postgres";


COMMENT ON TABLE "public"."justice_matrix_campaigns" IS 'Advocacy campaigns for refugees and asylum seekers - Justice Matrix project';



COMMENT ON COLUMN "public"."justice_matrix_campaigns"."lat" IS 'Latitude for map visualization';



COMMENT ON COLUMN "public"."justice_matrix_campaigns"."lng" IS 'Longitude for map visualization';



COMMENT ON COLUMN "public"."justice_matrix_campaigns"."country_code" IS 'ISO 3166 country code';



COMMENT ON COLUMN "public"."justice_matrix_campaigns"."categories" IS 'Campaign categories';



COMMENT ON COLUMN "public"."justice_matrix_campaigns"."featured" IS 'Highlighted for storytelling';



COMMENT ON COLUMN "public"."justice_matrix_campaigns"."featured_at" IS 'When item was featured';



CREATE TABLE IF NOT EXISTS "public"."justice_matrix_cases" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "jurisdiction" "text" NOT NULL,
    "case_citation" "text" NOT NULL,
    "year" integer,
    "court" "text",
    "strategic_issue" "text",
    "key_holding" "text",
    "authoritative_link" "text",
    "region" "text",
    "case_type" "text",
    "status" "text" DEFAULT 'active'::"text",
    "source" "text" DEFAULT 'partner_contribution'::"text",
    "contributor_org" "text",
    "verified" boolean DEFAULT false,
    "verified_by" "text",
    "verified_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "lat" numeric(10,7),
    "lng" numeric(10,7),
    "country_code" character varying(3),
    "categories" "text"[] DEFAULT '{}'::"text"[],
    "outcome" character varying(20),
    "precedent_strength" character varying(10),
    "featured" boolean DEFAULT false,
    "featured_at" timestamp with time zone,
    CONSTRAINT "justice_matrix_cases_outcome_check" CHECK ((("outcome")::"text" = ANY ((ARRAY['favorable'::character varying, 'adverse'::character varying, 'pending'::character varying])::"text"[]))),
    CONSTRAINT "justice_matrix_cases_precedent_strength_check" CHECK ((("precedent_strength")::"text" = ANY ((ARRAY['high'::character varying, 'medium'::character varying, 'low'::character varying])::"text"[])))
);


ALTER TABLE "public"."justice_matrix_cases" OWNER TO "postgres";


COMMENT ON TABLE "public"."justice_matrix_cases" IS 'Strategic refugee/asylum cases from around the world - Justice Matrix project';



COMMENT ON COLUMN "public"."justice_matrix_cases"."lat" IS 'Latitude for map visualization';



COMMENT ON COLUMN "public"."justice_matrix_cases"."lng" IS 'Longitude for map visualization';



COMMENT ON COLUMN "public"."justice_matrix_cases"."country_code" IS 'ISO 3166 country code';



COMMENT ON COLUMN "public"."justice_matrix_cases"."categories" IS 'Legal categories (non-refoulement, detention, etc.)';



COMMENT ON COLUMN "public"."justice_matrix_cases"."outcome" IS 'Case outcome: favorable, adverse, or pending';



COMMENT ON COLUMN "public"."justice_matrix_cases"."precedent_strength" IS 'Importance for future cases: high, medium, low';



COMMENT ON COLUMN "public"."justice_matrix_cases"."featured" IS 'Highlighted for storytelling';



COMMENT ON COLUMN "public"."justice_matrix_cases"."featured_at" IS 'When item was featured';



CREATE TABLE IF NOT EXISTS "public"."justice_matrix_discovered" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "source_id" "uuid",
    "source_url" "text" NOT NULL,
    "item_type" character varying(20) NOT NULL,
    "raw_data" "jsonb" NOT NULL,
    "extracted_title" "text",
    "extracted_jurisdiction" "text",
    "extracted_year" integer,
    "extracted_categories" "text"[],
    "extracted_summary" "text",
    "extracted_lat" numeric(10,7),
    "extracted_lng" numeric(10,7),
    "extracted_country_code" character varying(3),
    "status" character varying(20) DEFAULT 'pending'::character varying,
    "review_notes" "text",
    "reviewed_by" "text",
    "reviewed_at" timestamp with time zone,
    "approved_case_id" "uuid",
    "approved_campaign_id" "uuid",
    "approved_resource_id" "uuid",
    "similarity_score" numeric(5,2),
    "potential_duplicate_id" "uuid",
    "extraction_confidence" numeric(5,2),
    "discovered_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."justice_matrix_discovered" OWNER TO "postgres";


COMMENT ON TABLE "public"."justice_matrix_discovered" IS 'Queue of items discovered by Ralph pending human review';



COMMENT ON COLUMN "public"."justice_matrix_discovered"."raw_data" IS 'Full extracted data before normalization';



COMMENT ON COLUMN "public"."justice_matrix_discovered"."similarity_score" IS 'Similarity to existing items for deduplication';



COMMENT ON COLUMN "public"."justice_matrix_discovered"."extraction_confidence" IS 'AI confidence in extraction accuracy (0-100)';



CREATE TABLE IF NOT EXISTS "public"."justice_matrix_resources" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" "text" NOT NULL,
    "resource_type" "text" NOT NULL,
    "description" "text",
    "jurisdiction" "text",
    "case_id" "uuid",
    "campaign_id" "uuid",
    "file_url" "text",
    "external_link" "text",
    "author" "text",
    "organization" "text",
    "publish_date" "date",
    "language" "text" DEFAULT 'en'::"text",
    "is_public" boolean DEFAULT true,
    "requires_registration" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."justice_matrix_resources" OWNER TO "postgres";


COMMENT ON TABLE "public"."justice_matrix_resources" IS 'Legal resources, pleadings, and advocacy materials - Justice Matrix project';



CREATE TABLE IF NOT EXISTS "public"."justice_matrix_scrape_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "source_id" "uuid",
    "run_type" character varying(20) NOT NULL,
    "started_at" timestamp with time zone NOT NULL,
    "completed_at" timestamp with time zone,
    "duration_ms" integer,
    "status" character varying(20) NOT NULL,
    "pages_crawled" integer DEFAULT 0,
    "items_found" integer DEFAULT 0,
    "items_new" integer DEFAULT 0,
    "items_duplicate" integer DEFAULT 0,
    "items_error" integer DEFAULT 0,
    "error_message" "text",
    "error_details" "jsonb",
    "ai_tokens_used" integer DEFAULT 0,
    "ai_model_used" character varying(50),
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."justice_matrix_scrape_logs" OWNER TO "postgres";


COMMENT ON TABLE "public"."justice_matrix_scrape_logs" IS 'History of scrape runs for monitoring and debugging';



CREATE TABLE IF NOT EXISTS "public"."justice_matrix_sources" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "source_type" character varying(50) NOT NULL,
    "url" "text" NOT NULL,
    "region" character varying(50),
    "jurisdictions" "text"[],
    "organization" "text",
    "description" "text",
    "data_format" character varying(50),
    "requires_auth" boolean DEFAULT false,
    "auth_type" character varying(20),
    "scrape_frequency" character varying(20) DEFAULT 'weekly'::character varying,
    "scrape_priority" integer DEFAULT 5,
    "rate_limit_ms" integer DEFAULT 1000,
    "css_selectors" "jsonb",
    "extraction_patterns" "jsonb",
    "is_active" boolean DEFAULT true,
    "last_scraped_at" timestamp with time zone,
    "last_success_at" timestamp with time zone,
    "last_error" "text",
    "success_rate" numeric(5,2) DEFAULT 100.00,
    "total_items_found" integer DEFAULT 0,
    "total_items_approved" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."justice_matrix_sources" OWNER TO "postgres";


COMMENT ON TABLE "public"."justice_matrix_sources" IS 'Track sources for Ralph automated research - court databases, advocacy orgs, etc.';



CREATE TABLE IF NOT EXISTS "public"."justicehub_nodes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "node_type" "text",
    "state_code" "text",
    "country" "text" DEFAULT 'Australia'::"text",
    "lead_organization_id" "uuid",
    "description" "text",
    "contact_email" "text",
    "website_url" "text",
    "latitude" numeric(10,8),
    "longitude" numeric(11,8),
    "status" "text" DEFAULT 'forming'::"text",
    "logo_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "justicehub_nodes_node_type_check" CHECK (("node_type" = ANY (ARRAY['state'::"text", 'territory'::"text", 'international'::"text"]))),
    CONSTRAINT "justicehub_nodes_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'forming'::"text", 'planned'::"text"])))
);


ALTER TABLE "public"."justicehub_nodes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."knowledge_chunks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "content" "text" NOT NULL,
    "source_type" "text" NOT NULL,
    "source_id" "text",
    "project_id" "text",
    "file_path" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "confidence" double precision DEFAULT 0.8,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "summary" "text",
    "topics" "text"[],
    "entities" "text"[],
    "quality_score" double precision,
    "content_hash" "text",
    "embedding" "public"."vector"(384),
    CONSTRAINT "knowledge_chunks_confidence_check" CHECK ((("confidence" >= (0)::double precision) AND ("confidence" <= (1)::double precision))),
    CONSTRAINT "knowledge_chunks_source_type_check" CHECK (("source_type" = ANY (ARRAY['codebase'::"text", 'notion'::"text", 'ghl'::"text", 'email'::"text", 'calendar'::"text", 'manual'::"text", 'system'::"text", 'error_log'::"text", 'alert'::"text"])))
);


ALTER TABLE "public"."knowledge_chunks" OWNER TO "postgres";


COMMENT ON TABLE "public"."knowledge_chunks" IS 'RAG knowledge base with semantic search (384-dim all-MiniLM-L6-v2)';



COMMENT ON COLUMN "public"."knowledge_chunks"."source_type" IS 'Origin: codebase, notion, ghl, email, calendar, manual, system, error_log, alert';



COMMENT ON COLUMN "public"."knowledge_chunks"."embedding" IS '384-dimensional embedding from all-MiniLM-L6-v2 model';



CREATE TABLE IF NOT EXISTS "public"."pmpp_knowledge" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "type" "text" NOT NULL,
    "title" "text" NOT NULL,
    "content" "text" NOT NULL,
    "context" "text",
    "parent_principle_id" "uuid",
    "parent_method_id" "uuid",
    "parent_practice_id" "uuid",
    "version" integer DEFAULT 1,
    "status" "text" DEFAULT 'draft'::"text",
    "last_reviewed_at" timestamp with time zone DEFAULT "now"(),
    "review_frequency_days" integer,
    "update_authority" "text",
    "requires_approval_from" "text"[],
    "projects" "text"[],
    "domains" "text"[],
    "tags" "text"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "pmpp_hierarchy_check" CHECK (((("type" = 'principle'::"text") AND ("parent_principle_id" IS NULL) AND ("parent_method_id" IS NULL) AND ("parent_practice_id" IS NULL)) OR (("type" = 'method'::"text") AND ("parent_principle_id" IS NOT NULL) AND ("parent_method_id" IS NULL) AND ("parent_practice_id" IS NULL)) OR (("type" = 'practice'::"text") AND ("parent_principle_id" IS NOT NULL) AND ("parent_method_id" IS NOT NULL) AND ("parent_practice_id" IS NULL)) OR (("type" = 'procedure'::"text") AND ("parent_principle_id" IS NOT NULL) AND ("parent_method_id" IS NOT NULL) AND ("parent_practice_id" IS NOT NULL)))),
    CONSTRAINT "pmpp_knowledge_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'active'::"text", 'archived'::"text"]))),
    CONSTRAINT "pmpp_knowledge_type_check" CHECK (("type" = ANY (ARRAY['principle'::"text", 'method'::"text", 'practice'::"text", 'procedure'::"text"])))
);


ALTER TABLE "public"."pmpp_knowledge" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."knowledge_review_schedule" AS
 SELECT "id",
    "type",
    "title",
    "last_reviewed_at",
    "review_frequency_days",
    ("last_reviewed_at" + (("review_frequency_days" || ' days'::"text"))::interval) AS "next_review_due",
        CASE
            WHEN (("last_reviewed_at" + (("review_frequency_days" || ' days'::"text"))::interval) < "now"()) THEN 'overdue'::"text"
            WHEN (("last_reviewed_at" + (("review_frequency_days" || ' days'::"text"))::interval) < ("now"() + '7 days'::interval)) THEN 'due_soon'::"text"
            ELSE 'current'::"text"
        END AS "review_status"
   FROM "public"."pmpp_knowledge" "p"
  WHERE (("status" = 'active'::"text") AND ("review_frequency_days" IS NOT NULL))
  ORDER BY
        CASE
            WHEN (("last_reviewed_at" + (("review_frequency_days" || ' days'::"text"))::interval) < "now"()) THEN 1
            WHEN (("last_reviewed_at" + (("review_frequency_days" || ' days'::"text"))::interval) < ("now"() + '7 days'::interval)) THEN 2
            ELSE 3
        END, ("last_reviewed_at" + (("review_frequency_days" || ' days'::"text"))::interval);


ALTER VIEW "public"."knowledge_review_schedule" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."knowledge_source_sync" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "source_type" "text" NOT NULL,
    "last_sync_at" timestamp with time zone,
    "last_sync_cursor" "text",
    "last_sync_duration_ms" integer,
    "items_scanned_last_sync" integer DEFAULT 0,
    "items_extracted_last_sync" integer DEFAULT 0,
    "total_items_scanned" integer DEFAULT 0,
    "total_items_extracted" integer DEFAULT 0,
    "total_items_approved" integer DEFAULT 0,
    "total_items_rejected" integer DEFAULT 0,
    "enabled" boolean DEFAULT true,
    "sync_frequency_hours" integer DEFAULT 24,
    "next_sync_due" timestamp with time zone,
    "config" "jsonb" DEFAULT '{}'::"jsonb",
    "filters" "jsonb" DEFAULT '{}'::"jsonb",
    "status" "text" DEFAULT 'active'::"text",
    "last_error" "text",
    "last_error_at" timestamp with time zone,
    "consecutive_errors" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "knowledge_source_sync_source_type_check" CHECK (("source_type" = ANY (ARRAY['notion'::"text", 'gmail'::"text", 'calendar'::"text", 'ghl'::"text", 'whatsapp'::"text", 'slack'::"text", 'drive'::"text"]))),
    CONSTRAINT "knowledge_source_sync_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'paused'::"text", 'syncing'::"text", 'error'::"text"])))
);


ALTER TABLE "public"."knowledge_source_sync" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."knowledge_source_health" AS
 SELECT "source_type",
    "enabled",
    "status",
    "last_sync_at",
    "next_sync_due",
        CASE
            WHEN ("status" = 'error'::"text") THEN 'error'::"text"
            WHEN (NOT "enabled") THEN 'disabled'::"text"
            WHEN ("next_sync_due" < "now"()) THEN 'overdue'::"text"
            WHEN ("next_sync_due" < ("now"() + '02:00:00'::interval)) THEN 'due_soon'::"text"
            ELSE 'healthy'::"text"
        END AS "health_status",
    "total_items_scanned",
    "total_items_extracted",
    "total_items_approved",
        CASE
            WHEN ("total_items_extracted" > 0) THEN "round"(((("total_items_approved")::numeric / ("total_items_extracted")::numeric) * (100)::numeric), 1)
            ELSE (0)::numeric
        END AS "approval_rate_pct",
    "consecutive_errors",
    "last_error"
   FROM "public"."knowledge_source_sync"
  ORDER BY
        CASE
            WHEN ("status" = 'error'::"text") THEN 1
            WHEN ("next_sync_due" < "now"()) THEN 2
            ELSE 3
        END, "source_type";


ALTER VIEW "public"."knowledge_source_health" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."knowledge_sources" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "knowledge_id" "text" NOT NULL,
    "source_type" "text" NOT NULL,
    "source_name" "text" NOT NULL,
    "source_url" "text",
    "source_date" "date",
    "authority_level" integer NOT NULL,
    "verified_by" "uuid",
    "verified_at" timestamp with time zone,
    "context" "text",
    "limitations" "text",
    "conflicts_with" "uuid"[],
    "superseded_by" "uuid",
    "author" "text",
    "organization" "text",
    "projects" "text"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "knowledge_sources_authority_level_check" CHECK ((("authority_level" >= 1) AND ("authority_level" <= 5))),
    CONSTRAINT "knowledge_sources_source_type_check" CHECK (("source_type" = ANY (ARRAY['foundational'::"text", 'strategic'::"text", 'tactical'::"text", 'dynamic'::"text", 'experimental'::"text"])))
);


ALTER TABLE "public"."knowledge_sources" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."learned_thresholds" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "threshold_type" "text" NOT NULL,
    "segment" "text" DEFAULT 'default'::"text" NOT NULL,
    "value" double precision NOT NULL,
    "confidence" double precision DEFAULT 0.5 NOT NULL,
    "sample_size" integer DEFAULT 0 NOT NULL,
    "prior_value" double precision NOT NULL,
    "prior_strength" double precision DEFAULT 1.0 NOT NULL,
    "last_learned_at" timestamp with time zone,
    "learning_data" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "threshold_days" integer DEFAULT 30,
    "prior_alpha" numeric(10,2) DEFAULT 2,
    "prior_beta" numeric(10,2) DEFAULT 2,
    "last_updated" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."learned_thresholds" OWNER TO "postgres";


COMMENT ON TABLE "public"."learned_thresholds" IS 'Bayesian-learned contact frequency thresholds by relationship segment';



COMMENT ON COLUMN "public"."learned_thresholds"."threshold_type" IS 'Type of threshold: stale_days, attention_days, normal_days, high_value, etc.';



COMMENT ON COLUMN "public"."learned_thresholds"."segment" IS 'Contact/entity segment: funder, partner, community, default, etc.';



COMMENT ON COLUMN "public"."learned_thresholds"."confidence" IS 'Confidence in threshold (updated via Bayesian learning)';



COMMENT ON COLUMN "public"."learned_thresholds"."prior_value" IS 'Initial value before any learning (Bayesian prior)';



COMMENT ON COLUMN "public"."learned_thresholds"."prior_strength" IS 'Pseudo-count for how strongly to weight the prior';



CREATE TABLE IF NOT EXISTS "public"."linkedin_contacts" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "person_id" "uuid",
    "first_name" "text" NOT NULL,
    "last_name" "text" NOT NULL,
    "full_name" "text" GENERATED ALWAYS AS ((("first_name" || ' '::"text") || "last_name")) STORED,
    "linkedin_url" "text",
    "email_address" "text",
    "current_company" "text",
    "current_position" "text",
    "location" "text",
    "connected_date" "date",
    "data_source" "text",
    "relationship_score" numeric(3,2) DEFAULT 0.50,
    "strategic_value" "text" DEFAULT 'unknown'::"text",
    "influence_level" "text",
    "network_reach" integer,
    "engagement_frequency" "text",
    "interaction_count" integer DEFAULT 0,
    "last_interaction" timestamp with time zone,
    "alignment_tags" "text"[] DEFAULT '{}'::"text"[],
    "skills_extracted" "text"[] DEFAULT '{}'::"text"[],
    "industries" "text"[] DEFAULT '{}'::"text"[],
    "notion_person_id" "text",
    "gmail_contact_id" "text",
    "raw_data" "jsonb",
    "imported_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "bio" "text",
    "exa_enriched" boolean DEFAULT false,
    "exa_last_enriched" timestamp without time zone,
    "exa_confidence_score" numeric(3,2),
    CONSTRAINT "linkedin_contacts_engagement_frequency_check" CHECK (("engagement_frequency" = ANY (ARRAY['high'::"text", 'medium'::"text", 'low'::"text", 'none'::"text"]))),
    CONSTRAINT "linkedin_contacts_relationship_score_check" CHECK ((("relationship_score" >= (0)::numeric) AND ("relationship_score" <= (1)::numeric))),
    CONSTRAINT "linkedin_contacts_strategic_value_check" CHECK (("strategic_value" = ANY (ARRAY['high'::"text", 'medium'::"text", 'low'::"text", 'unknown'::"text"])))
);


ALTER TABLE "public"."linkedin_contacts" OWNER TO "postgres";


COMMENT ON COLUMN "public"."linkedin_contacts"."linkedin_url" IS 'LinkedIn profile URL found via Exa enrichment';



COMMENT ON COLUMN "public"."linkedin_contacts"."bio" IS 'Brief bio/summary from web search';



COMMENT ON COLUMN "public"."linkedin_contacts"."exa_enriched" IS 'Whether contact has been enriched with Exa data';



COMMENT ON COLUMN "public"."linkedin_contacts"."exa_last_enriched" IS 'Timestamp of last Exa enrichment';



COMMENT ON COLUMN "public"."linkedin_contacts"."exa_confidence_score" IS 'Confidence score of enrichment data (0-1)';



CREATE TABLE IF NOT EXISTS "public"."linkedin_imports" (
    "id" bigint NOT NULL,
    "owner" "text" NOT NULL,
    "type" "text" NOT NULL,
    "hash" "text" NOT NULL,
    "payload" "jsonb" NOT NULL,
    "imported_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."linkedin_imports" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."linkedin_imports_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."linkedin_imports_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."linkedin_imports_id_seq" OWNED BY "public"."linkedin_imports"."id";



CREATE TABLE IF NOT EXISTS "public"."linkedin_project_connections" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "contact_id" "uuid",
    "notion_project_id" "text",
    "project_name" "text" NOT NULL,
    "connection_type" "text",
    "relevance_score" numeric(3,2) DEFAULT 0.00,
    "potential_role" "text",
    "recommended_action" "text",
    "contact_status" "text" DEFAULT 'identified'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."linkedin_project_connections" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."locations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "country" "text",
    "state_province" "text",
    "city" "text",
    "coordinates" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."locations" OWNER TO "postgres";


COMMENT ON TABLE "public"."locations" IS 'Geographic locations for storytellers and projects';



CREATE TABLE IF NOT EXISTS "public"."media_assets" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "filename" "text" NOT NULL,
    "file_path" "text" NOT NULL,
    "file_size" integer,
    "mime_type" "text",
    "category" "text",
    "tags" "text"[] DEFAULT ARRAY[]::"text"[],
    "uploaded_by" "text" DEFAULT 'anonymous'::"text",
    "uploaded_at" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."media_assets" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."media_collections" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "type" "text" DEFAULT 'gallery'::"text",
    "project_id" "uuid",
    "story_id" "uuid",
    "organization_id" "uuid",
    "featured" boolean DEFAULT false,
    "public_visible" boolean DEFAULT true,
    "sort_order" integer DEFAULT 0,
    "cover_image_id" "uuid",
    "settings" json DEFAULT '{}'::json,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "media_collections_type_check" CHECK (("type" = ANY (ARRAY['gallery'::"text", 'slideshow'::"text", 'story-collection'::"text", 'project-showcase'::"text"])))
);


ALTER TABLE "public"."media_collections" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."media_files" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "filename" "text" NOT NULL,
    "original_filename" "text" NOT NULL,
    "file_size_bytes" bigint NOT NULL,
    "mime_type" "text" NOT NULL,
    "file_hash" "text",
    "storage_path" "text" NOT NULL,
    "storage_bucket" "text" NOT NULL,
    "public_url" "text",
    "story_id" "uuid",
    "storyteller_id" "uuid",
    "organization_id" "uuid",
    "alt_text" "text",
    "caption" "text",
    "media_type" "text",
    "processing_status" "text" DEFAULT 'completed'::"text",
    "thumbnail_url" "text",
    "visibility" "text" DEFAULT 'private'::"text",
    "uploaded_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "media_files_media_type_check" CHECK (("media_type" = ANY (ARRAY['image'::"text", 'audio'::"text", 'video'::"text", 'document'::"text"]))),
    CONSTRAINT "media_files_processing_status_check" CHECK (("processing_status" = ANY (ARRAY['uploading'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text"]))),
    CONSTRAINT "media_files_visibility_check" CHECK (("visibility" = ANY (ARRAY['private'::"text", 'organization'::"text", 'public'::"text"])))
);


ALTER TABLE "public"."media_files" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."media_item" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" character varying(500) NOT NULL,
    "description" "text",
    "media_type" character varying(50) NOT NULL,
    "media_url" "text" NOT NULL,
    "thumbnail_url" "text",
    "creator_name" character varying(200),
    "creator_profile_id" "uuid",
    "organization_id" "uuid",
    "organization_name" character varying(200),
    "program_id" "uuid",
    "views" integer DEFAULT 0,
    "duration" character varying(20),
    "file_size_bytes" bigint,
    "mime_type" character varying(100),
    "tags" "text"[],
    "is_featured" boolean DEFAULT false,
    "is_public" boolean DEFAULT true,
    "consent_level" character varying(50) DEFAULT 'Public'::character varying,
    "attribution_text" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."media_item" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."media_items" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "file_url" "text" NOT NULL,
    "file_type" "text" NOT NULL,
    "title" "text",
    "description" "text",
    "alt_text" "text",
    "file_size" bigint,
    "dimensions" json,
    "project_ids" "uuid"[],
    "story_ids" "uuid"[],
    "storyteller_ids" "uuid"[],
    "organization_ids" "uuid"[],
    "ai_tags" "text"[],
    "manual_tags" "text"[],
    "ai_confidence" numeric DEFAULT 0,
    "ai_processed" boolean DEFAULT false,
    "photographer" "text",
    "consent_verified" boolean DEFAULT false,
    "usage_rights" "text" DEFAULT 'community-approved'::"text",
    "attribution_required" boolean DEFAULT true,
    "community_approved" boolean DEFAULT false,
    "location_data" json,
    "capture_date" "date",
    "impact_themes" "text"[],
    "emotional_tone" "text",
    "processed" boolean DEFAULT false,
    "thumbnail_url" "text",
    "compressed_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "year_in_review_year" integer,
    "timeline_entry_id" "text",
    "is_hero_image" boolean DEFAULT false,
    "source" "text",
    "source_id" "text",
    "project_slugs" "text"[] DEFAULT '{}'::"text"[],
    "credit" "text",
    "caption" "text",
    "blurhash" "text",
    "created_by" "uuid",
    CONSTRAINT "media_items_file_type_check" CHECK (("file_type" = ANY (ARRAY['photo'::"text", 'video'::"text", 'document'::"text"])))
);


ALTER TABLE "public"."media_items" OWNER TO "postgres";


COMMENT ON TABLE "public"."media_items" IS 'Central media library for all ACT projects with tagging and metadata';



CREATE TABLE IF NOT EXISTS "public"."media_library" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "file_path" "text" NOT NULL,
    "file_name" "text" NOT NULL,
    "original_name" "text",
    "mime_type" "text" NOT NULL,
    "file_size" integer NOT NULL,
    "width" integer,
    "height" integer,
    "alt_text" "text",
    "caption" "text",
    "tags" "text"[] DEFAULT '{}'::"text"[],
    "folder" "text" DEFAULT 'uploads'::"text",
    "versions" "jsonb" DEFAULT '{}'::"jsonb",
    "blurhash" "text",
    "uploaded_by" "uuid",
    "used_in_posts" integer DEFAULT 0,
    "last_used_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "valid_mime_type" CHECK (("mime_type" ~~ 'image/%'::"text"))
);


ALTER TABLE "public"."media_library" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."media_processing_jobs" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "media_id" "uuid",
    "job_type" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text",
    "result_data" json,
    "error_message" "text",
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "media_processing_jobs_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text"])))
);


ALTER TABLE "public"."media_processing_jobs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."media_usage" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "media_id" "uuid",
    "used_in_type" "text" NOT NULL,
    "used_in_id" "uuid",
    "usage_context" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."media_usage" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."messages" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "portrait_id" "uuid" NOT NULL,
    "word" "text" NOT NULL,
    "read" boolean DEFAULT false NOT NULL,
    CONSTRAINT "messages_word_check" CHECK ((("word" ~ '^[a-zA-Z]+$'::"text") AND ("length"("word") <= 20)))
);


ALTER TABLE "public"."messages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."metrics" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "user_id" "text" DEFAULT 'anonymous'::"text",
    "stories_analyzed" integer DEFAULT 0,
    "brand_tests_active" integer DEFAULT 0,
    "content_items" integer DEFAULT 0,
    "brand_score" real DEFAULT 0,
    "last_updated" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."metrics" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."migration_email_templates" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "tenant_id" "text" NOT NULL,
    "template_name" "text" NOT NULL,
    "subject_template" "text" NOT NULL,
    "body_template" "text" NOT NULL,
    "is_default" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."migration_email_templates" OWNER TO "postgres";


COMMENT ON TABLE "public"."migration_email_templates" IS 'Email templates for vendor contact with variable substitution';



CREATE OR REPLACE VIEW "public"."migration_progress" AS
 SELECT "tenant_id",
    "count"(*) AS "total_subscriptions",
    "count"(*) FILTER (WHERE ("migration_status" = 'not_started'::"text")) AS "not_started",
    "count"(*) FILTER (WHERE ("migration_status" = 'pending_contact'::"text")) AS "pending_contact",
    "count"(*) FILTER (WHERE ("migration_status" = 'contacted'::"text")) AS "contacted",
    "count"(*) FILTER (WHERE ("migration_status" = 'vendor_confirmed'::"text")) AS "vendor_confirmed",
    "count"(*) FILTER (WHERE ("migration_status" = 'completed'::"text")) AS "completed",
    "count"(*) FILTER (WHERE ("migration_status" = 'skipped'::"text")) AS "skipped",
    "count"(*) FILTER (WHERE ("migration_status" = ANY (ARRAY['completed'::"text", 'skipped'::"text"]))) AS "done",
    "round"(((("count"(*) FILTER (WHERE ("migration_status" = ANY (ARRAY['completed'::"text", 'skipped'::"text"]))))::numeric / (NULLIF("count"(*), 0))::numeric) * (100)::numeric), 2) AS "completion_rate",
    "avg"("migration_priority") FILTER (WHERE ("migration_status" <> ALL (ARRAY['completed'::"text", 'skipped'::"text"]))) AS "avg_pending_priority",
    "count"(*) FILTER (WHERE ("migration_priority" >= 80)) AS "high_priority",
    "count"(*) FILTER (WHERE (("migration_priority" >= 60) AND ("migration_priority" < 80))) AS "medium_priority",
    "count"(*) FILTER (WHERE ("migration_priority" < 60)) AS "low_priority"
   FROM "public"."discovered_subscriptions"
  GROUP BY "tenant_id";


ALTER VIEW "public"."migration_progress" OWNER TO "postgres";


COMMENT ON VIEW "public"."migration_progress" IS 'Real-time dashboard summary of migration progress by tenant';



CREATE TABLE IF NOT EXISTS "public"."migration_rate_limits" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "tenant_id" "text" NOT NULL,
    "date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "emails_sent" integer DEFAULT 0,
    "emails_queued" integer DEFAULT 0,
    "daily_limit" integer DEFAULT 100,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."migration_rate_limits" OWNER TO "postgres";


COMMENT ON TABLE "public"."migration_rate_limits" IS 'Enforces daily Gmail API rate limits (100 emails/day)';



CREATE OR REPLACE VIEW "public"."missing_receipts" AS
 SELECT "id",
    "transaction_date",
    "vendor_name",
    "description",
    "amount",
    "project_code",
    "category",
    "receipt_status",
    "email_match_confidence",
    "email_match_subject",
    "deferred_until",
    "notes",
    "created_at"
   FROM "public"."receipt_status"
  WHERE (("receipt_status" = ANY (ARRAY['missing'::"text", 'pending'::"text"])) AND (("deferred_until" IS NULL) OR ("deferred_until" <= CURRENT_DATE)))
  ORDER BY
        CASE
            WHEN ("email_match_confidence" > 0.7) THEN 1
            WHEN ("email_match_confidence" > 0.5) THEN 2
            ELSE 3
        END, "amount" DESC, "transaction_date" DESC;


ALTER VIEW "public"."missing_receipts" OWNER TO "postgres";


COMMENT ON VIEW "public"."missing_receipts" IS 'Prioritized list of receipts needing attention';



CREATE TABLE IF NOT EXISTS "public"."xero_bank_transactions" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "xero_id" "text" NOT NULL,
    "tenant_id" "text" NOT NULL,
    "type" "text" NOT NULL,
    "status" "text",
    "contact_id" "text",
    "contact_name" "text",
    "date" "date",
    "total" numeric(15,2),
    "subtotal" numeric(15,2),
    "total_tax" numeric(15,2),
    "bank_account_id" "text",
    "bank_account_name" "text",
    "reference" "text",
    "line_items" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "synced_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "xero_bank_transactions_type_check" CHECK (("type" = ANY (ARRAY['SPEND'::"text", 'RECEIVE'::"text"])))
);


ALTER TABLE "public"."xero_bank_transactions" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."missing_subscriptions" AS
 WITH "recurring_vendors" AS (
         SELECT "xero_bank_transactions"."tenant_id",
            "xero_bank_transactions"."contact_name",
            "count"(*) AS "transaction_count",
            "avg"("xero_bank_transactions"."total") AS "avg_amount",
            "min"("xero_bank_transactions"."date") AS "first_transaction",
            "max"("xero_bank_transactions"."date") AS "last_transaction"
           FROM "public"."xero_bank_transactions"
          WHERE (("xero_bank_transactions"."type" = 'SPEND'::"text") AND ("xero_bank_transactions"."total" > (0)::numeric))
          GROUP BY "xero_bank_transactions"."tenant_id", "xero_bank_transactions"."contact_name"
         HAVING ("count"(*) >= 2)
        )
 SELECT "xbt"."id",
    "xbt"."tenant_id",
    "xbt"."contact_name" AS "vendor",
    "xbt"."total" AS "amount",
    "xbt"."date" AS "transaction_date",
    "xbt"."bank_account_name",
    "xbt"."reference" AS "description",
    "rv"."transaction_count",
    "rv"."avg_amount"
   FROM ("public"."xero_bank_transactions" "xbt"
     JOIN "recurring_vendors" "rv" ON ((("rv"."tenant_id" = "xbt"."tenant_id") AND ("rv"."contact_name" = "xbt"."contact_name"))))
  WHERE (("xbt"."type" = 'SPEND'::"text") AND (NOT (EXISTS ( SELECT 1
           FROM "public"."email_financial_documents" "efd"
          WHERE (("efd"."tenant_id" = "xbt"."tenant_id") AND ("lower"("efd"."vendor") = "lower"("xbt"."contact_name")) AND ("efd"."is_subscription" = true))))))
  ORDER BY "xbt"."date" DESC;


ALTER VIEW "public"."missing_subscriptions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."newsletter_subscribers" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "email" "text" NOT NULL,
    "name" "text",
    "status" "text" DEFAULT 'active'::"text",
    "subscribed_at" timestamp with time zone DEFAULT "now"(),
    "unsubscribed_at" timestamp with time zone,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "newsletter_subscribers_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'unsubscribed'::"text", 'bounced'::"text"])))
);


ALTER TABLE "public"."newsletter_subscribers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."newsletter_subscriptions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "email" "text" NOT NULL,
    "full_name" "text",
    "organization" "text",
    "subscription_type" "text" DEFAULT 'general'::"text",
    "ghl_contact_id" "text",
    "is_active" boolean DEFAULT true,
    "subscribed_at" timestamp with time zone DEFAULT "now"(),
    "unsubscribed_at" timestamp with time zone,
    "source" "text",
    CONSTRAINT "newsletter_subscriptions_subscription_type_check" CHECK (("subscription_type" = ANY (ARRAY['general'::"text", 'steward'::"text", 'researcher'::"text", 'youth'::"text"])))
);


ALTER TABLE "public"."newsletter_subscriptions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."normalized_documents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "source_type" "text" DEFAULT 'story'::"text" NOT NULL,
    "source_id" "uuid",
    "title" "text",
    "content" "text" DEFAULT ''::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE "public"."normalized_documents" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."normalized_stories" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "source_id" "uuid",
    "title" "text" DEFAULT ''::"text" NOT NULL,
    "content" "text" DEFAULT ''::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE "public"."normalized_stories" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."normalized_storytellers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "source_id" "uuid",
    "full_name" "text" DEFAULT ''::"text" NOT NULL,
    "bio" "text" DEFAULT ''::"text",
    "created_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE "public"."normalized_storytellers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."wiki_notifications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "type" character varying(50) NOT NULL,
    "title" "text" NOT NULL,
    "message" "text" NOT NULL,
    "link" "text",
    "priority" character varying(20) DEFAULT 'normal'::character varying,
    "is_read" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "read_at" timestamp with time zone,
    "wiki_page_id" "uuid",
    "queue_item_id" "uuid",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "wiki_notifications_type_check" CHECK ((("type")::"text" = ANY ((ARRAY['review_due'::character varying, 'page_stale'::character varying, 'new_extraction'::character varying, 'high_confidence'::character varying, 'system'::character varying])::"text"[])))
);


ALTER TABLE "public"."wiki_notifications" OWNER TO "postgres";


COMMENT ON TABLE "public"."wiki_notifications" IS 'In-app notifications for wiki review reminders and updates';



CREATE OR REPLACE VIEW "public"."notification_summary" AS
 SELECT "count"(*) FILTER (WHERE (NOT "is_read")) AS "unread_count",
    "count"(*) FILTER (WHERE ((NOT "is_read") AND (("priority")::"text" = 'urgent'::"text"))) AS "urgent_count",
    "count"(*) FILTER (WHERE ((NOT "is_read") AND (("priority")::"text" = 'high'::"text"))) AS "high_count",
    "count"(*) FILTER (WHERE ((NOT "is_read") AND (("type")::"text" = 'review_due'::"text"))) AS "review_due_count",
    "count"(*) FILTER (WHERE ((NOT "is_read") AND (("type")::"text" = 'high_confidence'::"text"))) AS "high_confidence_count",
    "max"("created_at") FILTER (WHERE (NOT "is_read")) AS "latest_unread_at"
   FROM "public"."wiki_notifications";


ALTER VIEW "public"."notification_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."notion_opportunities" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "notion_id" "text",
    "name" "text",
    "stage" "text",
    "amount" numeric,
    "probability" numeric,
    "close_date" "date",
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "type" "text" DEFAULT 'opportunities'::"text",
    "last_synced" timestamp with time zone DEFAULT "now"(),
    "sync_version" integer DEFAULT 1
);


ALTER TABLE "public"."notion_opportunities" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."notion_organization_people" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "notion_organizations_id" "uuid",
    "notion_people_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."notion_organization_people" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."notion_organizations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "notion_id" "text",
    "name" "text",
    "description" "text",
    "industry" "text",
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "type" "text" DEFAULT 'organizations'::"text",
    "last_synced" timestamp with time zone DEFAULT "now"(),
    "sync_version" integer DEFAULT 1
);


ALTER TABLE "public"."notion_organizations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."notion_people" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "notion_id" "text",
    "name" "text",
    "email" "text",
    "organization" "text",
    "role" "text",
    "tags" "text"[],
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."notion_people" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."notion_project_organizations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "notion_project_id" "uuid",
    "notion_organizations_id" "uuid",
    "relationship" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."notion_project_organizations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."notion_project_people" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "notion_project_id" "uuid",
    "notion_people_id" "uuid",
    "role" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."notion_project_people" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."notion_projects" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "notion_id" "text",
    "title" "text",
    "name" "text",
    "description" "text",
    "status" "text",
    "priority" "text",
    "assignee" "text",
    "start_date" "date",
    "end_date" "date",
    "budget" numeric,
    "actual_cost" numeric,
    "progress" numeric,
    "tags" "text"[],
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "type" "text" DEFAULT 'projects'::"text",
    "last_synced" timestamp with time zone DEFAULT "now"(),
    "sync_version" integer DEFAULT 1
);


ALTER TABLE "public"."notion_projects" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."notion_projects_cache" (
    "notion_project_id" "text" NOT NULL,
    "project_name" "text" NOT NULL,
    "project_source" "text" DEFAULT 'placemat'::"text",
    "tags" "text"[],
    "location" "text",
    "required_expertise" "text"[],
    "alma_intervention_id" "text",
    "status" "text",
    "description" "text",
    "raw_data" "jsonb",
    "last_synced_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "notion_projects_cache_project_source_check" CHECK (("project_source" = ANY (ARRAY['placemat'::"text", 'justicehub'::"text", 'farm'::"text", 'empathy_ledger'::"text", 'intelligence_hub'::"text"])))
);


ALTER TABLE "public"."notion_projects_cache" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."opportunities" (
    "id" bigint NOT NULL,
    "title" "text" NOT NULL,
    "brief" "text" NOT NULL,
    "region_tags" "text"[] DEFAULT '{}'::"text"[],
    "role_tags" "text"[] DEFAULT '{}'::"text"[],
    "status" "text" DEFAULT 'active'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "deadline" timestamp with time zone,
    "brief_embedding" "public"."vector"(384),
    "alignment_score" numeric,
    "archived" boolean DEFAULT false,
    CONSTRAINT "opportunities_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'closed'::"text", 'paused'::"text"])))
);


ALTER TABLE "public"."opportunities" OWNER TO "postgres";


COMMENT ON TABLE "public"."opportunities" IS 'Business opportunities that can be matched with contacts';



CREATE SEQUENCE IF NOT EXISTS "public"."opportunities_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."opportunities_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."opportunities_id_seq" OWNED BY "public"."opportunities"."id";



CREATE TABLE IF NOT EXISTS "public"."organization_connections" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "storyteller_id" "uuid",
    "organization_id" "uuid",
    "relationship_type" "text" NOT NULL,
    "relationship_context" "text",
    "mentioned_in_transcript" "uuid",
    "mentioned_in_story" "uuid",
    "verified" boolean DEFAULT false,
    "verification_source" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."organization_connections" OWNER TO "postgres";


COMMENT ON TABLE "public"."organization_connections" IS 'Discovered organizational affiliations mentioned in storyteller content';



CREATE TABLE IF NOT EXISTS "public"."organization_enrichment" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "organization_id" "uuid",
    "enrichment_type" character varying(50) NOT NULL,
    "data" "jsonb" NOT NULL,
    "confidence_score" numeric(3,2) NOT NULL,
    "source_metadata" "jsonb",
    "validation_status" character varying(20) DEFAULT 'pending'::character varying,
    "validated_by" character varying(255),
    "validated_at" timestamp with time zone,
    "validation_notes" "text",
    "active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    "updated_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE "public"."organization_enrichment" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."organization_members" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "text" NOT NULL,
    "permissions" "text"[] DEFAULT '{}'::"text"[],
    "status" "text" DEFAULT 'active'::"text",
    "invited_at" timestamp with time zone DEFAULT "now"(),
    "joined_at" timestamp with time zone,
    "last_active_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "organization_members_role_check" CHECK (("role" = ANY (ARRAY['member'::"text", 'admin'::"text", 'staff'::"text", 'counselor'::"text", 'manager'::"text", 'owner'::"text"]))),
    CONSTRAINT "organization_members_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'inactive'::"text", 'pending'::"text", 'suspended'::"text"])))
);


ALTER TABLE "public"."organization_members" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."organization_sync_log" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "organization_id" "uuid",
    "empathy_ledger_org_id" "uuid",
    "sync_action" "text" NOT NULL,
    "sync_status" "text" NOT NULL,
    "sync_details" "jsonb",
    "error_message" "text",
    "synced_at" timestamp without time zone DEFAULT "now"()
);


ALTER TABLE "public"."organization_sync_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."organizations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "type" "text",
    "location" "text",
    "contact_email" "text",
    "website_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "archived" boolean DEFAULT false NOT NULL,
    "collaboration_areas" "text"[],
    "slug" "text",
    "email" "text",
    "phone" "text",
    "website" "text",
    "street_address" "text",
    "suburb" "text",
    "city" "text",
    "state" "text",
    "postcode" "text",
    "latitude" numeric(10,8),
    "longitude" numeric(11,8),
    "verification_status" "text" DEFAULT 'pending'::"text",
    "is_active" boolean DEFAULT true,
    "logo_url" "text",
    "tags" "text"[] DEFAULT '{}'::"text"[],
    "settings" "jsonb" DEFAULT '{}'::"jsonb",
    "empathy_ledger_org_id" "uuid",
    "synced_from_empathy_ledger" boolean DEFAULT false,
    "last_synced_at" timestamp without time zone,
    "partner_tier" "text",
    "tagline" "text"
);


ALTER TABLE "public"."organizations" OWNER TO "postgres";


COMMENT ON TABLE "public"."organizations" IS 'Organizations in the Empathy Ledger multi-tenant system';



CREATE TABLE IF NOT EXISTS "public"."organizations_profiles" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "public_profile_id" "uuid" NOT NULL,
    "role" "text",
    "role_description" "text",
    "start_date" "date",
    "end_date" "date",
    "is_current" boolean DEFAULT true,
    "is_featured" boolean DEFAULT false,
    "display_order" integer DEFAULT 0,
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"()
);


ALTER TABLE "public"."organizations_profiles" OWNER TO "postgres";


COMMENT ON TABLE "public"."organizations_profiles" IS 'Links people to organizations they work with or founded';



CREATE TABLE IF NOT EXISTS "public"."outreach_strategies" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "contact_id" "uuid" NOT NULL,
    "strategy" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "recommended_approach" "text" DEFAULT 'professional'::"text",
    "best_topics" "text"[] DEFAULT '{}'::"text"[],
    "timing" "text" DEFAULT 'within-week'::"text",
    "mutual_connections" "jsonb" DEFAULT '[]'::"jsonb",
    "value_proposition" "text",
    "email_template" "text",
    "follow_up_sequence" "text"[] DEFAULT '{}'::"text"[],
    "success_probability" integer DEFAULT 70,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "outreach_strategies_success_probability_check" CHECK ((("success_probability" >= 0) AND ("success_probability" <= 100)))
);


ALTER TABLE "public"."outreach_strategies" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."outreach_tasks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "contact_id" "text",
    "project_id" "uuid",
    "project_name" "text",
    "contact_name" "text",
    "status" "text" DEFAULT 'draft'::"text",
    "priority" "text" DEFAULT 'normal'::"text",
    "recommended_channel" "text",
    "scheduled_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "owner" "text",
    "ai_brief" "jsonb",
    "draft_message" "text",
    "message_metadata" "jsonb",
    "response_status" "text",
    "response_notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."outreach_tasks" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."subscription_receipts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "subscription_id" "uuid" NOT NULL,
    "receipt_date" "date",
    "amount" numeric(10,2),
    "currency" "text" DEFAULT 'AUD'::"text",
    "file_url" "text",
    "file_type" "text",
    "ocr_text" "text",
    "ocr_confidence" numeric(3,2),
    "extracted_vendor" "text",
    "extracted_amount" numeric(10,2),
    "extracted_date" "date",
    "ner_entities" "jsonb",
    "source" "text",
    "gmail_message_id" "text",
    "xero_transaction_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "reconciliation_confidence" numeric(3,2),
    "reconciliation_date" timestamp with time zone,
    "reconciliation_status" "text" DEFAULT 'unmatched'::"text",
    CONSTRAINT "subscription_receipts_file_type_check" CHECK (("file_type" = ANY (ARRAY['pdf'::"text", 'image'::"text", 'email'::"text"]))),
    CONSTRAINT "subscription_receipts_reconciliation_confidence_check" CHECK ((("reconciliation_confidence" >= (0)::numeric) AND ("reconciliation_confidence" <= (1)::numeric))),
    CONSTRAINT "subscription_receipts_reconciliation_status_check" CHECK (("reconciliation_status" = ANY (ARRAY['auto_matched'::"text", 'manual_matched'::"text", 'unmatched'::"text", 'disputed'::"text", 'manual_review'::"text"]))),
    CONSTRAINT "subscription_receipts_source_check" CHECK (("source" = ANY (ARRAY['gmail'::"text", 'xero'::"text", 'manual'::"text"])))
);


ALTER TABLE "public"."subscription_receipts" OWNER TO "postgres";


COMMENT ON COLUMN "public"."subscription_receipts"."reconciliation_confidence" IS 'Fuzzy matching confidence score (0.0-1.0) from reconciliation engine';



COMMENT ON COLUMN "public"."subscription_receipts"."reconciliation_date" IS 'When this receipt was reconciled to a Xero transaction';



COMMENT ON COLUMN "public"."subscription_receipts"."reconciliation_status" IS 'auto_matched (>=80% confidence), manual_review (<80%), manual_matched (user verified), unmatched (no match), disputed (conflict)';



CREATE OR REPLACE VIEW "public"."outstanding_invoices" AS
 SELECT "sr"."id",
    "sr"."subscription_id",
    "sr"."receipt_date",
    "sr"."amount",
    "sr"."currency",
    "ds"."vendor",
    "ds"."tenant_id",
    (EXTRACT(day FROM ("now"() - ("sr"."receipt_date")::timestamp with time zone)))::integer AS "days_overdue",
        CASE
            WHEN ((EXTRACT(day FROM ("now"() - ("sr"."receipt_date")::timestamp with time zone)) > (30)::numeric) OR ("sr"."amount" > (500)::numeric)) THEN 'critical'::"text"
            WHEN ((EXTRACT(day FROM ("now"() - ("sr"."receipt_date")::timestamp with time zone)) > (7)::numeric) OR ("sr"."amount" > (100)::numeric)) THEN 'high'::"text"
            ELSE 'normal'::"text"
        END AS "priority_status",
    ((
        CASE
            WHEN (EXTRACT(day FROM ("now"() - ("sr"."receipt_date")::timestamp with time zone)) > (30)::numeric) THEN 50
            WHEN (EXTRACT(day FROM ("now"() - ("sr"."receipt_date")::timestamp with time zone)) > (7)::numeric) THEN 30
            ELSE LEAST((EXTRACT(day FROM ("now"() - ("sr"."receipt_date")::timestamp with time zone)))::integer, 20)
        END)::numeric +
        CASE
            WHEN ("sr"."amount" > (500)::numeric) THEN (50)::numeric
            WHEN ("sr"."amount" > (100)::numeric) THEN (30)::numeric
            ELSE LEAST(("sr"."amount" / (2)::numeric), (20)::numeric)
        END) AS "priority_score",
    "sr"."gmail_message_id",
    "sr"."source",
    "sr"."created_at"
   FROM ("public"."subscription_receipts" "sr"
     JOIN "public"."discovered_subscriptions" "ds" ON (("ds"."id" = "sr"."subscription_id")))
  WHERE ("sr"."xero_transaction_id" IS NULL)
  ORDER BY ((
        CASE
            WHEN (EXTRACT(day FROM ("now"() - ("sr"."receipt_date")::timestamp with time zone)) > (30)::numeric) THEN 50
            WHEN (EXTRACT(day FROM ("now"() - ("sr"."receipt_date")::timestamp with time zone)) > (7)::numeric) THEN 30
            ELSE LEAST((EXTRACT(day FROM ("now"() - ("sr"."receipt_date")::timestamp with time zone)))::integer, 20)
        END)::numeric +
        CASE
            WHEN ("sr"."amount" > (500)::numeric) THEN (50)::numeric
            WHEN ("sr"."amount" > (100)::numeric) THEN (30)::numeric
            ELSE LEAST(("sr"."amount" / (2)::numeric), (20)::numeric)
        END) DESC, "sr"."receipt_date" DESC;


ALTER VIEW "public"."outstanding_invoices" OWNER TO "postgres";


COMMENT ON VIEW "public"."outstanding_invoices" IS 'Pre-calculated view of unpaid receipts with priority scoring for quick dashboard queries';



CREATE TABLE IF NOT EXISTS "public"."pages" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "slug" "text" NOT NULL,
    "title" "text" NOT NULL,
    "content" "text" NOT NULL,
    "meta_description" "text",
    "published" boolean DEFAULT true,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."pages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."partner_contacts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "contact_type" "text" NOT NULL,
    "label" "text" NOT NULL,
    "value" "text" NOT NULL,
    "icon" "text",
    "is_primary" boolean DEFAULT false,
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "partner_contacts_contact_type_check" CHECK (("contact_type" = ANY (ARRAY['email'::"text", 'phone'::"text", 'website'::"text", 'social'::"text", 'address'::"text", 'booking'::"text"])))
);


ALTER TABLE "public"."partner_contacts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."partner_external_links" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "url" "text" NOT NULL,
    "link_type" "text" NOT NULL,
    "description" "text",
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "partner_external_links_link_type_check" CHECK (("link_type" = ANY (ARRAY['website'::"text", 'social'::"text", 'news'::"text", 'research'::"text", 'documentary'::"text", 'podcast'::"text"])))
);


ALTER TABLE "public"."partner_external_links" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."partner_goals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "goal_type" "text" NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "icon" "text",
    "display_order" integer DEFAULT 0,
    "is_featured" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "partner_goals_goal_type_check" CHECK (("goal_type" = ANY (ARRAY['mission'::"text", 'vision'::"text", 'goal'::"text", 'value'::"text", 'principle'::"text"])))
);


ALTER TABLE "public"."partner_goals" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."partner_impact_metrics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "metric_name" "text" NOT NULL,
    "metric_value" "text" NOT NULL,
    "metric_context" "text",
    "icon" "text",
    "display_order" integer DEFAULT 0,
    "is_featured" boolean DEFAULT true,
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."partner_impact_metrics" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."partner_photos" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "node_id" "uuid",
    "title" "text",
    "description" "text",
    "photographer" "text",
    "photo_url" "text" NOT NULL,
    "thumbnail_url" "text",
    "photo_type" "text" DEFAULT 'general'::"text",
    "location_name" "text",
    "taken_at" "date",
    "is_featured" boolean DEFAULT false,
    "is_public" boolean DEFAULT true,
    "display_order" integer DEFAULT 0,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "partner_photos_photo_type_check" CHECK (("photo_type" = ANY (ARRAY['card_thumbnail'::"text", 'hero_banner'::"text", 'gallery'::"text", 'team'::"text", 'location'::"text", 'program'::"text", 'hero'::"text", 'profile'::"text", 'event'::"text", 'site'::"text", 'general'::"text"])))
);


ALTER TABLE "public"."partner_photos" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."partner_site_locations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "location_type" "text",
    "status" "text" DEFAULT 'planned'::"text",
    "x_percent" numeric(5,2),
    "y_percent" numeric(5,2),
    "icon" "text",
    "photo_url" "text",
    "interactive_map_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "partner_site_locations_status_check" CHECK (("status" = ANY (ARRAY['completed'::"text", 'in_progress'::"text", 'planned'::"text", 'concept'::"text"])))
);


ALTER TABLE "public"."partner_site_locations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."partner_stories" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "node_id" "uuid",
    "empathy_ledger_story_id" "uuid",
    "title" "text" NOT NULL,
    "excerpt" "text",
    "thumbnail_url" "text",
    "story_type" "text",
    "is_featured" boolean DEFAULT false,
    "is_public" boolean DEFAULT true,
    "consent_level" "text" DEFAULT 'public'::"text",
    "linked_at" timestamp with time zone DEFAULT "now"(),
    "quote" "text",
    "summary" "text",
    "tags" "text"[],
    "display_order" integer DEFAULT 0,
    CONSTRAINT "partner_stories_consent_level_check" CHECK (("consent_level" = ANY (ARRAY['public'::"text", 'organization'::"text", 'private'::"text"])))
);


ALTER TABLE "public"."partner_stories" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."partner_storytellers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "node_id" "uuid",
    "empathy_ledger_profile_id" "uuid",
    "display_name" "text" NOT NULL,
    "role_at_org" "text",
    "bio_excerpt" "text",
    "avatar_url" "text",
    "is_featured" boolean DEFAULT false,
    "is_public" boolean DEFAULT true,
    "consent_level" "text" DEFAULT 'public'::"text",
    "linked_at" timestamp with time zone DEFAULT "now"(),
    "quote" "text",
    "display_order" integer DEFAULT 0,
    "role" "text",
    CONSTRAINT "partner_storytellers_consent_level_check" CHECK (("consent_level" = ANY (ARRAY['public'::"text", 'organization'::"text", 'private'::"text"])))
);


ALTER TABLE "public"."partner_storytellers" OWNER TO "postgres";


COMMENT ON COLUMN "public"."partner_storytellers"."role" IS 'Standardized role from role_taxonomy (e.g., elder, participant, storyteller)';



CREATE OR REPLACE VIEW "public"."partner_storytellers_v" AS
 SELECT "id",
    "organization_id",
    "node_id",
    "empathy_ledger_profile_id",
    "display_name",
    "role",
    "role" AS "role_at_org",
    "bio_excerpt",
    "avatar_url",
    "quote",
    "is_featured",
    "is_public",
    "consent_level",
    "display_order",
    "linked_at"
   FROM "public"."partner_storytellers";


ALTER VIEW "public"."partner_storytellers_v" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."partner_videos" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "node_id" "uuid",
    "title" "text" NOT NULL,
    "description" "text",
    "video_url" "text" NOT NULL,
    "video_id" "text",
    "platform" "text" DEFAULT 'youtube'::"text",
    "thumbnail_url" "text",
    "duration_seconds" integer,
    "video_type" "text" DEFAULT 'documentary'::"text",
    "is_featured" boolean DEFAULT false,
    "is_public" boolean DEFAULT true,
    "view_count" integer DEFAULT 0,
    "published_at" "date",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "video_placement" "text" DEFAULT 'gallery'::"text",
    CONSTRAINT "partner_videos_platform_check" CHECK (("platform" = ANY (ARRAY['youtube'::"text", 'vimeo'::"text", 'wistia'::"text", 'other'::"text"]))),
    CONSTRAINT "partner_videos_video_placement_check" CHECK (("video_placement" = ANY (ARRAY['featured'::"text", 'gallery'::"text", 'testimonial'::"text", 'program'::"text"]))),
    CONSTRAINT "partner_videos_video_type_check" CHECK (("video_type" = ANY (ARRAY['documentary'::"text", 'interview'::"text", 'promotional'::"text", 'training'::"text", 'event'::"text", 'music_video'::"text"])))
);


ALTER TABLE "public"."partner_videos" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."partners" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "name" "text" NOT NULL,
    "type" "text" NOT NULL,
    "category" "text",
    "logo_url" "text",
    "website_url" "text",
    "description" "text",
    "collaboration_focus" "text",
    "location" "text",
    "partnership_since" "date",
    "featured" boolean DEFAULT false,
    "relationship_strength" "text" DEFAULT 'emerging'::"text",
    "public_visible" boolean DEFAULT true,
    "empathy_ledger_org_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."partners" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."pending_contacts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "email" "text" NOT NULL,
    "name" "text",
    "company" "text",
    "title" "text",
    "first_seen_at" timestamp with time zone DEFAULT "now"(),
    "last_seen_at" timestamp with time zone DEFAULT "now"(),
    "communication_count" integer DEFAULT 1,
    "topics" "text"[],
    "importance_score" numeric(3,2) DEFAULT 0.5,
    "suggested_tags" "text"[],
    "status" "text" DEFAULT 'pending'::"text",
    "reviewed_by" "uuid",
    "reviewed_at" timestamp with time zone,
    "ghl_contact_id" "text",
    "rejection_reason" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."pending_contacts" OWNER TO "postgres";


COMMENT ON TABLE "public"."pending_contacts" IS 'Contacts discovered from emails awaiting review for GHL creation';



CREATE OR REPLACE VIEW "public"."pending_elder_reviews" AS
 SELECT "eq"."id",
    "eq"."content_type",
    "eq"."project_slug",
    "eq"."cultural_topics",
    "eq"."sensitivity_level",
    "eq"."priority",
    "eq"."submitted_at",
    "eq"."assigned_to",
    "u"."email" AS "submitter_email"
   FROM ("public"."elder_review_queue" "eq"
     LEFT JOIN "auth"."users" "u" ON (("eq"."submitted_by" = "u"."id")))
  WHERE ("eq"."status" = ANY (ARRAY['pending'::"text", 'in_review'::"text"]))
  ORDER BY "eq"."priority" DESC, "eq"."submitted_at";


ALTER VIEW "public"."pending_elder_reviews" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."pending_extractions" AS
 SELECT "id",
    "source_type",
    "source_id",
    "source_url",
    "source_metadata",
    "raw_content",
    "raw_title",
    "extracted_knowledge",
    "suggested_title",
    "suggested_type",
    "suggested_excerpt",
    "suggested_projects",
    "suggested_domains",
    "suggested_tags",
    "suggested_parent_ids",
    "confidence_score",
    "status",
    "reviewed_by",
    "reviewed_at",
    "review_notes",
    "wiki_page_id",
    "extracted_at",
    "extraction_model",
    "extraction_prompt",
    "priority",
    "created_at",
        CASE
            WHEN ("confidence_score" >= 0.8) THEN 'high'::"text"
            WHEN ("confidence_score" >= 0.5) THEN 'medium'::"text"
            ELSE 'low'::"text"
        END AS "confidence_level"
   FROM "public"."knowledge_extraction_queue" "e"
  WHERE ("status" = 'pending'::"text")
  ORDER BY "priority" DESC, "confidence_score" DESC, "created_at";


ALTER VIEW "public"."pending_extractions" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."pending_proposals" AS
 SELECT "p"."id",
    "p"."agent_id",
    "p"."title",
    "p"."description",
    "p"."priority",
    "p"."deadline",
    "p"."created_at",
    "a"."autonomy_level",
    "a"."risk_level",
    ("p"."reasoning" ->> 'trigger'::"text") AS "trigger_reason",
    ("p"."reasoning" ->> 'confidence'::"text") AS "confidence",
    "p"."impact_assessment"
   FROM ("public"."agent_proposals" "p"
     LEFT JOIN "public"."agent_actions" "a" ON (("p"."action_id" = "a"."id")))
  WHERE ("p"."status" = 'pending'::"text")
  ORDER BY
        CASE "p"."priority"
            WHEN 'urgent'::"text" THEN 1
            WHEN 'high'::"text" THEN 2
            WHEN 'normal'::"text" THEN 3
            ELSE 4
        END, "p"."created_at";


ALTER VIEW "public"."pending_proposals" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."person_identity_map" (
    "person_id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "full_name" "text",
    "email" "text",
    "linkedin_contact_id" "uuid",
    "gmail_id" "text",
    "notion_id" "text",
    "notion_person_id" "text",
    "external_ids" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "contact_data" "jsonb" DEFAULT '{}'::"jsonb",
    "youth_justice_relevance_score" integer DEFAULT 0,
    "engagement_priority" "text" DEFAULT 'low'::"text",
    "sector" "text",
    "indigenous_affiliation" boolean DEFAULT false,
    "government_influence" integer DEFAULT 0,
    "funding_capacity" "text",
    "collaboration_potential" integer DEFAULT 0,
    "tags" "text"[],
    "current_position" "text",
    "current_company" "text",
    "data_source" "text",
    "alignment_tags" "text"[] DEFAULT '{}'::"text"[],
    "exa_enriched" boolean DEFAULT false,
    "exa_enriched_at" timestamp with time zone,
    "exa_enrichment_confidence" numeric(3,2),
    "exa_last_refresh_at" timestamp with time zone,
    "exa_refresh_needed" boolean DEFAULT false,
    "discovered_via" "text",
    "ghl_contact_id" "text",
    "data_quality_score" integer DEFAULT 0,
    "data_sources" "text"[] DEFAULT '{}'::"text"[],
    "needs_cleanup" boolean DEFAULT false,
    "last_verified_at" timestamp with time zone,
    "total_emails_sent" integer DEFAULT 0,
    "total_emails_received" integer DEFAULT 0,
    "last_communication_at" timestamp with time zone,
    CONSTRAINT "person_identity_map_engagement_priority_check" CHECK (("engagement_priority" = ANY (ARRAY['critical'::"text", 'high'::"text", 'medium'::"text", 'low'::"text"]))),
    CONSTRAINT "person_identity_map_exa_enrichment_confidence_check" CHECK ((("exa_enrichment_confidence" >= (0)::numeric) AND ("exa_enrichment_confidence" <= (1)::numeric)))
);


ALTER TABLE "public"."person_identity_map" OWNER TO "postgres";


COMMENT ON COLUMN "public"."person_identity_map"."data_quality_score" IS 'Quality score 0-100 based on completeness: +20 email, +20 name, +15 company, +15 position, +10 LinkedIn, +10 GHL, +10 enriched';



COMMENT ON COLUMN "public"."person_identity_map"."data_sources" IS 'Array of sources: linkedin_ben, linkedin_nic, gmail, ghl, exa, manual';



COMMENT ON COLUMN "public"."person_identity_map"."needs_cleanup" IS 'True if record needs manual review (conflicting data, low quality)';



CREATE TABLE IF NOT EXISTS "public"."photo_album_photos" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "album_id" "uuid" NOT NULL,
    "photo_id" "uuid" NOT NULL,
    "sort_order" integer DEFAULT 0,
    "added_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."photo_album_photos" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."photo_album_shares" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "album_id" "uuid" NOT NULL,
    "share_method" character varying(50) NOT NULL,
    "share_url" "text",
    "recipient_info" "jsonb" DEFAULT '{}'::"jsonb",
    "expires_at" timestamp with time zone,
    "access_count" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "last_accessed" timestamp with time zone
);


ALTER TABLE "public"."photo_album_shares" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."photo_albums" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" character varying(255) NOT NULL,
    "description" "text",
    "cover_photo_id" "uuid",
    "slug" character varying(255) NOT NULL,
    "is_public" boolean DEFAULT false,
    "is_shareable" boolean DEFAULT true,
    "created_by" character varying(50) DEFAULT 'admin'::character varying,
    "storyteller_id" "uuid",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."photo_albums" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."photo_storyteller_tags" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "photo_id" "uuid" NOT NULL,
    "storyteller_id" "uuid" NOT NULL,
    "confidence" numeric(4,3),
    "face_coordinates" "jsonb",
    "detection_method" character varying(50) DEFAULT 'manual'::character varying,
    "tagged_by" character varying(50) DEFAULT 'admin'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."photo_storyteller_tags" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."photos" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "filename" character varying(255) NOT NULL,
    "url" "text" NOT NULL,
    "file_size" bigint NOT NULL,
    "dimensions" "jsonb",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "upload_date" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."photos" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."platform_collection_media" (
    "collection_id" "uuid" NOT NULL,
    "media_id" "uuid" NOT NULL,
    "sort_order" integer DEFAULT 0,
    "caption" "text",
    "featured_in_collection" boolean DEFAULT false,
    "auto_added" boolean DEFAULT false,
    "auto_score" numeric,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."platform_collection_media" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."platform_media_collections" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "platform_organization_id" "uuid",
    "name" "text" NOT NULL,
    "description" "text",
    "type" "text" DEFAULT 'gallery'::"text",
    "auto_generated" boolean DEFAULT false,
    "generation_criteria" "jsonb",
    "auto_refresh" boolean DEFAULT false,
    "featured" boolean DEFAULT false,
    "public_visible" boolean DEFAULT true,
    "sort_order" integer DEFAULT 0,
    "cover_image_id" "uuid",
    "settings" json DEFAULT '{}'::json,
    "project_id" "uuid",
    "story_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "platform_media_collections_type_check" CHECK (("type" = ANY (ARRAY['gallery'::"text", 'slideshow'::"text", 'story-collection'::"text", 'project-showcase'::"text", 'auto-curated'::"text"])))
);


ALTER TABLE "public"."platform_media_collections" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."platform_media_items" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "platform_organization_id" "uuid",
    "empathy_ledger_media_id" "uuid",
    "bucket_name" "text" DEFAULT 'empathy-ledger-media'::"text",
    "storage_path" "text" NOT NULL,
    "file_url" "text" NOT NULL,
    "thumbnail_url" "text",
    "file_type" "text" NOT NULL,
    "file_size" bigint,
    "dimensions" json,
    "mime_type" "text",
    "original_filename" "text",
    "title" "text",
    "description" "text",
    "content_category" "text" DEFAULT 'community'::"text",
    "content_subcategory" "text",
    "ai_tags" "text"[],
    "manual_tags" "text"[],
    "ai_confidence" numeric DEFAULT 0,
    "ai_processed" boolean DEFAULT false,
    "impact_themes" "text"[],
    "photographer" "text",
    "consent_verified" boolean DEFAULT false,
    "community_approved" boolean DEFAULT false,
    "attribution_required" boolean DEFAULT true,
    "usage_rights" "text" DEFAULT 'community-approved'::"text",
    "location_data" json,
    "capture_date" "date",
    "emotional_tone" "text",
    "project_ids" "uuid"[],
    "story_ids" "uuid"[],
    "storyteller_ids" "uuid"[],
    "processed" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "platform_media_items_file_type_check" CHECK (("file_type" = ANY (ARRAY['photo'::"text", 'video'::"text", 'document'::"text"])))
);


ALTER TABLE "public"."platform_media_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."platform_media_processing_jobs" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "platform_organization_id" "uuid",
    "media_id" "uuid",
    "job_type" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text",
    "input_data" json,
    "result_data" json,
    "error_message" "text",
    "processing_duration_ms" integer,
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "platform_media_processing_jobs_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text"])))
);


ALTER TABLE "public"."platform_media_processing_jobs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."platform_media_usage" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "platform_organization_id" "uuid",
    "media_id" "uuid",
    "used_in_type" "text" NOT NULL,
    "used_in_id" "uuid",
    "usage_context" "text",
    "view_count" integer DEFAULT 0,
    "download_count" integer DEFAULT 0,
    "share_count" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."platform_media_usage" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."platform_organizations" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "slug" "text" NOT NULL,
    "name" "text" NOT NULL,
    "storage_prefix" "text" NOT NULL,
    "subscription_tier" "text" DEFAULT 'starter'::"text",
    "storage_quota_gb" integer DEFAULT 10,
    "storage_used_gb" numeric DEFAULT 0,
    "api_calls_this_month" integer DEFAULT 0,
    "primary_contact_email" "text",
    "billing_email" "text",
    "domain" "text",
    "first_upload_at" timestamp with time zone,
    "last_activity_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "platform_organizations_subscription_tier_check" CHECK (("subscription_tier" = ANY (ARRAY['starter'::"text", 'professional'::"text", 'enterprise'::"text"])))
);


ALTER TABLE "public"."platform_organizations" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."platform_organization_stats" AS
 SELECT "o"."id",
    "o"."slug",
    "o"."name",
    "o"."storage_used_gb",
    "o"."storage_quota_gb",
    "count"("m"."id") AS "total_media_items",
    "count"("m"."id") FILTER (WHERE ("m"."file_type" = 'photo'::"text")) AS "photo_count",
    "count"("m"."id") FILTER (WHERE ("m"."file_type" = 'video'::"text")) AS "video_count",
    "count"(DISTINCT "c"."id") AS "collection_count",
    "max"("m"."created_at") AS "last_upload",
    "count"("m"."id") FILTER (WHERE ("m"."created_at" > ("now"() - '30 days'::interval))) AS "uploads_this_month",
    COALESCE("sum"("u"."view_count"), (0)::bigint) AS "total_views",
    COALESCE("sum"("u"."download_count"), (0)::bigint) AS "total_downloads"
   FROM ((("public"."platform_organizations" "o"
     LEFT JOIN "public"."platform_media_items" "m" ON (("o"."id" = "m"."platform_organization_id")))
     LEFT JOIN "public"."platform_media_collections" "c" ON (("o"."id" = "c"."platform_organization_id")))
     LEFT JOIN "public"."platform_media_usage" "u" ON (("m"."id" = "u"."media_id")))
  GROUP BY "o"."id", "o"."slug", "o"."name", "o"."storage_used_gb", "o"."storage_quota_gb";


ALTER VIEW "public"."platform_organization_stats" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."platform_public_media_with_collections" AS
SELECT
    NULL::"uuid" AS "id",
    NULL::"uuid" AS "platform_organization_id",
    NULL::"text" AS "file_url",
    NULL::"text" AS "thumbnail_url",
    NULL::"text" AS "file_type",
    NULL::"text" AS "title",
    NULL::"text" AS "description",
    NULL::"text" AS "content_category",
    NULL::"text" AS "content_subcategory",
    NULL::"text"[] AS "manual_tags",
    NULL::"text"[] AS "impact_themes",
    NULL::"text" AS "photographer",
    NULL::"date" AS "capture_date",
    NULL::timestamp with time zone AS "created_at",
    NULL::"text" AS "organization_slug",
    NULL::"text" AS "organization_name",
    NULL::json AS "collections";


ALTER VIEW "public"."platform_public_media_with_collections" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."portraits" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "image_url" "text" NOT NULL,
    "name" "text",
    "storyteller_id" "text" NOT NULL,
    "visible" boolean DEFAULT true NOT NULL,
    "views" integer DEFAULT 0 NOT NULL,
    "clicks" integer DEFAULT 0 NOT NULL,
    "rotation" double precision DEFAULT 0 NOT NULL,
    "offset_x" double precision DEFAULT 0 NOT NULL,
    "offset_y" double precision DEFAULT 0 NOT NULL,
    "access_code" "text" DEFAULT "substr"("md5"(("random"())::"text"), 0, 8) NOT NULL
);


ALTER TABLE "public"."portraits" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."privacy_audit_log" (
    "id" bigint NOT NULL,
    "tenant_id" "text",
    "occurred_at" timestamp with time zone DEFAULT "now"(),
    "actor" "text",
    "method" "text",
    "path" "text",
    "resource" "text",
    "ip" "text",
    "status" integer,
    "query" "jsonb",
    "body" "jsonb"
);


ALTER TABLE "public"."privacy_audit_log" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."privacy_audit_log_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."privacy_audit_log_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."privacy_audit_log_id_seq" OWNED BY "public"."privacy_audit_log"."id";



CREATE TABLE IF NOT EXISTS "public"."privacy_dsr_requests" (
    "id" bigint NOT NULL,
    "tenant_id" "text",
    "subject_identifier" "text" NOT NULL,
    "type" "text" NOT NULL,
    "status" "text" DEFAULT 'received'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    "notes" "text",
    CONSTRAINT "privacy_dsr_requests_status_check" CHECK (("status" = ANY (ARRAY['received'::"text", 'processing'::"text", 'completed'::"text", 'rejected'::"text"]))),
    CONSTRAINT "privacy_dsr_requests_type_check" CHECK (("type" = ANY (ARRAY['export'::"text", 'delete'::"text"])))
);


ALTER TABLE "public"."privacy_dsr_requests" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."privacy_dsr_requests_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."privacy_dsr_requests_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."privacy_dsr_requests_id_seq" OWNED BY "public"."privacy_dsr_requests"."id";



CREATE TABLE IF NOT EXISTS "public"."privacy_settings" (
    "tenant_id" "text" NOT NULL,
    "analytics_consent" boolean DEFAULT true,
    "email_processing_consent" boolean DEFAULT true,
    "data_sharing_consent" boolean DEFAULT false,
    "retention_days" integer DEFAULT 365,
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "consent_version" integer DEFAULT 1,
    "consent_expires_at" timestamp with time zone,
    "policy_ref" "text"
);


ALTER TABLE "public"."privacy_settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."processing_jobs" (
    "transcript_id" "uuid",
    "status" character varying(20),
    "progress_percentage" integer,
    "current_step" character varying(100),
    "estimated_completion" timestamp without time zone
);


ALTER TABLE "public"."processing_jobs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."profile_appearances" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "empathy_ledger_profile_id" "uuid" NOT NULL,
    "appears_on_type" "text" NOT NULL,
    "appears_on_id" "uuid" NOT NULL,
    "role" "text",
    "story_excerpt" "text",
    "featured" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "public_profile_id" "uuid",
    CONSTRAINT "profile_appearances_appears_on_type_check" CHECK (("appears_on_type" = ANY (ARRAY['program'::"text", 'service'::"text", 'article'::"text"])))
);


ALTER TABLE "public"."profile_appearances" OWNER TO "postgres";


COMMENT ON TABLE "public"."profile_appearances" IS 'Links Empathy Ledger profiles to JusticeHub programs, services, and articles';



COMMENT ON COLUMN "public"."profile_appearances"."empathy_ledger_profile_id" IS 'UUID of profile in Empathy Ledger database';



COMMENT ON COLUMN "public"."profile_appearances"."appears_on_type" IS 'Type of content: program, service, or article';



COMMENT ON COLUMN "public"."profile_appearances"."appears_on_id" IS 'ID of the program, service, or article';



COMMENT ON COLUMN "public"."profile_appearances"."role" IS 'Person''s role: participant, facilitator, family member, etc.';



COMMENT ON COLUMN "public"."profile_appearances"."story_excerpt" IS 'Brief excerpt from their story for preview';



COMMENT ON COLUMN "public"."profile_appearances"."featured" IS 'Whether this should be featured prominently';



CREATE TABLE IF NOT EXISTS "public"."profile_sync_log" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "public_profile_id" "uuid",
    "empathy_ledger_profile_id" "uuid",
    "sync_action" "text" NOT NULL,
    "sync_status" "text" NOT NULL,
    "sync_details" "jsonb",
    "error_message" "text",
    "synced_at" timestamp without time zone DEFAULT "now"()
);


ALTER TABLE "public"."profile_sync_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."profiles" (
    "id" "uuid" NOT NULL,
    "email" "text",
    "full_name" "text",
    "display_name" "text",
    "bio" "text",
    "role" "text" DEFAULT 'user'::"text",
    "permissions" "text"[] DEFAULT '{}'::"text"[],
    "primary_organization_id" "uuid",
    "language_preference" "text" DEFAULT 'en'::"text",
    "timezone" "text" DEFAULT 'UTC'::"text",
    "notification_preferences" "jsonb" DEFAULT '{}'::"jsonb",
    "privacy_preferences" "jsonb" DEFAULT '{}'::"jsonb",
    "account_status" "text" DEFAULT 'active'::"text",
    "email_verified" boolean DEFAULT false,
    "terms_accepted_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_super_admin" boolean DEFAULT false,
    CONSTRAINT "profiles_account_status_check" CHECK (("account_status" = ANY (ARRAY['active'::"text", 'suspended'::"text", 'archived'::"text"]))),
    CONSTRAINT "profiles_role_check" CHECK (("role" = ANY (ARRAY['user'::"text", 'storyteller'::"text", 'staff'::"text", 'admin'::"text", 'super_admin'::"text"])))
);


ALTER TABLE "public"."profiles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."program_outcomes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "program_id" "uuid",
    "outcome_type" "text" NOT NULL,
    "metric_name" "text" NOT NULL,
    "value" "text" NOT NULL,
    "comparison_value" "text",
    "timeframe" "text",
    "sample_size" integer,
    "source" "text",
    "source_year" integer,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."program_outcomes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."program_visits" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "program_id" "uuid",
    "visit_type" "text" NOT NULL,
    "visit_date" "date" NOT NULL,
    "participants" "text"[],
    "organizations" "text"[],
    "purpose" "text",
    "outcomes" "text",
    "follow_up_actions" "text",
    "documents" "jsonb" DEFAULT '[]'::"jsonb",
    "photos" "jsonb" DEFAULT '[]'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "program_visits_visit_type_check" CHECK (("visit_type" = ANY (ARRAY['in_person'::"text", 'virtual'::"text", 'conference'::"text", 'exchange'::"text"])))
);


ALTER TABLE "public"."program_visits" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_activity_summary" (
    "project_id" "uuid" NOT NULL,
    "notion_edit_minutes" numeric DEFAULT 0,
    "notion_edit_count" integer DEFAULT 0,
    "calendar_meeting_minutes" numeric DEFAULT 0,
    "calendar_meeting_count" integer DEFAULT 0,
    "gmail_thread_count" integer DEFAULT 0,
    "gmail_recent_contacts" "jsonb" DEFAULT '[]'::"jsonb",
    "last_notation_activity" timestamp with time zone,
    "last_calendar_activity" timestamp with time zone,
    "last_gmail_activity" timestamp with time zone,
    "last_synced" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."project_activity_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_contact_alignment" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "project_id" "uuid" NOT NULL,
    "contact_id" "uuid" NOT NULL,
    "alignment_score" numeric(5,2) DEFAULT 50 NOT NULL,
    "confidence" integer DEFAULT 70,
    "shared_themes" "text"[] DEFAULT '{}'::"text"[],
    "contact_context" "jsonb" DEFAULT '{}'::"jsonb",
    "project_context" "jsonb" DEFAULT '{}'::"jsonb",
    "outreach_recommendation" "jsonb" DEFAULT '{}'::"jsonb",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "project_contact_alignment_confidence_check" CHECK ((("confidence" >= 0) AND ("confidence" <= 100)))
);


ALTER TABLE "public"."project_contact_alignment" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_contact_matches" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "contact_id" "uuid",
    "person_id" "uuid",
    "project_notion_id" "text" NOT NULL,
    "project_name" "text" NOT NULL,
    "project_source" "text" NOT NULL,
    "alignment_score" integer,
    "matched_keywords" "text"[],
    "match_reason" "text",
    "alma_intervention_id" "uuid",
    "alma_signal_boost" integer DEFAULT 0,
    "engagement_status" "text" DEFAULT 'potential'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "project_contact_matches_alignment_score_check" CHECK ((("alignment_score" >= 0) AND ("alignment_score" <= 100))),
    CONSTRAINT "project_contact_matches_check" CHECK ((("contact_id" IS NOT NULL) OR ("person_id" IS NOT NULL))),
    CONSTRAINT "project_contact_matches_engagement_status_check" CHECK (("engagement_status" = ANY (ARRAY['potential'::"text", 'contacted'::"text", 'active'::"text", 'obsolete'::"text"]))),
    CONSTRAINT "project_contact_matches_project_source_check" CHECK (("project_source" = ANY (ARRAY['placemat'::"text", 'justicehub'::"text", 'farm'::"text", 'empathy_ledger'::"text", 'intelligence_hub'::"text"])))
);


ALTER TABLE "public"."project_contact_matches" OWNER TO "postgres";


COMMENT ON TABLE "public"."project_contact_matches" IS 'Universal project-contact matching table that works across ALL ACT systems:
Placemat, JusticeHub (ALMA), Empathy Ledger, The Farm, Intelligence Hub.
Links enriched contacts to any ACT project using Notion project ID as universal reference.';



COMMENT ON COLUMN "public"."project_contact_matches"."project_source" IS 'Identifies which ACT system owns the project:
- placemat: ACT Placemat projects
- justicehub: JusticeHub / ALMA interventions
- farm: The Farm incubation projects
- empathy_ledger: Empathy Ledger story projects
- intelligence_hub: Intelligence Hub knowledge projects';



COMMENT ON COLUMN "public"."project_contact_matches"."alma_intervention_id" IS 'If project_source = "justicehub", this references the ALMA intervention (alma_interventions.id).
ALMA signal boost field contains additional scoring from ALMA portfolio analytics.';



CREATE TABLE IF NOT EXISTS "public"."project_contributions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_id" "uuid" NOT NULL,
    "contributor_id" "uuid",
    "contributor_type" "text" NOT NULL,
    "contribution_type" "text" NOT NULL,
    "contribution_description" "text",
    "contribution_value" "jsonb" DEFAULT '{}'::"jsonb",
    "skills_contributed" "jsonb" DEFAULT '[]'::"jsonb",
    "expertise_areas" "jsonb" DEFAULT '[]'::"jsonb",
    "linked_outcomes" "jsonb" DEFAULT '[]'::"jsonb",
    "impact_description" "text",
    "public_recognition" boolean DEFAULT false,
    "attribution_preferences" "jsonb" DEFAULT '{}'::"jsonb",
    "contribution_start_date" "date",
    "contribution_end_date" "date",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "valid_contribution_type" CHECK (("contribution_type" = ANY (ARRAY['time'::"text", 'expertise'::"text", 'funding'::"text", 'resources'::"text", 'advocacy'::"text", 'story'::"text"]))),
    CONSTRAINT "valid_contributor_type" CHECK (("contributor_type" = ANY (ARRAY['individual'::"text", 'organization'::"text", 'community'::"text", 'anonymous'::"text"])))
);


ALTER TABLE "public"."project_contributions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_health" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_code" "text" NOT NULL,
    "project_name" "text",
    "overall_score" integer DEFAULT 50,
    "momentum_score" integer,
    "engagement_score" integer,
    "financial_score" integer,
    "timeline_score" integer,
    "health_status" "text" DEFAULT 'healthy'::"text",
    "metrics" "jsonb" DEFAULT '{}'::"jsonb",
    "alerts" "jsonb" DEFAULT '[]'::"jsonb",
    "calculated_at" timestamp with time zone DEFAULT "now"(),
    "calculation_version" "text" DEFAULT '1.0'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "project_health_engagement_score_check" CHECK ((("engagement_score" >= 0) AND ("engagement_score" <= 100))),
    CONSTRAINT "project_health_financial_score_check" CHECK ((("financial_score" >= 0) AND ("financial_score" <= 100))),
    CONSTRAINT "project_health_health_status_check" CHECK (("health_status" = ANY (ARRAY['thriving'::"text", 'healthy'::"text", 'attention'::"text", 'critical'::"text", 'dormant'::"text"]))),
    CONSTRAINT "project_health_momentum_score_check" CHECK ((("momentum_score" >= 0) AND ("momentum_score" <= 100))),
    CONSTRAINT "project_health_overall_score_check" CHECK ((("overall_score" >= 0) AND ("overall_score" <= 100))),
    CONSTRAINT "project_health_timeline_score_check" CHECK ((("timeline_score" >= 0) AND ("timeline_score" <= 100)))
);


ALTER TABLE "public"."project_health" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_health_analysis" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "project_id" "uuid" NOT NULL,
    "health_score" integer NOT NULL,
    "risks" "text"[] DEFAULT '{}'::"text"[],
    "opportunities" "text"[] DEFAULT '{}'::"text"[],
    "recommendations" "text"[] DEFAULT '{}'::"text"[],
    "analysis_date" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "project_health_analysis_health_score_check" CHECK ((("health_score" >= 0) AND ("health_score" <= 100)))
);


ALTER TABLE "public"."project_health_analysis" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_health_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_id" "uuid",
    "notion_project_id" "text",
    "recorded_at" timestamp with time zone DEFAULT "now"(),
    "health_score" numeric,
    "urgency_score" numeric,
    "critical_factors" "text"[] DEFAULT ARRAY[]::"text"[],
    "status" "text",
    "notes" "text",
    "raw_payload" "jsonb"
);


ALTER TABLE "public"."project_health_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_outcomes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_id" "uuid" NOT NULL,
    "outcome_type" "text" NOT NULL,
    "outcome_category" "text" NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "baseline_data" "jsonb" DEFAULT '{}'::"jsonb",
    "target_metrics" "jsonb" DEFAULT '{}'::"jsonb",
    "current_metrics" "jsonb" DEFAULT '{}'::"jsonb",
    "final_metrics" "jsonb" DEFAULT '{}'::"jsonb",
    "direct_beneficiaries" "jsonb" DEFAULT '{}'::"jsonb",
    "indirect_beneficiaries" "jsonb" DEFAULT '{}'::"jsonb",
    "geographic_impact" "jsonb" DEFAULT '{}'::"jsonb",
    "temporal_impact" "jsonb" DEFAULT '{}'::"jsonb",
    "measurement_methodology" "text",
    "data_sources" "jsonb" DEFAULT '[]'::"jsonb",
    "verification_status" "text" DEFAULT 'unverified'::"text",
    "verified_by" "uuid",
    "verification_notes" "text",
    "verification_date" timestamp with time zone,
    "contributing_organizations" "jsonb" DEFAULT '[]'::"jsonb",
    "community_attribution" "jsonb" DEFAULT '{}'::"jsonb",
    "individual_attribution" "jsonb" DEFAULT '[]'::"jsonb",
    "report_url" "text",
    "media_assets" "jsonb" DEFAULT '[]'::"jsonb",
    "public_visibility" boolean DEFAULT true,
    "featured" boolean DEFAULT false,
    "outcome_period_start" "date",
    "outcome_period_end" "date",
    "measurement_frequency" "text" DEFAULT 'milestone'::"text",
    "status" "text" DEFAULT 'in_progress'::"text",
    "confidence_level" "text" DEFAULT 'medium'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "reported_by" "uuid",
    CONSTRAINT "valid_confidence" CHECK (("confidence_level" = ANY (ARRAY['high'::"text", 'medium'::"text", 'low'::"text"]))),
    CONSTRAINT "valid_outcome_category" CHECK (("outcome_category" = ANY (ARRAY['quantitative'::"text", 'qualitative'::"text", 'narrative'::"text", 'mixed'::"text"]))),
    CONSTRAINT "valid_status" CHECK (("status" = ANY (ARRAY['planned'::"text", 'in_progress'::"text", 'achieved'::"text", 'exceeded'::"text", 'partially_achieved'::"text", 'not_achieved'::"text"]))),
    CONSTRAINT "valid_verification_status" CHECK (("verification_status" = ANY (ARRAY['unverified'::"text", 'in_review'::"text", 'verified'::"text", 'disputed'::"text"])))
);


ALTER TABLE "public"."project_outcomes" OWNER TO "postgres";


COMMENT ON TABLE "public"."project_outcomes" IS 'Detailed tracking of project outcomes and impact metrics';



CREATE TABLE IF NOT EXISTS "public"."projects" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "organization_id" "uuid",
    "location" "text",
    "status" "text" DEFAULT 'active'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "archived" boolean DEFAULT false NOT NULL,
    "end_date" "date",
    "notion_id" "text",
    "notion_project_id" "text",
    "summary" "text"
);


ALTER TABLE "public"."projects" OWNER TO "postgres";


COMMENT ON TABLE "public"."projects" IS 'Projects within organizations - location-based groupings';



CREATE OR REPLACE VIEW "public"."project_impact_summary" AS
 SELECT "p"."id" AS "project_id",
    "p"."name" AS "project_name",
    "p"."status" AS "project_status",
    "count"(DISTINCT "po"."id") AS "total_outcomes",
    "count"(DISTINCT "po"."id") FILTER (WHERE ("po"."verification_status" = 'verified'::"text")) AS "verified_outcomes",
    "count"(DISTINCT "pc"."id") AS "total_contributions",
    "count"(DISTINCT "pc"."contributor_id") AS "unique_contributors",
    COALESCE("sum"((("po"."current_metrics" ->> 'beneficiaries'::"text"))::integer), (0)::bigint) AS "total_beneficiaries",
    "max"("po"."updated_at") AS "last_outcome_update"
   FROM (("public"."projects" "p"
     LEFT JOIN "public"."project_outcomes" "po" ON (("p"."id" = "po"."project_id")))
     LEFT JOIN "public"."project_contributions" "pc" ON (("p"."id" = "pc"."project_id")))
  GROUP BY "p"."id", "p"."name", "p"."status";


ALTER VIEW "public"."project_impact_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_intelligence" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "project_id" "uuid" NOT NULL,
    "notion_page_id" "text",
    "project_name" "text" NOT NULL,
    "summary" "text",
    "focus_areas" "text"[] DEFAULT '{}'::"text"[],
    "communities" "text"[] DEFAULT '{}'::"text"[],
    "strategic_alignment" "text"[] DEFAULT '{}'::"text"[],
    "required_support" "text"[] DEFAULT '{}'::"text"[],
    "partner_targets" "text"[] DEFAULT '{}'::"text"[],
    "risk_level" "text" DEFAULT 'unknown'::"text",
    "readiness_score" integer DEFAULT 60,
    "intelligence" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "embedding" real[] DEFAULT '{}'::real[],
    "last_synced_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "project_intelligence_readiness_score_check" CHECK ((("readiness_score" >= 0) AND ("readiness_score" <= 100)))
);


ALTER TABLE "public"."project_intelligence" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_knowledge" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_code" "text" NOT NULL,
    "project_name" "text",
    "knowledge_type" "text" NOT NULL,
    "title" "text",
    "content" "text",
    "source_type" "text",
    "source_ref" "text",
    "source_url" "text",
    "voice_note_id" "uuid",
    "communication_id" "uuid",
    "recorded_by" "text" DEFAULT 'ben'::"text",
    "recorded_at" timestamp with time zone DEFAULT "now"(),
    "participants" "text"[],
    "contact_ids" "text"[],
    "summary" "text",
    "topics" "text"[],
    "sentiment" "text",
    "importance" "text" DEFAULT 'normal'::"text",
    "action_required" boolean DEFAULT false,
    "action_items" "jsonb",
    "follow_up_date" "date",
    "decision_status" "text",
    "decision_rationale" "text",
    "embedding" "public"."vector"(384),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."project_knowledge" OWNER TO "postgres";


COMMENT ON TABLE "public"."project_knowledge" IS 'Unified catch-all for project-related knowledge, reflections, decisions, and context';



COMMENT ON COLUMN "public"."project_knowledge"."project_code" IS 'Project code from config/project-codes.json (e.g., ACT-HV, ACT-JH)';



COMMENT ON COLUMN "public"."project_knowledge"."knowledge_type" IS 'Type: reflection, decision, meeting, voice_note, document, event, question, link, communication, milestone';



COMMENT ON COLUMN "public"."project_knowledge"."embedding" IS 'Vector embedding for semantic search (384 dimensions)';



CREATE TABLE IF NOT EXISTS "public"."project_media_links" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "media_id" "uuid" NOT NULL,
    "link_type" "text" NOT NULL,
    "link_id" "text" NOT NULL,
    "display_order" integer DEFAULT 0,
    "caption" "text",
    "alt_text" "text",
    "is_hero" boolean DEFAULT false,
    "is_featured" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "project_media_links_link_type_check" CHECK (("link_type" = ANY (ARRAY['project_page'::"text", 'blog_post'::"text", 'gallery'::"text", 'timeline_entry'::"text", 'hero'::"text"])))
);


ALTER TABLE "public"."project_media_links" OWNER TO "postgres";


COMMENT ON TABLE "public"."project_media_links" IS 'Polymorphic links between media and various content entities';



CREATE TABLE IF NOT EXISTS "public"."project_outcome_updates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_outcome_id" "uuid" NOT NULL,
    "update_type" "text" NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "metric_updates" "jsonb" DEFAULT '{}'::"jsonb",
    "evidence_data" "jsonb" DEFAULT '{}'::"jsonb",
    "attachments" "jsonb" DEFAULT '[]'::"jsonb",
    "reported_by" "uuid" NOT NULL,
    "data_collection_method" "text",
    "validation_notes" "text",
    "report_date" "date" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "valid_update_type" CHECK (("update_type" = ANY (ARRAY['measurement'::"text", 'milestone'::"text", 'correction'::"text", 'verification'::"text", 'final'::"text"])))
);


ALTER TABLE "public"."project_outcome_updates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_pairings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_id" "uuid" NOT NULL,
    "partner_project_id" "uuid" NOT NULL,
    "reason" "text",
    "similarity" numeric,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."project_pairings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_research" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_id" "uuid" NOT NULL,
    "source" "text" NOT NULL,
    "url" "text",
    "summary" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."project_research" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_support_graph" (
    "project_id" "uuid" NOT NULL,
    "notion_project_id" "text",
    "project_name" "text",
    "project_status" "text",
    "urgency_score" numeric,
    "funding_gap" numeric,
    "upcoming_milestone" "date",
    "supporters" "jsonb" DEFAULT '[]'::"jsonb",
    "keyword_highlights" "text"[] DEFAULT ARRAY[]::"text"[],
    "last_calculated" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."project_support_graph" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."project_support_overview" AS
 SELECT "psg"."project_id",
    "psg"."project_name",
    "psg"."project_status",
    "psg"."urgency_score",
    "psg"."funding_gap",
    "psg"."upcoming_milestone",
    "jsonb_array_length"("psg"."supporters") AS "supporter_slots",
    "fps"."total_actual",
    "fps"."total_potential",
    "fps"."concentration_risk",
    "fps"."last_updated" AS "financial_last_updated"
   FROM ("public"."project_support_graph" "psg"
     LEFT JOIN "public"."financial_project_summaries" "fps" ON (("fps"."project_id" = "psg"."project_id")));


ALTER VIEW "public"."project_support_overview" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_updates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_id" "text" NOT NULL,
    "project_name" "text" NOT NULL,
    "update_type" "text" DEFAULT 'update'::"text",
    "content" "text" NOT NULL,
    "author" "text" DEFAULT 'ben'::"text",
    "tags" "text"[] DEFAULT '{}'::"text"[],
    "notion_synced" boolean DEFAULT false,
    "notion_page_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."project_updates" OWNER TO "postgres";


COMMENT ON TABLE "public"."project_updates" IS 'Project updates and milestones tracked by ACT Studio Bot';



CREATE OR REPLACE VIEW "public"."public_media_with_collections" AS
 SELECT "m"."id",
    "m"."file_url",
    "m"."file_type",
    "m"."title",
    "m"."description",
    "m"."alt_text",
    "m"."thumbnail_url",
    "m"."manual_tags",
    "m"."impact_themes",
    "m"."photographer",
    "m"."capture_date",
    COALESCE("json_agg"("json_build_object"('collection_id', "c"."id", 'collection_name', "c"."name", 'collection_type', "c"."type")) FILTER (WHERE ("c"."id" IS NOT NULL)), '[]'::json) AS "collections"
   FROM (("public"."media_items" "m"
     LEFT JOIN "public"."collection_media" "cm" ON (("m"."id" = "cm"."media_id")))
     LEFT JOIN "public"."media_collections" "c" ON ((("cm"."collection_id" = "c"."id") AND ("c"."public_visible" = true))))
  WHERE (("m"."community_approved" = true) AND ("m"."consent_verified" = true))
  GROUP BY "m"."id", "m"."file_url", "m"."file_type", "m"."title", "m"."description", "m"."alt_text", "m"."thumbnail_url", "m"."manual_tags", "m"."impact_themes", "m"."photographer", "m"."capture_date";


ALTER VIEW "public"."public_media_with_collections" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."public_profiles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "full_name" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "preferred_name" "text",
    "pronouns" "text",
    "bio" "text",
    "tagline" "text",
    "role_tags" "text"[] DEFAULT '{}'::"text"[],
    "photo_url" "text",
    "photo_credit" "text",
    "website_url" "text",
    "email" "text",
    "social_links" "jsonb" DEFAULT '{}'::"jsonb",
    "user_id" "uuid",
    "empathy_ledger_profile_id" "uuid",
    "is_featured" boolean DEFAULT false,
    "is_public" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "synced_from_empathy_ledger" boolean DEFAULT false,
    "sync_type" "text" DEFAULT 'manual'::"text",
    "last_synced_at" timestamp without time zone,
    "current_organization" "text",
    "location" "text"
);


ALTER TABLE "public"."public_profiles" OWNER TO "postgres";


COMMENT ON TABLE "public"."public_profiles" IS 'Central registry for public-facing people across all content types';



COMMENT ON COLUMN "public"."public_profiles"."user_id" IS 'Links to users table if person is also a platform user';



COMMENT ON COLUMN "public"."public_profiles"."empathy_ledger_profile_id" IS 'Links to Empathy Ledger profile if applicable';



COMMENT ON COLUMN "public"."public_profiles"."is_public" IS 'Privacy control - false hides profile from public view';



COMMENT ON COLUMN "public"."public_profiles"."current_organization" IS 'Current organization the person is affiliated with (synced from Empathy Ledger)';



COMMENT ON COLUMN "public"."public_profiles"."location" IS 'Geographic location (synced from Empathy Ledger for auto-linking to local programs)';



CREATE TABLE IF NOT EXISTS "public"."pulse_events" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "portrait_id" "uuid" NOT NULL,
    "event_type" "text" NOT NULL,
    "metadata" "jsonb",
    CONSTRAINT "pulse_events_event_type_check" CHECK (("event_type" = ANY (ARRAY['view'::"text", 'hover'::"text", 'click'::"text", 'message'::"text"])))
);


ALTER TABLE "public"."pulse_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."push_subscriptions" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "storyteller_id" "text" NOT NULL,
    "subscription" "jsonb" NOT NULL,
    "active" boolean DEFAULT true NOT NULL
);


ALTER TABLE "public"."push_subscriptions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."quotes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "story_id" "uuid",
    "transcript_id" "uuid",
    "storyteller_id" "uuid" NOT NULL,
    "quote_text" "text" NOT NULL,
    "context_before" "text",
    "context_after" "text",
    "extracted_by_ai" boolean DEFAULT false,
    "ai_confidence_score" numeric(3,2),
    "themes" "uuid"[] DEFAULT '{}'::"uuid"[],
    "emotional_tone" "text"[],
    "significance_score" numeric(3,2),
    "attribution_approved" boolean DEFAULT false,
    "storyteller_approved" boolean DEFAULT false,
    "usage_permissions" "text"[] DEFAULT '{}'::"text"[],
    "usage_count" integer DEFAULT 0,
    "last_used_at" timestamp with time zone,
    "quote_type" "text",
    "visibility" "text" DEFAULT 'private'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "quotes_check" CHECK (((("story_id" IS NOT NULL) AND ("transcript_id" IS NULL)) OR (("story_id" IS NULL) AND ("transcript_id" IS NOT NULL)))),
    CONSTRAINT "quotes_quote_type_check" CHECK (("quote_type" = ANY (ARRAY['wisdom'::"text", 'experience'::"text", 'insight'::"text", 'emotion'::"text", 'call_to_action'::"text", 'teaching'::"text"]))),
    CONSTRAINT "quotes_visibility_check" CHECK (("visibility" = ANY (ARRAY['private'::"text", 'organization'::"text", 'public'::"text"])))
);


ALTER TABLE "public"."quotes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."rd_activity_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "component" "text" NOT NULL,
    "hypothesis" "text" NOT NULL,
    "methodology" "text" NOT NULL,
    "success_metric" "text" NOT NULL,
    "findings" "text",
    "developer" "text" NOT NULL,
    "time_spent_hours" numeric(5,2),
    "category" "text",
    "status" "text" DEFAULT 'active'::"text",
    "started_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    "notion_page_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "rd_activity_log_category_check" CHECK (("category" = ANY (ARRAY['Software Development'::"text", 'AI Research'::"text", 'Data Analysis'::"text", 'Testing'::"text"]))),
    CONSTRAINT "rd_activity_log_status_check" CHECK (("status" = ANY (ARRAY['planning'::"text", 'active'::"text", 'complete'::"text", 'failed'::"text"])))
);


ALTER TABLE "public"."rd_activity_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."receipt_match_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "receipt_match_id" "uuid",
    "action" "text" NOT NULL,
    "previous_status" "text",
    "new_status" "text",
    "feedback" "text",
    "feedback_notes" "text",
    "triggered_by" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "receipt_match_history_action_check" CHECK (("action" = ANY (ARRAY['created'::"text", 'email_suggested'::"text", 'confidence_updated'::"text", 'resolved'::"text", 'deferred'::"text", 'no_receipt_marked'::"text", 'reopened'::"text"]))),
    CONSTRAINT "receipt_match_history_feedback_check" CHECK (("feedback" = ANY (ARRAY['correct'::"text", 'incorrect'::"text", 'partial'::"text", NULL::"text"])))
);


ALTER TABLE "public"."receipt_match_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."receipt_matches" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "source_type" "text" NOT NULL,
    "source_id" "text" NOT NULL,
    "vendor_name" "text",
    "amount" numeric(12,2) NOT NULL,
    "transaction_date" "date" NOT NULL,
    "category" "text",
    "description" "text",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "suggested_email_id" "uuid",
    "suggested_email_subject" "text",
    "suggested_email_from" "text",
    "suggested_email_date" timestamp with time zone,
    "match_confidence" integer,
    "match_reasons" "jsonb" DEFAULT '[]'::"jsonb",
    "resolved_at" timestamp with time zone,
    "resolved_by" "text",
    "resolution_notes" "text",
    "week_start" "date",
    "deferred_count" integer DEFAULT 0,
    "points_awarded" integer DEFAULT 0,
    "quick_resolve" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "receipt_matches_source_type_check" CHECK (("source_type" = ANY (ARRAY['invoice'::"text", 'transaction'::"text"]))),
    CONSTRAINT "receipt_matches_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'email_suggested'::"text", 'resolved'::"text", 'no_receipt_needed'::"text", 'deferred'::"text"])))
);


ALTER TABLE "public"."receipt_matches" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."receipt_reconciliation_weeks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "week_start" "date" NOT NULL,
    "week_end" "date" NOT NULL,
    "total_pending" integer DEFAULT 0,
    "resolved_count" integer DEFAULT 0,
    "no_receipt_count" integer DEFAULT 0,
    "deferred_count" integer DEFAULT 0,
    "total_amount_pending" numeric(12,2) DEFAULT 0,
    "total_amount_resolved" numeric(12,2) DEFAULT 0,
    "travel_count" integer DEFAULT 0,
    "subscription_count" integer DEFAULT 0,
    "other_count" integer DEFAULT 0,
    "average_resolve_time_hours" numeric(10,2),
    "quick_resolve_rate" numeric(5,2),
    "is_perfect_week" boolean DEFAULT false,
    "points_earned" integer DEFAULT 0,
    "bonuses_applied" "jsonb" DEFAULT '[]'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."receipt_reconciliation_weeks" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."receipt_weekly_summary" AS
 SELECT ("date_trunc"('week'::"text", ("transaction_date")::timestamp with time zone))::"date" AS "week_start",
    "count"(*) AS "total_transactions",
    "sum"("amount") AS "total_amount",
    "sum"(
        CASE
            WHEN ("receipt_status" = 'matched'::"text") THEN 1
            ELSE 0
        END) AS "matched",
    "sum"(
        CASE
            WHEN ("receipt_status" = 'missing'::"text") THEN 1
            ELSE 0
        END) AS "missing",
    "sum"(
        CASE
            WHEN ("receipt_status" = 'pending'::"text") THEN 1
            ELSE 0
        END) AS "pending",
    "sum"(
        CASE
            WHEN ("receipt_status" = 'not_required'::"text") THEN 1
            ELSE 0
        END) AS "not_required",
    "sum"(
        CASE
            WHEN ("receipt_status" = 'deferred'::"text") THEN 1
            ELSE 0
        END) AS "deferred"
   FROM "public"."receipt_status"
  WHERE ("transaction_date" >= (CURRENT_DATE - '90 days'::interval))
  GROUP BY ("date_trunc"('week'::"text", ("transaction_date")::timestamp with time zone))
  ORDER BY (("date_trunc"('week'::"text", ("transaction_date")::timestamp with time zone))::"date") DESC;


ALTER VIEW "public"."receipt_weekly_summary" OWNER TO "postgres";


COMMENT ON VIEW "public"."receipt_weekly_summary" IS 'Weekly receipt status summary for dashboard';



CREATE OR REPLACE VIEW "public"."recent_agent_activity" AS
 SELECT "ar"."request_id",
    "ar"."created_at",
    "ar"."source_agent",
    "sa"."name" AS "source_name",
    "ar"."target_agent",
    "ta"."name" AS "target_name",
    "ar"."action",
    "ar"."status",
    "ar"."duration_ms",
    "ar"."error_message"
   FROM (("public"."agent_requests" "ar"
     LEFT JOIN "public"."agent_registry" "sa" ON (("ar"."source_agent" = "sa"."agent_id")))
     LEFT JOIN "public"."agent_registry" "ta" ON (("ar"."target_agent" = "ta"."agent_id")))
  ORDER BY "ar"."created_at" DESC
 LIMIT 100;


ALTER VIEW "public"."recent_agent_activity" OWNER TO "postgres";


COMMENT ON VIEW "public"."recent_agent_activity" IS 'Last 100 inter-agent requests';



CREATE TABLE IF NOT EXISTS "public"."recommendation_outcomes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "recommendation_type" "text" NOT NULL,
    "entity_id" "text",
    "entity_type" "text",
    "recommended_action" "text" NOT NULL,
    "confidence_score" double precision DEFAULT 0.5,
    "recommended_at" timestamp with time zone DEFAULT "now"(),
    "acted_upon" boolean,
    "outcome" "text",
    "outcome_value" double precision,
    "outcome_date" timestamp with time zone,
    "feedback_notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."recommendation_outcomes" OWNER TO "postgres";


COMMENT ON TABLE "public"."recommendation_outcomes" IS 'Tracks AI recommendations and outcomes for continuous learning';



COMMENT ON COLUMN "public"."recommendation_outcomes"."recommendation_type" IS 'Type of recommendation: follow_up, outreach, priority_change, etc.';



COMMENT ON COLUMN "public"."recommendation_outcomes"."outcome" IS 'Result of the recommendation: success, failure, ignored, etc.';



COMMENT ON COLUMN "public"."recommendation_outcomes"."outcome_value" IS 'Numeric value of the outcome (e.g., revenue, engagement score)';



CREATE TABLE IF NOT EXISTS "public"."relationship_health" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ghl_contact_id" "text" NOT NULL,
    "temperature" integer,
    "last_temperature_change" integer,
    "temperature_trend" "text",
    "lcaa_stage" "text",
    "lcaa_stage_confidence" numeric(3,2),
    "total_touchpoints" integer DEFAULT 0,
    "inbound_count" integer DEFAULT 0,
    "outbound_count" integer DEFAULT 0,
    "avg_response_time_hours" numeric(10,2),
    "last_inbound_at" timestamp with time zone,
    "last_outbound_at" timestamp with time zone,
    "last_contact_at" timestamp with time zone,
    "days_since_contact" integer,
    "overall_sentiment" "text",
    "sentiment_history" "jsonb",
    "relationship_summary" "text",
    "suggested_actions" "text"[],
    "risk_flags" "text"[],
    "calculated_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "relationship_health_temperature_check" CHECK ((("temperature" >= 0) AND ("temperature" <= 100)))
);


ALTER TABLE "public"."relationship_health" OWNER TO "postgres";


COMMENT ON TABLE "public"."relationship_health" IS 'Relationship quality metrics derived from communications';



COMMENT ON COLUMN "public"."relationship_health"."temperature" IS 'Relationship warmth: 0=cold, 100=hot';



CREATE TABLE IF NOT EXISTS "public"."research_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "slug" "text" NOT NULL,
    "title" "text" NOT NULL,
    "authors" "text"[] DEFAULT '{}'::"text"[],
    "organization" "text" NOT NULL,
    "year" integer NOT NULL,
    "category" "public"."research_category" NOT NULL,
    "jurisdiction" "public"."research_jurisdiction" NOT NULL,
    "type" "public"."research_type" NOT NULL,
    "tags" "text"[] DEFAULT '{}'::"text"[],
    "summary" "text" NOT NULL,
    "key_findings" "text"[] DEFAULT '{}'::"text"[],
    "external_url" "text",
    "pdf_url" "text",
    "video_url" "text",
    "is_featured" boolean DEFAULT false,
    "is_active" boolean DEFAULT true,
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."research_items" OWNER TO "postgres";


COMMENT ON TABLE "public"."research_items" IS 'Seeded with 27 research items from research library page';



COMMENT ON COLUMN "public"."research_items"."authors" IS 'Array of author names';



COMMENT ON COLUMN "public"."research_items"."tags" IS 'Array of searchable tags';



COMMENT ON COLUMN "public"."research_items"."key_findings" IS 'Array of key research findings';



CREATE TABLE IF NOT EXISTS "public"."review_curated_entries" (
    "id" "text" NOT NULL,
    "year" integer DEFAULT 2025 NOT NULL,
    "date" timestamp with time zone NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "source" "text" DEFAULT 'manual'::"text" NOT NULL,
    "type" "text" DEFAULT 'milestone'::"text" NOT NULL,
    "tags" "text"[] DEFAULT '{}'::"text"[],
    "status" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "included" boolean DEFAULT true,
    "edited_title" "text",
    "edited_description" "text",
    "hero_image_url" "text",
    "hero_image_id" "text",
    "hero_image_alt" "text",
    "hero_video_url" "text",
    "hero_video_platform" "text",
    "hero_video_title" "text",
    "photos" "text"[] DEFAULT '{}'::"text"[],
    "has_project_page" boolean DEFAULT false,
    "project_slug" "text",
    "season_order" integer,
    "display_order" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."review_curated_entries" OWNER TO "postgres";


COMMENT ON TABLE "public"."review_curated_entries" IS 'Stores admin-curated timeline entries for Year in Review pages';



CREATE TABLE IF NOT EXISTS "public"."review_media_links" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "media_id" "uuid" NOT NULL,
    "link_type" "text" NOT NULL,
    "link_id" "text" NOT NULL,
    "display_order" integer DEFAULT 0,
    "caption" "text",
    "alt_text" "text",
    "is_hero" boolean DEFAULT false,
    "is_featured" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "review_media_links_link_type_check" CHECK (("link_type" = ANY (ARRAY['timeline_entry'::"text", 'review_project'::"text", 'content_block'::"text", 'season'::"text", 'hero'::"text"])))
);


ALTER TABLE "public"."review_media_links" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."review_projects" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "year" integer DEFAULT 2025 NOT NULL,
    "timeline_entry_id" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "title" "text" NOT NULL,
    "subtitle" "text",
    "hero_image_id" "uuid",
    "hero_video_url" "text",
    "hero_video_type" "text",
    "hero_caption" "text",
    "content_blocks" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "is_featured" boolean DEFAULT false,
    "featured_order" integer,
    "is_published" boolean DEFAULT false,
    "published_at" timestamp with time zone,
    "meta_title" "text",
    "meta_description" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "review_projects_hero_video_type_check" CHECK (("hero_video_type" = ANY (ARRAY['loom'::"text", 'youtube'::"text", 'vimeo'::"text", 'direct'::"text"])))
);


ALTER TABLE "public"."review_projects" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."review_videos" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "year" integer DEFAULT 2025 NOT NULL,
    "platform" "text" NOT NULL,
    "video_id" "text" NOT NULL,
    "embed_url" "text" NOT NULL,
    "thumbnail_url" "text",
    "title" "text",
    "description" "text",
    "duration_seconds" integer,
    "link_type" "text" NOT NULL,
    "link_id" "text",
    "display_order" integer DEFAULT 0,
    "is_featured" boolean DEFAULT false,
    "autoplay" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "review_videos_link_type_check" CHECK (("link_type" = ANY (ARRAY['timeline_entry'::"text", 'review_project'::"text", 'content_block'::"text", 'season'::"text", 'standalone'::"text"]))),
    CONSTRAINT "review_videos_platform_check" CHECK (("platform" = ANY (ARRAY['loom'::"text", 'youtube'::"text", 'vimeo'::"text", 'direct'::"text"])))
);


ALTER TABLE "public"."review_videos" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."review_year_settings" (
    "year" integer NOT NULL,
    "seasons" "jsonb" DEFAULT '[]'::"jsonb",
    "settings" "jsonb" DEFAULT '{}'::"jsonb",
    "last_updated" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."review_year_settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."role_taxonomy" (
    "id" "text" NOT NULL,
    "category" "text" NOT NULL,
    "display_name" "text" NOT NULL,
    "description" "text",
    "display_order" integer DEFAULT 0,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "role_taxonomy_category_check" CHECK (("category" = ANY (ARRAY['leadership'::"text", 'staff'::"text", 'community'::"text", 'supporting'::"text", 'content'::"text", 'testimonial'::"text"])))
);


ALTER TABLE "public"."role_taxonomy" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."scraped_services" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "organization_id" "uuid",
    "name" character varying(255) NOT NULL,
    "description" "text",
    "category" character varying(100),
    "subcategory" character varying(100),
    "eligibility_criteria" "text"[],
    "cost_structure" character varying(50),
    "availability_schedule" "jsonb",
    "contact_info" "jsonb",
    "outcomes_evidence" "text"[],
    "geographical_coverage" "jsonb",
    "target_demographics" "jsonb",
    "capacity_indicators" "jsonb",
    "confidence_score" numeric(3,2) NOT NULL,
    "source_url" "text",
    "extraction_timestamp" timestamp with time zone,
    "validation_status" character varying(20) DEFAULT 'pending'::character varying,
    "active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    "updated_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE "public"."scraped_services" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."scraping_metadata" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "organization_id" "uuid",
    "source_type" character varying(50) NOT NULL,
    "source_url" "text" NOT NULL,
    "discovery_method" character varying(50) NOT NULL,
    "extraction_method" character varying(50) NOT NULL,
    "scraping_timestamp" timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    "ai_processing_version" character varying(20) NOT NULL,
    "confidence_scores" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "validation_status" character varying(20) DEFAULT 'pending'::character varying,
    "data_lineage" "jsonb" DEFAULT '[]'::"jsonb",
    "quality_flags" "jsonb" DEFAULT '[]'::"jsonb",
    "last_updated" timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    "created_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE "public"."scraping_metadata" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."search_history" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "user_id" "text" DEFAULT 'anonymous'::"text",
    "query" "text" NOT NULL,
    "filters" "jsonb" DEFAULT '{}'::"jsonb",
    "results_count" integer DEFAULT 0,
    "search_timestamp" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."search_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."service_contacts" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "service_id" "uuid" NOT NULL,
    "contact_type" "text" DEFAULT 'general'::"text",
    "contact_name" "text",
    "phone" "text",
    "email" "text",
    "website" "text",
    "hours" "text",
    "is_primary" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "chk_contact_type" CHECK (("contact_type" = ANY (ARRAY['general'::"text", 'crisis'::"text", 'intake'::"text", 'admin'::"text", 'emergency'::"text", 'referral'::"text"])))
);


ALTER TABLE "public"."service_contacts" OWNER TO "postgres";


COMMENT ON TABLE "public"."service_contacts" IS 'Multiple contact points for services with different contact types';



CREATE TABLE IF NOT EXISTS "public"."service_locations" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "service_id" "uuid" NOT NULL,
    "location_name" "text",
    "street_address" "text",
    "locality" "text",
    "city" "text",
    "region" "text",
    "state" "text",
    "postcode" "text",
    "latitude" numeric(10,8),
    "longitude" numeric(11,8),
    "contact_phone" "text",
    "contact_email" "text",
    "operating_hours" "jsonb",
    "is_primary" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."service_locations" OWNER TO "postgres";


COMMENT ON TABLE "public"."service_locations" IS 'Multiple locations for services that operate in different places';



CREATE TABLE IF NOT EXISTS "public"."services" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "organization_id" "uuid",
    "name" character varying(255) NOT NULL,
    "description" "text",
    "category" character varying(100),
    "subcategory" character varying(100),
    "eligibility_criteria" "text"[],
    "cost_structure" character varying(50),
    "availability_schedule" "jsonb",
    "contact_info" "jsonb",
    "outcomes_evidence" "text"[],
    "geographical_coverage" "jsonb",
    "target_demographics" "jsonb",
    "capacity_indicators" "jsonb",
    "active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    "updated_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    "slug" "text",
    "program_type" "text",
    "service_category" "text"[] DEFAULT '{}'::"text"[],
    "delivery_method" "text"[] DEFAULT '{}'::"text"[],
    "capacity_total" integer,
    "capacity_current" integer DEFAULT 0,
    "is_accepting_referrals" boolean DEFAULT true,
    "cost" "text",
    "location_address" "text",
    "location_city" "text",
    "location_state" "text",
    "location_postcode" "text",
    "contact_phone" "text",
    "contact_email" "text",
    "website_url" "text",
    "success_rate" numeric(5,2),
    "is_featured" boolean DEFAULT false,
    "is_active" boolean DEFAULT true,
    "tags" "text"[] DEFAULT '{}'::"text"[],
    "operating_hours" "jsonb" DEFAULT '{}'::"jsonb",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "categories" "text"[] DEFAULT '{}'::"text"[],
    "keywords" "text"[] DEFAULT '{}'::"text"[],
    "target_age_min" integer,
    "target_age_max" integer,
    "youth_specific" boolean DEFAULT false,
    "indigenous_specific" boolean DEFAULT false,
    "gender_specific" "text"[] DEFAULT '{}'::"text"[],
    "languages_supported" "text"[] DEFAULT '{}'::"text"[],
    "accessibility_features" "text"[] DEFAULT '{}'::"text"[],
    "service_type" "text",
    "location_type" "text",
    "service_area" "text"[] DEFAULT '{}'::"text"[],
    "data_source" "text",
    "data_source_url" "text",
    "last_verified_at" timestamp with time zone,
    "verification_status" "text" DEFAULT 'unverified'::"text",
    "scrape_confidence_score" numeric(3,2),
    "last_scraped_at" timestamp with time zone,
    "waitlist_time_weeks" integer,
    "online_booking_url" "text",
    "latitude" numeric(10,8),
    "longitude" numeric(11,8),
    "project" "text" DEFAULT 'youth-justice-service-finder'::"text",
    "parent_service_id" "uuid",
    "location_latitude" numeric(10,8),
    "location_longitude" numeric(11,8),
    "location_geocoded_at" timestamp with time zone,
    "alma_intervention_id" "uuid",
    "infrastructure_type" "text",
    CONSTRAINT "chk_age_range" CHECK ((("target_age_min" IS NULL) OR ("target_age_max" IS NULL) OR ("target_age_min" <= "target_age_max"))),
    CONSTRAINT "chk_location_type" CHECK ((("location_type" IS NULL) OR ("location_type" = ANY (ARRAY['fixed'::"text", 'mobile'::"text", 'online'::"text", 'statewide'::"text", 'national'::"text"])))),
    CONSTRAINT "chk_scrape_confidence" CHECK ((("scrape_confidence_score" IS NULL) OR (("scrape_confidence_score" >= (0)::numeric) AND ("scrape_confidence_score" <= (1)::numeric)))),
    CONSTRAINT "chk_verification_status" CHECK (("verification_status" = ANY (ARRAY['verified'::"text", 'unverified'::"text", 'needs_review'::"text", 'rejected'::"text"])))
);


ALTER TABLE "public"."services" OWNER TO "postgres";


COMMENT ON TABLE "public"."services" IS 'Unified services table supporting both platform services and youth justice service finder';



COMMENT ON COLUMN "public"."services"."categories" IS 'Service categories: legal_aid, mental_health, housing, crisis_support, etc.';



COMMENT ON COLUMN "public"."services"."keywords" IS 'Search keywords for service discovery';



COMMENT ON COLUMN "public"."services"."youth_specific" IS 'Whether service is specifically designed for youth';



COMMENT ON COLUMN "public"."services"."indigenous_specific" IS 'Whether service is culturally specific for Indigenous youth';



COMMENT ON COLUMN "public"."services"."data_source_url" IS 'Original URL where service data was scraped from';



COMMENT ON COLUMN "public"."services"."verification_status" IS 'Manual verification status: verified, unverified, needs_review, rejected';



COMMENT ON COLUMN "public"."services"."scrape_confidence_score" IS 'AI confidence score for scraped data (0.00-1.00)';



COMMENT ON COLUMN "public"."services"."location_latitude" IS 'Latitude coordinate for map-based service discovery';



COMMENT ON COLUMN "public"."services"."location_longitude" IS 'Longitude coordinate for map-based service discovery';



COMMENT ON COLUMN "public"."services"."location_geocoded_at" IS 'Timestamp when coordinates were added/updated';



COMMENT ON COLUMN "public"."services"."alma_intervention_id" IS 'Hybrid linking: Services can optionally represent ALMA interventions';



COMMENT ON COLUMN "public"."services"."infrastructure_type" IS 'Type of youth justice infrastructure: detention_centre, youth_justice_centre, court, regional_office, community_service';



CREATE OR REPLACE VIEW "public"."services_complete" AS
 SELECT "s"."id",
    "s"."name",
    "s"."slug",
    "s"."description",
    "s"."categories",
    "s"."keywords",
    "s"."target_age_min" AS "minimum_age",
    "s"."target_age_max" AS "maximum_age",
        CASE
            WHEN (("s"."target_age_min" IS NOT NULL) OR ("s"."target_age_max" IS NOT NULL)) THEN "jsonb_build_object"('minimum', "s"."target_age_min", 'maximum', "s"."target_age_max")
            ELSE NULL::"jsonb"
        END AS "age_range",
    "s"."youth_specific",
    "s"."indigenous_specific",
    "s"."website_url" AS "url",
    "s"."is_active" AS "active",
    "s"."scrape_confidence_score" AS "score",
    "s"."latitude" AS "location_latitude",
    "s"."longitude" AS "location_longitude",
        CASE
            WHEN ("o"."id" IS NOT NULL) THEN "jsonb_build_object"('id', "o"."id", 'name', "o"."name", 'type', "o"."type", 'website', "o"."website")
            ELSE NULL::"jsonb"
        END AS "organization",
        CASE
            WHEN ("o"."id" IS NOT NULL) THEN "jsonb_build_object"('id', "o"."id", 'name', "o"."name", 'website', "o"."website")
            ELSE NULL::"jsonb"
        END AS "organizations",
        CASE
            WHEN (("s"."location_address" IS NOT NULL) OR ("s"."location_city" IS NOT NULL)) THEN "jsonb_build_object"('address', "s"."location_address", 'city', "s"."location_city", 'region', "s"."location_city", 'state', "s"."location_state", 'postcode', "s"."location_postcode")
            ELSE NULL::"jsonb"
        END AS "location",
    "jsonb_build_object"('phone', "s"."contact_phone", 'email', "s"."contact_email", 'website', "s"."website_url", 'hours', "s"."operating_hours") AS "contact",
    ( SELECT COALESCE("json_agg"("jsonb_build_object"('id', "sl"."id", 'street_address', "sl"."street_address", 'locality', "sl"."locality", 'region', "sl"."region", 'state', "sl"."state", 'postcode', "sl"."postcode", 'latitude', "sl"."latitude", 'longitude', "sl"."longitude") ORDER BY "sl"."is_primary" DESC, "sl"."location_name"), '[]'::json) AS "coalesce"
           FROM "public"."service_locations" "sl"
          WHERE ("sl"."service_id" = "s"."id")) AS "locations",
    ( SELECT COALESCE("json_agg"("jsonb_build_object"('id', "sc"."id", 'phone', "sc"."phone", 'email', "sc"."email", 'website', "sc"."website", 'hours', "sc"."hours") ORDER BY "sc"."is_primary" DESC, "sc"."contact_type"), '[]'::json) AS "coalesce"
           FROM "public"."service_contacts" "sc"
          WHERE ("sc"."service_id" = "s"."id")) AS "contacts",
    "s"."created_at",
    "s"."updated_at",
    "s"."last_scraped_at"
   FROM ("public"."services" "s"
     LEFT JOIN "public"."organizations" "o" ON (("s"."organization_id" = "o"."id")));


ALTER VIEW "public"."services_complete" OWNER TO "postgres";


COMMENT ON VIEW "public"."services_complete" IS 'Complete service data including coordinates for mapping';



CREATE TABLE IF NOT EXISTS "public"."services_profiles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "service_id" "uuid",
    "public_profile_id" "uuid",
    "role" "text" NOT NULL,
    "role_description" "text",
    "display_order" integer DEFAULT 0,
    "is_featured" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."services_profiles" OWNER TO "postgres";


COMMENT ON TABLE "public"."services_profiles" IS 'Links people to services';



CREATE OR REPLACE VIEW "public"."services_unified" AS
 SELECT "s"."id",
    "s"."name",
    "s"."slug",
    "s"."description",
    'services'::"text" AS "source_table",
    "s"."latitude",
    "s"."longitude",
    "s"."location_city" AS "city",
    "s"."location_state" AS "state",
    "s"."location_address" AS "address",
    "s"."location_postcode" AS "postcode",
    "s"."organization_id",
    ( SELECT "organizations"."name"
           FROM "public"."organizations"
          WHERE ("organizations"."id" = "s"."organization_id")) AS "organization_name",
    "s"."categories" AS "service_categories",
    "s"."service_type" AS "intervention_type",
    "s"."infrastructure_type",
    NULL::"text" AS "program_approach",
    "s"."tags",
    "s"."contact_phone" AS "phone",
    "s"."contact_email" AS "email",
    "s"."website_url" AS "website",
    COALESCE("s"."youth_specific", true) AS "youth_specific",
    COALESCE("s"."indigenous_specific", false) AS "indigenous_specific",
    COALESCE("s"."is_featured", false) AS "is_featured",
    COALESCE("s"."is_active", true) AS "is_active",
    "s"."success_rate",
    NULL::integer AS "participants_served",
    NULL::integer AS "years_operating",
    "ai"."evidence_level",
    "ai"."portfolio_score",
    "ai"."consent_level",
    "ai"."cultural_authority",
    "ai"."review_status" AS "alma_review_status",
    NULL::"text" AS "impact_summary",
    GREATEST("s"."updated_at", "ai"."updated_at") AS "updated_at",
    LEAST("s"."created_at", "ai"."created_at") AS "created_at",
    "s"."id" AS "service_id",
    NULL::"uuid" AS "registered_service_id",
    "s"."alma_intervention_id"
   FROM ("public"."services" "s"
     LEFT JOIN "public"."alma_interventions" "ai" ON (("s"."alma_intervention_id" = "ai"."id")))
  WHERE (COALESCE("s"."is_active", true) = true)
UNION ALL
 SELECT "rs"."id",
    "rs"."name",
    "lower"("replace"("rs"."name", ' '::"text", '-'::"text")) AS "slug",
    "rs"."description",
    'registered_services'::"text" AS "source_table",
    "rs"."latitude",
    "rs"."longitude",
    "rs"."location" AS "city",
    "rs"."state",
    NULL::"text" AS "address",
    NULL::"text" AS "postcode",
    "rs"."organization_id",
    "rs"."organization" AS "organization_name",
    "rs"."tags" AS "service_categories",
    "ai"."type" AS "intervention_type",
    'community_service'::"text" AS "infrastructure_type",
    "rs"."approach" AS "program_approach",
    "rs"."tags",
    "rs"."contact_phone" AS "phone",
    "rs"."contact_email" AS "email",
    "rs"."website",
    true AS "youth_specific",
    COALESCE("rs"."indigenous_knowledge", false) AS "indigenous_specific",
    COALESCE("rs"."is_featured", false) AS "is_featured",
    true AS "is_active",
    ("rs"."success_rate")::numeric AS "success_rate",
    "rs"."participants_served",
    "rs"."years_operating",
    "ai"."evidence_level",
    "ai"."portfolio_score",
    "ai"."consent_level",
    "ai"."cultural_authority",
    "ai"."review_status" AS "alma_review_status",
    "rs"."impact_summary",
    GREATEST("rs"."updated_at", "ai"."updated_at") AS "updated_at",
    LEAST("rs"."created_at", "ai"."created_at") AS "created_at",
    "rs"."linked_service_id" AS "service_id",
    "rs"."id" AS "registered_service_id",
    "rs"."alma_intervention_id"
   FROM ("public"."registered_services" "rs"
     LEFT JOIN "public"."alma_interventions" "ai" ON (("rs"."alma_intervention_id" = "ai"."id")))
  WHERE (NOT (EXISTS ( SELECT 1
           FROM "public"."services" "s"
          WHERE ("lower"(TRIM(BOTH FROM "s"."name")) = "lower"(TRIM(BOTH FROM "rs"."name"))))))
UNION ALL
 SELECT "ai"."id",
    "ai"."name",
    "lower"("replace"("ai"."name", ' '::"text", '-'::"text")) AS "slug",
    "ai"."description",
    'alma_interventions'::"text" AS "source_table",
    "ai"."latitude",
    "ai"."longitude",
    NULL::"text" AS "city",
    "ai"."geography"[1] AS "state",
    NULL::"text" AS "address",
    NULL::"text" AS "postcode",
    "ai"."operating_organization_id" AS "organization_id",
    "ai"."operating_organization" AS "organization_name",
    NULL::"text"[] AS "service_categories",
    "ai"."type" AS "intervention_type",
    NULL::"text" AS "infrastructure_type",
    NULL::"text" AS "program_approach",
    NULL::"text"[] AS "tags",
    "ai"."contact_phone" AS "phone",
    "ai"."contact_email" AS "email",
    "ai"."website",
    true AS "youth_specific",
    false AS "indigenous_specific",
    false AS "is_featured",
    true AS "is_active",
    NULL::numeric AS "success_rate",
    NULL::integer AS "participants_served",
    "ai"."years_operating",
    "ai"."evidence_level",
    "ai"."portfolio_score",
    "ai"."consent_level",
    "ai"."cultural_authority",
    "ai"."review_status" AS "alma_review_status",
    NULL::"text" AS "impact_summary",
    "ai"."updated_at",
    "ai"."created_at",
    "ai"."linked_service_id" AS "service_id",
    "ai"."linked_community_program_id" AS "registered_service_id",
    "ai"."id" AS "alma_intervention_id"
   FROM "public"."alma_interventions" "ai"
  WHERE (("ai"."linked_service_id" IS NULL) AND (NOT (EXISTS ( SELECT 1
           FROM "public"."services" "s"
          WHERE ("lower"(TRIM(BOTH FROM "s"."name")) = "lower"(TRIM(BOTH FROM "ai"."name")))))) AND (NOT (EXISTS ( SELECT 1
           FROM "public"."registered_services" "rs"
          WHERE ("lower"(TRIM(BOTH FROM "rs"."name")) = "lower"(TRIM(BOTH FROM "ai"."name")))))));


ALTER VIEW "public"."services_unified" OWNER TO "postgres";


COMMENT ON VIEW "public"."services_unified" IS 'Unified view of all services, registered services (partners), and ALMA interventions. Services are primary source of truth.';



CREATE TABLE IF NOT EXISTS "public"."site_deployments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "site_id" "uuid" NOT NULL,
    "vercel_deployment_id" "text" NOT NULL,
    "status" "text" NOT NULL,
    "environment" "text" DEFAULT 'production'::"text",
    "git_commit_sha" "text",
    "git_commit_message" "text",
    "git_branch" "text",
    "build_duration_seconds" integer,
    "deployed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."site_deployments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."site_health_checks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "site_id" "uuid" NOT NULL,
    "checked_at" timestamp with time zone DEFAULT "now"(),
    "http_status" integer,
    "http_response_time_ms" integer,
    "http_error" "text",
    "ssl_valid" boolean,
    "ssl_expires_at" timestamp with time zone,
    "vercel_deployment_status" "text",
    "vercel_deployment_id" "text",
    "vercel_build_time_seconds" integer,
    "vercel_error" "text",
    "github_last_commit_at" timestamp with time zone,
    "github_last_commit_sha" "text",
    "github_open_prs" integer DEFAULT 0,
    "github_failed_checks" integer DEFAULT 0,
    "github_security_alerts" integer DEFAULT 0,
    "health_score" integer DEFAULT 0,
    "health_status" "text" DEFAULT 'unknown'::"text",
    "raw_data" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."site_health_checks" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."site_latest_health" AS
 SELECT DISTINCT ON ("shc"."site_id") "shc"."id",
    "shc"."site_id",
    "shc"."checked_at",
    "shc"."http_status",
    "shc"."http_response_time_ms",
    "shc"."http_error",
    "shc"."ssl_valid",
    "shc"."ssl_expires_at",
    "shc"."vercel_deployment_status",
    "shc"."vercel_deployment_id",
    "shc"."vercel_build_time_seconds",
    "shc"."vercel_error",
    "shc"."github_last_commit_at",
    "shc"."github_last_commit_sha",
    "shc"."github_open_prs",
    "shc"."github_failed_checks",
    "shc"."github_security_alerts",
    "shc"."health_score",
    "shc"."health_status",
    "shc"."raw_data",
    "es"."name" AS "site_name",
    "es"."slug" AS "site_slug",
    "es"."url" AS "site_url"
   FROM ("public"."site_health_checks" "shc"
     JOIN "public"."ecosystem_sites" "es" ON (("es"."id" = "shc"."site_id")))
  ORDER BY "shc"."site_id", "shc"."checked_at" DESC;


ALTER VIEW "public"."site_latest_health" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."skills_evidence" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "storyteller_id" "uuid",
    "skill_name" character varying(200) NOT NULL,
    "skill_category" "public"."skill_category_enum" NOT NULL,
    "proficiency_level" "public"."proficiency_level_enum",
    "evidence_quote" "text",
    "context_description" "text",
    "demonstration_examples" "jsonb",
    "ai_confidence_score" numeric(4,3),
    "human_validated" boolean DEFAULT false,
    "evidence_strength" "public"."evidence_strength_enum",
    "learning_stage" character varying(100),
    "teaching_potential" boolean DEFAULT false,
    "mentoring_capacity" boolean DEFAULT false,
    "community_value_score" numeric(3,2),
    "transferability_score" numeric(3,2),
    "innovation_factor" numeric(3,2),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."skills_evidence" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."sprint_snapshots" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "sprint_name" "text" NOT NULL,
    "sprint_number" integer,
    "sprint_start_date" "date",
    "sprint_end_date" "date",
    "snapshot_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "snapshot_time" timestamp with time zone DEFAULT "now"() NOT NULL,
    "total_issues" integer DEFAULT 0 NOT NULL,
    "todo_issues" integer DEFAULT 0 NOT NULL,
    "in_progress_issues" integer DEFAULT 0 NOT NULL,
    "done_issues" integer DEFAULT 0 NOT NULL,
    "blocked_issues" integer DEFAULT 0 NOT NULL,
    "completion_percentage" numeric(5,2) DEFAULT 0,
    "velocity" numeric(5,2),
    "ideal_remaining" integer,
    "actual_remaining" integer,
    "by_repository" "jsonb" DEFAULT '{}'::"jsonb",
    "by_type" "jsonb" DEFAULT '{}'::"jsonb",
    "by_priority" "jsonb" DEFAULT '{}'::"jsonb",
    "project_id" "text",
    "github_org" "text" DEFAULT 'Acurioustractor'::"text",
    "is_sprint_complete" boolean DEFAULT false,
    "is_final_snapshot" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "avg_cycle_time" numeric,
    "avg_lead_time" numeric,
    "throughput_per_week" numeric,
    "flow_efficiency" numeric,
    "blocked" integer,
    "in_progress" integer,
    "todo" integer,
    "wip_count" integer
);


ALTER TABLE "public"."sprint_snapshots" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stories" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "title" "text" NOT NULL,
    "content" "text" NOT NULL,
    "participant_name" "text" NOT NULL,
    "participant_age" integer,
    "location" "text",
    "date_recorded" "date",
    "themes" "text"[] DEFAULT ARRAY[]::"text"[],
    "impact_level" "text",
    "summary" "text",
    "transcript_id" "text",
    "is_published" boolean DEFAULT false,
    "tags" "text"[] DEFAULT ARRAY[]::"text"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "author_id" "text" DEFAULT 'anonymous'::"text",
    "excerpt" "text",
    "story_type" "text" DEFAULT 'personal'::"text",
    "visibility" "text" DEFAULT 'public'::"text",
    "published_at" timestamp with time zone,
    "is_featured" boolean DEFAULT false,
    "organization_id" "uuid",
    "status" "text" DEFAULT 'draft'::"text",
    "slug" "text",
    "featured_image_url" "text",
    "source_platform" "text" DEFAULT 'empathy_ledger'::"text",
    "public_profile_id" "uuid"
);


ALTER TABLE "public"."stories" OWNER TO "postgres";


COMMENT ON COLUMN "public"."stories"."author_id" IS 'DEPRECATED: Use public_profile_id instead. This column references auth.users but public_profile_id references public_profiles for consistent author attribution.';



COMMENT ON COLUMN "public"."stories"."public_profile_id" IS 'Links to public_profiles for author attribution. This is the preferred column for author references, replacing the deprecated author_id.';



CREATE TABLE IF NOT EXISTS "public"."story_analysis" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "story_id" "uuid" NOT NULL,
    "storyteller_id" "uuid" NOT NULL,
    "analysis_type" character varying(50) DEFAULT 'narrative_analysis'::character varying NOT NULL,
    "ai_model_used" character varying(100),
    "analysis_version" character varying(20) DEFAULT '1.0'::character varying,
    "results" "jsonb" DEFAULT '{}'::"jsonb",
    "narrative_score" numeric(3,2),
    "readability_score" numeric(3,2),
    "emotional_impact_score" numeric(3,2),
    "literary_themes" "text"[] DEFAULT '{}'::"text"[],
    "narrative_structure" character varying(50),
    "story_arc" character varying(50),
    "key_messages" "text"[] DEFAULT '{}'::"text"[],
    "story_quotes" "text"[] DEFAULT '{}'::"text"[],
    "story_summary" "text",
    "coherence_score" numeric(3,2),
    "engagement_score" numeric(3,2),
    "publication_ready" boolean DEFAULT false,
    "editorial_notes" "text",
    "processing_status" character varying(20) DEFAULT 'pending'::character varying,
    "processing_time_seconds" integer,
    "processing_notes" "jsonb" DEFAULT '{}'::"jsonb",
    "human_reviewed" boolean DEFAULT false,
    "reviewed_by" "uuid",
    "reviewed_at" timestamp with time zone,
    "review_notes" "text",
    "approved_for_publication" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "transcript_id" "uuid",
    CONSTRAINT "story_analysis_coherence_score_check" CHECK ((("coherence_score" >= (0)::numeric) AND ("coherence_score" <= (1)::numeric))),
    CONSTRAINT "story_analysis_emotional_impact_score_check" CHECK ((("emotional_impact_score" >= (0)::numeric) AND ("emotional_impact_score" <= (1)::numeric))),
    CONSTRAINT "story_analysis_engagement_score_check" CHECK ((("engagement_score" >= (0)::numeric) AND ("engagement_score" <= (1)::numeric))),
    CONSTRAINT "story_analysis_narrative_score_check" CHECK ((("narrative_score" >= (0)::numeric) AND ("narrative_score" <= (1)::numeric))),
    CONSTRAINT "story_analysis_processing_status_check1" CHECK ((("processing_status")::"text" = ANY ((ARRAY['pending'::character varying, 'processing'::character varying, 'completed'::character varying, 'failed'::character varying, 'requires_review'::character varying])::"text"[]))),
    CONSTRAINT "story_analysis_readability_score_check" CHECK ((("readability_score" >= (0)::numeric) AND ("readability_score" <= (1)::numeric)))
);


ALTER TABLE "public"."story_analysis" OWNER TO "postgres";


COMMENT ON TABLE "public"."story_analysis" IS 'AI analysis of finished story narratives - literary themes, story quality, publication readiness';



COMMENT ON COLUMN "public"."story_analysis"."story_id" IS 'References the finished story narrative';



COMMENT ON COLUMN "public"."story_analysis"."narrative_score" IS 'Quality of story structure and flow';



COMMENT ON COLUMN "public"."story_analysis"."literary_themes" IS 'Literary themes in the crafted story';



COMMENT ON COLUMN "public"."story_analysis"."story_quotes" IS 'Polished quotes from the finished story';



COMMENT ON COLUMN "public"."story_analysis"."publication_ready" IS 'Whether story meets publication standards';



CREATE TABLE IF NOT EXISTS "public"."story_attribution_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "storyteller_id" "uuid" NOT NULL,
    "event_type" "text" NOT NULL,
    "source_url" "text",
    "user_agent" "text",
    "referrer" "text",
    "session_id" "text" NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "timestamp" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "story_attribution_events_event_type_check" CHECK (("event_type" = ANY (ARRAY['view'::"text", 'share'::"text", 'profile_visit'::"text", 'card_expand'::"text", 'qr_scan'::"text", 'connection_request'::"text"])))
);


ALTER TABLE "public"."story_attribution_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."story_comments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "story_id" "uuid",
    "user_id" "text" NOT NULL,
    "content" "text" NOT NULL,
    "is_approved" boolean DEFAULT true,
    "like_count" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."story_comments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."story_reactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "story_id" "uuid",
    "user_id" "text" NOT NULL,
    "reaction_type" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "story_reactions_reaction_type_check" CHECK (("reaction_type" = ANY (ARRAY['like'::"text", 'heart'::"text", 'inspire'::"text", 'support'::"text", 'empathy'::"text"])))
);


ALTER TABLE "public"."story_reactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."story_related_art" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "story_id" "uuid",
    "art_innovation_id" "uuid",
    "relevance_note" "text",
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."story_related_art" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."story_related_interventions" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "story_id" "uuid" NOT NULL,
    "intervention_id" "uuid" NOT NULL,
    "relevance_note" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."story_related_interventions" OWNER TO "postgres";


COMMENT ON TABLE "public"."story_related_interventions" IS 'Links platform stories to ALMA interventions';



COMMENT ON COLUMN "public"."story_related_interventions"."relevance_note" IS 'Optional note explaining why this intervention is related to this story';



CREATE TABLE IF NOT EXISTS "public"."story_related_programs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "story_id" "uuid",
    "program_id" "uuid",
    "relevance_note" "text",
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."story_related_programs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."story_related_services" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "story_id" "uuid",
    "service_id" "uuid",
    "relevance_note" "text",
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."story_related_services" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."storyteller_ai_intelligence" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "storyteller_id" "uuid",
    "core_expertise_areas" "jsonb",
    "collaboration_style" "jsonb",
    "cultural_competency_level" "text",
    "innovation_indicators" "jsonb",
    "ideal_collaboration_profiles" "jsonb",
    "professional_growth_trajectory" "jsonb",
    "community_impact_potential" numeric(3,2),
    "narrative_authenticity_score" numeric(3,2),
    "professional_credibility_score" numeric(3,2),
    "story_engagement_quality" numeric(3,2),
    "aboriginal_protocol_adherence" numeric(3,2),
    "community_centered_approach" numeric(3,2),
    "cultural_sensitivity_indicators" "jsonb",
    "last_analysis_date" timestamp with time zone,
    "analysis_completeness" numeric(3,2),
    "requires_human_review" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."storyteller_ai_intelligence" OWNER TO "postgres";


COMMENT ON TABLE "public"."storyteller_ai_intelligence" IS 'AI-generated professional intelligence and collaboration analysis for storytellers';



COMMENT ON COLUMN "public"."storyteller_ai_intelligence"."core_expertise_areas" IS 'Array of expertise areas with confidence scores and evidence';



COMMENT ON COLUMN "public"."storyteller_ai_intelligence"."collaboration_style" IS 'Analysis of collaboration approach and ideal partners';



COMMENT ON COLUMN "public"."storyteller_ai_intelligence"."cultural_competency_level" IS 'Level of cultural competency: basic, intermediate, advanced, expert';



CREATE TABLE IF NOT EXISTS "public"."storyteller_connections" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "storyteller_a" "uuid",
    "storyteller_b" "uuid",
    "connection_type" "text" NOT NULL,
    "match_basis" "jsonb" DEFAULT '{}'::"jsonb",
    "strength_score" double precision,
    "status" "text" DEFAULT 'potential'::"text",
    "mutual_consent" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "storyteller_connections_status_check" CHECK (("status" = ANY (ARRAY['potential'::"text", 'introduced'::"text", 'connected'::"text", 'collaborating'::"text", 'inactive'::"text"]))),
    CONSTRAINT "storyteller_connections_strength_score_check" CHECK ((("strength_score" >= (0)::double precision) AND ("strength_score" <= (1)::double precision)))
);


ALTER TABLE "public"."storyteller_connections" OWNER TO "postgres";


COMMENT ON TABLE "public"."storyteller_connections" IS 'Organic connections between storytellers based on authentic compatibility';



CREATE TABLE IF NOT EXISTS "public"."storyteller_media" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "storyteller_id" "uuid",
    "type" "text" NOT NULL,
    "url" "text" NOT NULL,
    "thumbnail_url" "text",
    "title" "text" NOT NULL,
    "description" "text",
    "alt_text" "text",
    "file_size" bigint NOT NULL,
    "dimensions" "jsonb",
    "duration" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "cultural_protocol" "text" DEFAULT 'open'::"text" NOT NULL,
    "tags" "text"[] DEFAULT ARRAY[]::"text"[],
    "usage_rights" "text" DEFAULT 'full'::"text" NOT NULL,
    "associated_stories" "uuid"[] DEFAULT ARRAY[]::"uuid"[],
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "storyteller_media_cultural_protocol_check" CHECK (("cultural_protocol" = ANY (ARRAY['open'::"text", 'protected'::"text", 'sacred'::"text", 'restricted'::"text"]))),
    CONSTRAINT "storyteller_media_type_check" CHECK (("type" = ANY (ARRAY['photo'::"text", 'video'::"text", 'audio'::"text", 'document'::"text"]))),
    CONSTRAINT "storyteller_media_usage_rights_check" CHECK (("usage_rights" = ANY (ARRAY['full'::"text", 'limited'::"text", 'restricted'::"text"])))
);


ALTER TABLE "public"."storyteller_media" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."storyteller_videos" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "storyteller_id" "uuid",
    "url" "text" NOT NULL,
    "title" "text",
    "description" "text",
    "platform" "text",
    "video_id" "text",
    "thumbnail_url" "text",
    "duration" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."storyteller_videos" OWNER TO "postgres";


COMMENT ON TABLE "public"."storyteller_videos" IS 'Video links associated with storytellers for multimedia storytelling';



COMMENT ON COLUMN "public"."storyteller_videos"."platform" IS 'Video platform: youtube, vimeo, tiktok, instagram, other';



COMMENT ON COLUMN "public"."storyteller_videos"."video_id" IS 'Platform-specific video identifier';



COMMENT ON COLUMN "public"."storyteller_videos"."duration" IS 'Video duration in seconds';



CREATE TABLE IF NOT EXISTS "public"."storytellers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "full_name" "text" NOT NULL,
    "email" "text",
    "profile_image_url" "text",
    "bio" "text",
    "organization_id" "uuid",
    "project_id" "uuid",
    "location_id" "uuid",
    "consent_given" boolean DEFAULT false,
    "consent_date" timestamp with time zone,
    "privacy_preferences" "jsonb" DEFAULT '{"show_photo": false, "show_location": false, "public_display": false, "show_organization": false}'::"jsonb",
    "role" "text",
    "phone_number" "text",
    "cultural_background" "text",
    "preferred_pronouns" "text",
    "user_id" "uuid",
    "airtable_record_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "profile_image_file" "text",
    "transcript" "text",
    "media_url" "text",
    "media_type" "text",
    "vision_expressions" "text"[] DEFAULT '{}'::"text"[],
    "mission_statements" "text"[] DEFAULT '{}'::"text"[],
    "personal_goals" "text"[] DEFAULT '{}'::"text"[],
    "aspirations" "text"[] DEFAULT '{}'::"text"[],
    "skills_discovered" "jsonb" DEFAULT '{}'::"jsonb",
    "expertise_areas" "text"[] DEFAULT '{}'::"text"[],
    "knowledge_shared" "text"[] DEFAULT '{}'::"text"[],
    "capabilities_mentioned" "jsonb" DEFAULT '{}'::"jsonb",
    "community_roles" "text"[] DEFAULT '{}'::"text"[],
    "leadership_expressions" "text"[] DEFAULT '{}'::"text"[],
    "influence_areas" "text"[] DEFAULT '{}'::"text"[],
    "impact_stories" "jsonb"[] DEFAULT '{}'::"jsonb"[],
    "achievements_mentioned" "text"[] DEFAULT '{}'::"text"[],
    "outcomes_described" "text"[] DEFAULT '{}'::"text"[],
    "transformation_stories" "jsonb"[] DEFAULT '{}'::"jsonb"[],
    "key_insights" "text"[] DEFAULT '{}'::"text"[],
    "life_lessons" "text"[] DEFAULT '{}'::"text"[],
    "advice_given" "text"[] DEFAULT '{}'::"text"[],
    "philosophical_expressions" "text"[] DEFAULT '{}'::"text"[],
    "support_offered" "jsonb" DEFAULT '{}'::"jsonb",
    "resources_available" "text"[] DEFAULT '{}'::"text"[],
    "networks_accessible" "text"[] DEFAULT '{}'::"text"[],
    "assistance_types" "jsonb" DEFAULT '{}'::"jsonb",
    "support_needed" "jsonb" DEFAULT '{}'::"jsonb",
    "challenges_faced" "text"[] DEFAULT '{}'::"text"[],
    "learning_interests" "text"[] DEFAULT '{}'::"text"[],
    "growth_areas" "text"[] DEFAULT '{}'::"text"[],
    "organizations_mentioned" "jsonb"[] DEFAULT '{}'::"jsonb"[],
    "affiliations_expressed" "text"[] DEFAULT '{}'::"text"[],
    "partnerships_described" "text"[] DEFAULT '{}'::"text"[],
    "institutional_connections" "jsonb"[] DEFAULT '{}'::"jsonb"[],
    "geographic_connections" "text"[] DEFAULT '{}'::"text"[],
    "cultural_communities" "text"[] DEFAULT '{}'::"text"[],
    "language_communities" "text"[] DEFAULT '{}'::"text"[],
    "generational_connections" "text"[] DEFAULT '{}'::"text"[],
    "story_visibility_level" "text" DEFAULT 'community'::"text",
    "quote_sharing_consent" boolean DEFAULT true,
    "impact_story_promotion" boolean DEFAULT true,
    "wisdom_sharing_level" "text" DEFAULT 'community'::"text",
    "open_to_mentoring" boolean DEFAULT false,
    "available_for_collaboration" boolean DEFAULT false,
    "seeking_organizational_connections" boolean DEFAULT false,
    "interested_in_peer_support" boolean DEFAULT true,
    "narrative_ownership_level" "text" DEFAULT 'guided_sharing'::"text",
    "attribution_preferences" "jsonb" DEFAULT '{}'::"jsonb",
    "story_use_permissions" "jsonb" DEFAULT '{}'::"jsonb",
    "platform_benefit_sharing" "jsonb" DEFAULT '{}'::"jsonb",
    "generated_themes" "text"[],
    "display_name" "text",
    "username" "text",
    "personal_statement" "text",
    "life_motto" "text",
    "website_url" "text",
    "profile_image_alt_text" "text",
    "date_of_birth" "date",
    "age_range" "text",
    "current_role" "text",
    "current_organization" "text",
    "years_of_experience" integer,
    "professional_summary" "text",
    "industry_sectors" "jsonb" DEFAULT '[]'::"jsonb",
    "linkedin_profile_url" "text",
    "resume_url" "text",
    "notion_id" "text",
    "consent_expiry" timestamp with time zone,
    "contact_email" "text",
    "contact_phone" "text",
    "location" "text"
);


ALTER TABLE "public"."storytellers" OWNER TO "postgres";


COMMENT ON TABLE "public"."storytellers" IS 'Core storyteller-centric table - every story must link to a storyteller';



COMMENT ON COLUMN "public"."storytellers"."vision_expressions" IS 'Natural expressions of vision extracted from transcripts: "I want to...", "My dream is..."';



COMMENT ON COLUMN "public"."storytellers"."skills_discovered" IS 'Skills discovered through transcript analysis, not self-reported lists';



COMMENT ON COLUMN "public"."storytellers"."support_offered" IS 'Support they naturally express offering: "I can help with...", "I know how to..."';



COMMENT ON COLUMN "public"."storytellers"."narrative_ownership_level" IS 'Self-determined level of control over how their story is shared and used';



COMMENT ON COLUMN "public"."storytellers"."generated_themes" IS 'Auto-generated themes based on discovery data for improved UI display';



CREATE TABLE IF NOT EXISTS "public"."studio_projects" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "name" "text" NOT NULL,
    "client_name" "text",
    "category" "text" NOT NULL,
    "priority" "text" DEFAULT 'medium'::"text",
    "status" "text" DEFAULT 'active'::"text",
    "description" "text",
    "objectives" "text"[] DEFAULT '{}'::"text"[],
    "start_date" "date",
    "end_date" "date",
    "budget" numeric(12,2),
    "financial_data" "jsonb" DEFAULT '{}'::"jsonb",
    "notion_pages" "text"[] DEFAULT '{}'::"text"[],
    "contacts" "uuid"[] DEFAULT '{}'::"uuid"[],
    "deliverables" "text"[] DEFAULT '{}'::"text"[],
    "outcomes" "text"[] DEFAULT '{}'::"text"[],
    "lessons_learned" "text",
    "tags" "text"[] DEFAULT '{}'::"text"[],
    "intelligence" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "studio_projects_category_check" CHECK (("category" = ANY (ARRAY['justice'::"text", 'stories'::"text", 'community'::"text", 'regeneration'::"text", 'other'::"text"]))),
    CONSTRAINT "studio_projects_priority_check" CHECK (("priority" = ANY (ARRAY['high'::"text", 'medium'::"text", 'low'::"text"]))),
    CONSTRAINT "studio_projects_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'completed'::"text", 'on-hold'::"text", 'archived'::"text"])))
);


ALTER TABLE "public"."studio_projects" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."subscription_analytics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "subscription_id" "uuid" NOT NULL,
    "tenant_id" "text" NOT NULL,
    "last_used_date" "date",
    "usage_frequency" "text",
    "estimated_value" numeric(10,2),
    "actual_cost" numeric(10,2),
    "value_score" numeric(3,2),
    "recommendation" "text",
    "recommendation_reason" "text",
    "confidence" numeric(3,2),
    "analyzed_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "subscription_analytics_recommendation_check" CHECK (("recommendation" = ANY (ARRAY['keep'::"text", 'review'::"text", 'cancel'::"text"]))),
    CONSTRAINT "subscription_analytics_usage_frequency_check" CHECK (("usage_frequency" = ANY (ARRAY['daily'::"text", 'weekly'::"text", 'monthly'::"text", 'rarely'::"text", 'never'::"text"])))
);


ALTER TABLE "public"."subscription_analytics" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."subscription_cost_anomalies" AS
 WITH "subscription_averages" AS (
         SELECT "email_financial_documents"."vendor",
            "avg"("email_financial_documents"."amount") AS "avg_amount",
            "stddev"("email_financial_documents"."amount") AS "stddev_amount",
            "count"(*) AS "transaction_count"
           FROM "public"."email_financial_documents"
          WHERE (("email_financial_documents"."is_subscription" = true) AND ("email_financial_documents"."amount" IS NOT NULL))
          GROUP BY "email_financial_documents"."vendor"
         HAVING ("count"(*) >= 3)
        )
 SELECT "efd"."id",
    "efd"."tenant_id",
    "efd"."vendor",
    "efd"."amount" AS "current_amount",
    "sa"."avg_amount" AS "expected_amount",
    ((("efd"."amount" - "sa"."avg_amount") / "sa"."avg_amount") * (100)::numeric) AS "percent_difference",
    "efd"."transaction_date",
    "efd"."account_email",
        CASE
            WHEN (((("efd"."amount" - "sa"."avg_amount") / "sa"."avg_amount") * (100)::numeric) > (50)::numeric) THEN 'CRITICAL'::"text"
            WHEN (((("efd"."amount" - "sa"."avg_amount") / "sa"."avg_amount") * (100)::numeric) > (20)::numeric) THEN 'HIGH'::"text"
            ELSE 'MEDIUM'::"text"
        END AS "severity"
   FROM ("public"."email_financial_documents" "efd"
     JOIN "subscription_averages" "sa" ON (("sa"."vendor" = "efd"."vendor")))
  WHERE (("efd"."is_subscription" = true) AND ("efd"."amount" IS NOT NULL) AND ("efd"."amount" > ("sa"."avg_amount" + ((2)::numeric * "sa"."stddev_amount"))))
  ORDER BY ((("efd"."amount" - "sa"."avg_amount") / "sa"."avg_amount") * (100)::numeric) DESC;


ALTER VIEW "public"."subscription_cost_anomalies" OWNER TO "postgres";


COMMENT ON VIEW "public"."subscription_cost_anomalies" IS 'Subscriptions with charges significantly higher than historical average';



CREATE OR REPLACE VIEW "public"."subscription_cost_by_account" AS
 SELECT "tenant_id",
    "account_email",
    "count"(*) AS "subscription_count",
    "count"(*) FILTER (WHERE ("subscription_status" = 'active'::"text")) AS "active_count",
    "count"(*) FILTER (WHERE ("subscription_status" = 'cancelled'::"text")) AS "cancelled_count",
    "sum"(
        CASE
            WHEN (("subscription_frequency" = 'monthly'::"text") AND ("amount" IS NOT NULL)) THEN ("amount" * (12)::numeric)
            WHEN (("subscription_frequency" = 'yearly'::"text") AND ("amount" IS NOT NULL)) THEN "amount"
            WHEN (("subscription_frequency" = 'quarterly'::"text") AND ("amount" IS NOT NULL)) THEN ("amount" * (4)::numeric)
            ELSE (0)::numeric
        END) AS "total_annual_cost",
    "avg"("amount") AS "avg_amount",
    "min"("amount") AS "min_amount",
    "max"("amount") AS "max_amount"
   FROM "public"."email_financial_documents"
  WHERE (("is_subscription" = true) AND ("subscription_status" <> 'cancelled'::"text"))
  GROUP BY "tenant_id", "account_email"
  ORDER BY ("sum"(
        CASE
            WHEN (("subscription_frequency" = 'monthly'::"text") AND ("amount" IS NOT NULL)) THEN ("amount" * (12)::numeric)
            WHEN (("subscription_frequency" = 'yearly'::"text") AND ("amount" IS NOT NULL)) THEN "amount"
            WHEN (("subscription_frequency" = 'quarterly'::"text") AND ("amount" IS NOT NULL)) THEN ("amount" * (4)::numeric)
            ELSE (0)::numeric
        END)) DESC;


ALTER VIEW "public"."subscription_cost_by_account" OWNER TO "postgres";


COMMENT ON VIEW "public"."subscription_cost_by_account" IS 'Cost analysis grouped by email account';



CREATE OR REPLACE VIEW "public"."subscription_cost_by_category" AS
 SELECT "tenant_id",
    "category",
    "count"(*) AS "subscription_count",
    "count"(*) FILTER (WHERE ("subscription_status" = 'active'::"text")) AS "active_count",
    "sum"(
        CASE
            WHEN (("subscription_frequency" = 'monthly'::"text") AND ("amount" IS NOT NULL)) THEN ("amount" * (12)::numeric)
            WHEN (("subscription_frequency" = 'yearly'::"text") AND ("amount" IS NOT NULL)) THEN "amount"
            WHEN (("subscription_frequency" = 'quarterly'::"text") AND ("amount" IS NOT NULL)) THEN ("amount" * (4)::numeric)
            ELSE (0)::numeric
        END) AS "total_annual_cost",
    "sum"(
        CASE
            WHEN (("subscription_frequency" = 'monthly'::"text") AND ("amount" IS NOT NULL)) THEN "amount"
            WHEN (("subscription_frequency" = 'yearly'::"text") AND ("amount" IS NOT NULL)) THEN ("amount" / (12)::numeric)
            WHEN (("subscription_frequency" = 'quarterly'::"text") AND ("amount" IS NOT NULL)) THEN ("amount" / (3)::numeric)
            ELSE (0)::numeric
        END) AS "total_monthly_cost",
    "avg"("amount") AS "avg_amount"
   FROM "public"."email_financial_documents"
  WHERE (("is_subscription" = true) AND ("subscription_status" <> 'cancelled'::"text"))
  GROUP BY "tenant_id", "category"
  ORDER BY ("sum"(
        CASE
            WHEN (("subscription_frequency" = 'monthly'::"text") AND ("amount" IS NOT NULL)) THEN ("amount" * (12)::numeric)
            WHEN (("subscription_frequency" = 'yearly'::"text") AND ("amount" IS NOT NULL)) THEN "amount"
            WHEN (("subscription_frequency" = 'quarterly'::"text") AND ("amount" IS NOT NULL)) THEN ("amount" * (4)::numeric)
            ELSE (0)::numeric
        END)) DESC;


ALTER VIEW "public"."subscription_cost_by_category" OWNER TO "postgres";


COMMENT ON VIEW "public"."subscription_cost_by_category" IS 'Cost analysis grouped by category type';



CREATE TABLE IF NOT EXISTS "public"."subscription_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "subscription_id" "uuid",
    "change_type" "text" NOT NULL,
    "previous_cost" numeric(10,2),
    "new_cost" numeric(10,2),
    "previous_status" "text",
    "new_status" "text",
    "notes" "text",
    "triggered_by" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "subscription_history_change_type_check" CHECK (("change_type" = ANY (ARRAY['created'::"text", 'renewed'::"text", 'upgraded'::"text", 'downgraded'::"text", 'cancelled'::"text", 'paused'::"text", 'resumed'::"text", 'price_change'::"text"])))
);


ALTER TABLE "public"."subscription_history" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."subscription_payment_calendar" AS
 SELECT "id",
    "tenant_id",
    "vendor",
    "amount",
    "currency",
    "account_email",
    "next_payment_date",
    ("next_payment_date" - CURRENT_DATE) AS "days_until_due",
    "payment_pattern_confidence",
    "subscription_frequency",
    "subscription_status",
        CASE
            WHEN ("next_payment_date" IS NULL) THEN 'no_prediction'::"text"
            WHEN (("next_payment_date" - CURRENT_DATE) <= 0) THEN 'overdue'::"text"
            WHEN (("next_payment_date" - CURRENT_DATE) <= 1) THEN 'due_today'::"text"
            WHEN (("next_payment_date" - CURRENT_DATE) <= 7) THEN 'due_soon'::"text"
            WHEN (("next_payment_date" - CURRENT_DATE) <= 30) THEN 'upcoming'::"text"
            ELSE 'future'::"text"
        END AS "urgency",
    "created_at",
    "updated_at"
   FROM "public"."email_financial_documents"
  WHERE (("is_subscription" = true) AND ("subscription_status" <> 'cancelled'::"text") AND ("next_payment_date" IS NOT NULL))
  ORDER BY "next_payment_date";


ALTER VIEW "public"."subscription_payment_calendar" OWNER TO "postgres";


COMMENT ON VIEW "public"."subscription_payment_calendar" IS 'Active subscriptions with payment due dates and urgency levels';



CREATE OR REPLACE VIEW "public"."subscription_renewal_alerts" AS
 SELECT "id",
    "tenant_id",
    "vendor",
    "amount",
    "currency",
    "account_email",
    "next_payment_date",
    ("next_payment_date" - CURRENT_DATE) AS "days_until_due",
    "payment_pattern_confidence",
    "subscription_frequency",
    "renewal_reminder_sent",
    "last_renewal_reminder_date",
        CASE
            WHEN (("next_payment_date" - CURRENT_DATE) <= 0) THEN 'OVERDUE'::"text"
            WHEN (("next_payment_date" - CURRENT_DATE) <= 1) THEN 'DUE TODAY'::"text"
            WHEN (("next_payment_date" - CURRENT_DATE) <= 7) THEN 'DUE THIS WEEK'::"text"
            ELSE 'UPCOMING'::"text"
        END AS "alert_type"
   FROM "public"."email_financial_documents"
  WHERE (("is_subscription" = true) AND ("subscription_status" = 'active'::"text") AND ("next_payment_date" IS NOT NULL) AND (("next_payment_date" - CURRENT_DATE) <= 7) AND (("renewal_reminder_sent" = false) OR ("last_renewal_reminder_date" < (CURRENT_DATE - '7 days'::interval))))
  ORDER BY ("next_payment_date" - CURRENT_DATE);


ALTER VIEW "public"."subscription_renewal_alerts" OWNER TO "postgres";


COMMENT ON VIEW "public"."subscription_renewal_alerts" IS 'Subscriptions due for renewal within 7 days';



CREATE TABLE IF NOT EXISTS "public"."subscriptions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "vendor_name" "text" NOT NULL,
    "vendor_email" "text",
    "account_email" "text",
    "account_status" "text" DEFAULT 'active'::"text",
    "billing_cycle" "text",
    "amount" numeric(10,2),
    "currency" "text" DEFAULT 'AUD'::"text",
    "next_billing_date" "date",
    "category" "text",
    "purpose" "text",
    "project_codes" "text"[],
    "is_essential" boolean DEFAULT true,
    "review_status" "text" DEFAULT 'active'::"text",
    "receipt_automation" "text" DEFAULT 'manual'::"text",
    "dext_supplier_rule" boolean DEFAULT false,
    "xero_bank_rule" boolean DEFAULT false,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "current_login_email" "text",
    "login_url" "text",
    "migration_notes" "text",
    "migrated_at" timestamp with time zone,
    CONSTRAINT "subscriptions_account_status_check" CHECK (("account_status" = ANY (ARRAY['active'::"text", 'paused'::"text", 'cancelled'::"text", 'pending_migration'::"text"]))),
    CONSTRAINT "subscriptions_billing_cycle_check" CHECK (("billing_cycle" = ANY (ARRAY['monthly'::"text", 'annual'::"text", 'usage'::"text", 'one_time'::"text"]))),
    CONSTRAINT "subscriptions_category_check" CHECK (("category" = ANY (ARRAY['ai_tools'::"text", 'design_creative'::"text", 'development'::"text", 'productivity'::"text", 'marketing_crm'::"text", 'accounting'::"text", 'hosting_domains'::"text", 'communication'::"text", 'media_entertainment'::"text", 'security'::"text", 'other'::"text"]))),
    CONSTRAINT "subscriptions_receipt_automation_check" CHECK (("receipt_automation" = ANY (ARRAY['manual'::"text", 'email_forward'::"text", 'dext_auto_publish'::"text", 'fully_automated'::"text"]))),
    CONSTRAINT "subscriptions_review_status_check" CHECK (("review_status" = ANY (ARRAY['active'::"text", 'review_needed'::"text", 'keep'::"text", 'cancel'::"text", 'downgrade'::"text"])))
);


ALTER TABLE "public"."subscriptions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."suggestion_feedback" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "suggestion_id" "uuid" NOT NULL,
    "action" "text" NOT NULL,
    "original_role" "text",
    "final_role" "text",
    "admin_notes" "text",
    "reviewed_by" "uuid",
    "created_at" timestamp without time zone DEFAULT "now"(),
    CONSTRAINT "suggestion_feedback_action_check" CHECK (("action" = ANY (ARRAY['approved'::"text", 'rejected'::"text", 'edited'::"text", 'ignored'::"text"])))
);


ALTER TABLE "public"."suggestion_feedback" OWNER TO "postgres";


COMMENT ON TABLE "public"."suggestion_feedback" IS 'Tracks admin actions on suggestions to improve future suggestions';



CREATE TABLE IF NOT EXISTS "public"."support_matches" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "supporter_id" "uuid",
    "seeker_id" "uuid",
    "support_type" "text" NOT NULL,
    "support_description" "text" NOT NULL,
    "match_confidence" double precision,
    "status" "text" DEFAULT 'potential'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "support_matches_match_confidence_check" CHECK ((("match_confidence" >= (0)::double precision) AND ("match_confidence" <= (1)::double precision))),
    CONSTRAINT "support_matches_status_check" CHECK (("status" = ANY (ARRAY['potential'::"text", 'offered'::"text", 'accepted'::"text", 'completed'::"text", 'declined'::"text"])))
);


ALTER TABLE "public"."support_matches" OWNER TO "postgres";


COMMENT ON TABLE "public"."support_matches" IS 'Natural support opportunities identified through transcript analysis';



CREATE TABLE IF NOT EXISTS "public"."sync_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "event_type" "text" NOT NULL,
    "table_name" "text" NOT NULL,
    "record_id" "uuid" NOT NULL,
    "operation_data" "jsonb" NOT NULL,
    "sync_status" "text" DEFAULT 'pending'::"text",
    "sync_target" "text" NOT NULL,
    "retry_count" integer DEFAULT 0,
    "max_retries" integer DEFAULT 3,
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "processed_at" timestamp with time zone,
    "priority" integer DEFAULT 5,
    "batch_id" "uuid",
    CONSTRAINT "valid_event_type" CHECK (("event_type" = ANY (ARRAY['insert'::"text", 'update'::"text", 'delete'::"text"]))),
    CONSTRAINT "valid_sync_status" CHECK (("sync_status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text", 'skipped'::"text"]))),
    CONSTRAINT "valid_sync_target" CHECK (("sync_target" = ANY (ARRAY['neo4j'::"text", 'supabase'::"text", 'both'::"text"])))
);


ALTER TABLE "public"."sync_events" OWNER TO "postgres";


COMMENT ON TABLE "public"."sync_events" IS 'Queue for real-time synchronization events between Supabase and Neo4j';



CREATE OR REPLACE VIEW "public"."sync_event_statistics" AS
 SELECT "table_name",
    "sync_target",
    "sync_status",
    "count"(*) AS "event_count",
    "min"("created_at") AS "oldest_event",
    "max"("created_at") AS "newest_event",
    "avg"(
        CASE
            WHEN (("processed_at" IS NOT NULL) AND ("created_at" IS NOT NULL)) THEN EXTRACT(epoch FROM ("processed_at" - "created_at"))
            ELSE NULL::numeric
        END) AS "avg_processing_time_seconds"
   FROM "public"."sync_events"
  WHERE ("created_at" > ("now"() - '7 days'::interval))
  GROUP BY "table_name", "sync_target", "sync_status"
  ORDER BY "table_name", "sync_target", "sync_status";


ALTER VIEW "public"."sync_event_statistics" OWNER TO "postgres";


COMMENT ON VIEW "public"."sync_event_statistics" IS 'Statistics view for monitoring sync event processing';



CREATE TABLE IF NOT EXISTS "public"."sync_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "source_table" "text" NOT NULL,
    "source_id" "text" NOT NULL,
    "target_system" "text" NOT NULL,
    "operation" "text" NOT NULL,
    "payload" "jsonb",
    "cultural_check_passed" boolean DEFAULT false,
    "cultural_protocol_id" "uuid",
    "status" "text" DEFAULT 'pending'::"text",
    "error_message" "text",
    "retry_count" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "processed_at" timestamp with time zone
);


ALTER TABLE "public"."sync_queue" OWNER TO "postgres";


COMMENT ON TABLE "public"."sync_queue" IS 'Queue for syncing data to external systems with cultural checks';



CREATE TABLE IF NOT EXISTS "public"."sync_state" (
    "id" "text" NOT NULL,
    "sync_type" "text" NOT NULL,
    "last_sync_token" "text",
    "last_sync_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "next_page_token" "text",
    "error_count" integer DEFAULT 0,
    "last_error" "text",
    "state" "jsonb" DEFAULT '{}'::"jsonb",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "sync_state_sync_type_check" CHECK (("sync_type" = ANY (ARRAY['gmail'::"text", 'calendar'::"text", 'ghl'::"text", 'notion'::"text", 'github'::"text", 'google_auth'::"text", 'xero'::"text"])))
);


ALTER TABLE "public"."sync_state" OWNER TO "postgres";


COMMENT ON TABLE "public"."sync_state" IS 'Tracks incremental sync state for Gmail, Calendar, GHL, and other services';



COMMENT ON COLUMN "public"."sync_state"."last_sync_token" IS 'History ID for Gmail, sync token for Calendar, etc.';



COMMENT ON COLUMN "public"."sync_state"."metadata" IS 'Additional metadata like push notification expiration';



CREATE TABLE IF NOT EXISTS "public"."tag_inference_rules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "rule_type" "text" NOT NULL,
    "match_value" "text" NOT NULL,
    "tags" "text"[] NOT NULL,
    "priority" integer DEFAULT 0,
    "active" boolean DEFAULT true,
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."tag_inference_rules" OWNER TO "postgres";


COMMENT ON TABLE "public"."tag_inference_rules" IS 'Configurable rules for auto-suggesting contact tags based on domain, keywords, etc.';



CREATE OR REPLACE VIEW "public"."task_queue_dashboard" AS
 SELECT "t"."id",
    "t"."title",
    "t"."status",
    "t"."priority",
    "t"."assigned_agent",
    "a"."name" AS "agent_name",
    "t"."source",
    "t"."needs_review",
    "t"."created_at",
    "t"."started_at",
    "t"."completed_at",
    "t"."duration_ms",
        CASE
            WHEN ("t"."status" = 'working'::"text") THEN (EXTRACT(epoch FROM ("now"() - "t"."started_at")))::integer
            ELSE NULL::integer
        END AS "working_seconds"
   FROM ("public"."agent_task_queue" "t"
     LEFT JOIN "public"."agents" "a" ON (("t"."assigned_agent" = "a"."id")))
  ORDER BY
        CASE "t"."status"
            WHEN 'review'::"text" THEN 1
            WHEN 'working'::"text" THEN 2
            WHEN 'queued'::"text" THEN 3
            ELSE 4
        END, "t"."priority", "t"."created_at";


ALTER VIEW "public"."task_queue_dashboard" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."themes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "category" "text",
    "parent_theme_id" "uuid",
    "level" integer DEFAULT 0,
    "sort_order" integer DEFAULT 0,
    "ai_confidence_threshold" numeric(3,2) DEFAULT 0.75,
    "usage_count" integer DEFAULT 0,
    "cultural_context" "text"[],
    "requires_cultural_review" boolean DEFAULT false,
    "status" "text" DEFAULT 'active'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "themes_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'archived'::"text", 'under_review'::"text"])))
);


ALTER TABLE "public"."themes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."touchpoints" (
    "id" "text" NOT NULL,
    "source" "text" NOT NULL,
    "source_id" "text",
    "contact_id" bigint,
    "contact_email" "text",
    "contact_name" "text",
    "project_id" "text",
    "project_name" "text",
    "occurred_at" timestamp with time zone,
    "summary" "text",
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."touchpoints" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."training_dataset" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "verification_id" "uuid",
    "prompt" "text" NOT NULL,
    "completion" "text" NOT NULL,
    "content_type" "text" NOT NULL,
    "project_slug" "text",
    "brand_voice_score" integer,
    "cultural_safety_score" integer,
    "overall_quality_score" integer,
    "included_in_training_run" "text"[],
    "last_used_for_training" timestamp with time zone,
    "usage_count" integer DEFAULT 0,
    "tags" "text"[],
    "themes" "text"[],
    "difficulty_level" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "training_dataset_difficulty_level_check" CHECK (("difficulty_level" = ANY (ARRAY['basic'::"text", 'intermediate'::"text", 'advanced'::"text"])))
);


ALTER TABLE "public"."training_dataset" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."training_ready_content" AS
 SELECT "id",
    "content_type",
    "project_slug",
    "generated_content" AS "prompt",
    "final_content" AS "completion",
    "brand_voice_score",
    "cultural_safety_score",
    "overall_quality_score",
    "verified_at"
   FROM "public"."ai_content_verifications" "v"
  WHERE (("status" = 'approved'::"text") AND ("overall_quality_score" >= 4) AND (("requires_elder_review" = false) OR ("elder_reviewed_at" IS NOT NULL)) AND ("used_for_training" = false))
  ORDER BY "overall_quality_score" DESC, "verified_at" DESC;


ALTER VIEW "public"."training_ready_content" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."transcript_analysis" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "transcript_id" "uuid",
    "analysis_type" "text" NOT NULL,
    "ai_model_used" "text" NOT NULL,
    "analysis_version" "text" DEFAULT '1.0'::"text",
    "results" "jsonb" NOT NULL,
    "confidence_score" numeric(3,2),
    "quality_score" numeric(3,2),
    "themes_identified" "uuid"[] DEFAULT '{}'::"uuid"[],
    "primary_emotions" "text"[],
    "key_topics" "text"[],
    "key_quotes" "text"[],
    "summary" "text",
    "insights" "text"[],
    "cultural_elements" "jsonb",
    "sensitivity_flags" "text"[],
    "cultural_review_required" boolean DEFAULT false,
    "processing_status" "text" DEFAULT 'completed'::"text",
    "processing_time_seconds" integer,
    "processing_notes" "text",
    "human_reviewed" boolean DEFAULT false,
    "reviewed_by" "uuid",
    "reviewed_at" timestamp with time zone,
    "review_notes" "text",
    "approved_for_use" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "storyteller_id" "uuid",
    CONSTRAINT "story_analysis_analysis_type_check" CHECK (("analysis_type" = ANY (ARRAY['theme_extraction'::"text", 'sentiment_analysis'::"text", 'quote_extraction'::"text", 'story_creation'::"text", 'cultural_analysis'::"text"]))),
    CONSTRAINT "story_analysis_processing_status_check" CHECK (("processing_status" = ANY (ARRAY['processing'::"text", 'completed'::"text", 'failed'::"text", 'requires_review'::"text"])))
);


ALTER TABLE "public"."transcript_analysis" OWNER TO "postgres";


COMMENT ON TABLE "public"."transcript_analysis" IS 'AI analysis of raw interview transcripts - conversational content, spoken themes, interview insights';



COMMENT ON COLUMN "public"."transcript_analysis"."transcript_id" IS 'References the raw interview transcript';



COMMENT ON COLUMN "public"."transcript_analysis"."themes_identified" IS 'Themes extracted from conversational content';



COMMENT ON COLUMN "public"."transcript_analysis"."key_quotes" IS 'Meaningful excerpts from spoken interview';



CREATE TABLE IF NOT EXISTS "public"."transcript_usage" (
    "transcript_id" "uuid",
    "content_type" character varying(50),
    "content_id" "uuid",
    "source_start_position" integer,
    "source_end_position" integer
);


ALTER TABLE "public"."transcript_usage" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."transcripts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "storyteller_id" "uuid" NOT NULL,
    "transcript_content" "text" NOT NULL,
    "transcript_type" "text" DEFAULT 'interview'::"text",
    "collection_date" timestamp with time zone,
    "collection_method" "text",
    "duration_minutes" integer,
    "language" "text" DEFAULT 'en'::"text",
    "interviewer_name" "text",
    "location" "text",
    "word_count" integer GENERATED ALWAYS AS ("array_length"("string_to_array"("transcript_content", ' '::"text"), 1)) STORED,
    "character_count" integer GENERATED ALWAYS AS ("length"("transcript_content")) STORED,
    "storyteller_approved_content" boolean DEFAULT false,
    "consent_for_ai_analysis" boolean DEFAULT false,
    "consent_for_quote_extraction" boolean DEFAULT false,
    "consent_for_theme_analysis" boolean DEFAULT false,
    "consent_for_story_creation" boolean DEFAULT false,
    "consent_date" timestamp with time zone,
    "consent_notes" "text",
    "privacy_level" "text" DEFAULT 'private'::"text",
    "access_restrictions" "text"[] DEFAULT '{}'::"text"[],
    "ready_for_analysis" boolean DEFAULT false,
    "analysis_requested_date" timestamp with time zone,
    "analysis_completed_date" timestamp with time zone,
    "analysis_quality_score" numeric(3,2),
    "content_warnings" "text"[] DEFAULT '{}'::"text"[],
    "requires_cultural_review" boolean DEFAULT false,
    "cultural_considerations" "text",
    "safety_review_status" "text" DEFAULT 'pending'::"text",
    "safety_notes" "text",
    "trauma_informed_considerations" "text",
    "processing_status" "text" DEFAULT 'raw'::"text",
    "last_processed_date" timestamp with time zone,
    "processing_notes" "text",
    "stories_created_count" integer DEFAULT 0,
    "last_story_creation_date" timestamp with time zone,
    "original_file_format" "text",
    "original_file_size_mb" numeric(10,2),
    "transcription_method" "text" DEFAULT 'manual'::"text",
    "transcription_confidence_score" numeric(3,2),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "transcripts_privacy_level_check" CHECK (("privacy_level" = ANY (ARRAY['private'::"text", 'organization-only'::"text", 'research-approved'::"text", 'public-approved'::"text"]))),
    CONSTRAINT "transcripts_processing_status_check" CHECK (("processing_status" = ANY (ARRAY['raw'::"text", 'pending'::"text", 'completed'::"text", 'failed'::"text"]))),
    CONSTRAINT "transcripts_safety_review_status_check" CHECK (("safety_review_status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'needs-support'::"text", 'requires-cultural-review'::"text", 'archived'::"text"]))),
    CONSTRAINT "transcripts_transcript_type_check" CHECK (("transcript_type" = ANY (ARRAY['interview'::"text", 'written-submission'::"text", 'audio-recording'::"text", 'video-recording'::"text", 'workshop'::"text", 'conversation'::"text"])))
);


ALTER TABLE "public"."transcripts" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."unreconciled_financial_documents" AS
 SELECT "id",
    "document_type",
    "vendor",
    "amount",
    "transaction_date",
    "account_email",
    "confidence",
        CASE
            WHEN (("reconciliation_status" = 'unmatched'::"text") AND ("confidence" >= 0.80)) THEN 'high_priority'::"text"
            WHEN ("reconciliation_status" = 'manual_review'::"text") THEN 'needs_review'::"text"
            ELSE 'low_priority'::"text"
        END AS "priority"
   FROM "public"."email_financial_documents"
  WHERE ("reconciliation_status" = ANY (ARRAY['unmatched'::"text", 'manual_review'::"text"]))
  ORDER BY "transaction_date" DESC;


ALTER VIEW "public"."unreconciled_financial_documents" OWNER TO "postgres";


COMMENT ON VIEW "public"."unreconciled_financial_documents" IS 'Documents needing attention with priority scoring based on confidence and reconciliation status.';



CREATE OR REPLACE VIEW "public"."unused_subscriptions" AS
 SELECT "efd"."id",
    "efd"."tenant_id",
    "efd"."vendor",
    "efd"."amount",
    "efd"."currency",
    "efd"."account_email",
    "efd"."subscription_frequency",
    "efd"."usage_last_checked_date",
    "efd"."usage_status",
    "max"("xbt"."date") AS "last_xero_transaction_date",
    (CURRENT_DATE - "max"("xbt"."date")) AS "days_since_last_activity"
   FROM ("public"."email_financial_documents" "efd"
     LEFT JOIN "public"."xero_bank_transactions" "xbt" ON ((("xbt"."tenant_id" = "efd"."tenant_id") AND ("lower"("xbt"."contact_name") = "lower"("efd"."vendor")))))
  WHERE (("efd"."is_subscription" = true) AND ("efd"."subscription_status" = 'active'::"text") AND ("efd"."amount" IS NOT NULL))
  GROUP BY "efd"."id", "efd"."tenant_id", "efd"."vendor", "efd"."amount", "efd"."currency", "efd"."account_email", "efd"."subscription_frequency", "efd"."usage_last_checked_date", "efd"."usage_status"
 HAVING (("max"("xbt"."date") IS NULL) OR ((CURRENT_DATE - "max"("xbt"."date")) > 90))
  ORDER BY (CURRENT_DATE - "max"("xbt"."date")) DESC;


ALTER VIEW "public"."unused_subscriptions" OWNER TO "postgres";


COMMENT ON VIEW "public"."unused_subscriptions" IS 'Active subscriptions with no Xero activity in 90+ days';



CREATE TABLE IF NOT EXISTS "public"."user_behavior_insights" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "engagement_patterns" "jsonb" DEFAULT '{}'::"jsonb",
    "content_preferences" "jsonb" DEFAULT '{}'::"jsonb",
    "collaboration_patterns" "jsonb" DEFAULT '{}'::"jsonb",
    "platform_usage_patterns" "jsonb" DEFAULT '{}'::"jsonb",
    "predicted_interests" "jsonb" DEFAULT '[]'::"jsonb",
    "recommended_projects" "jsonb" DEFAULT '[]'::"jsonb",
    "collaboration_matches" "jsonb" DEFAULT '[]'::"jsonb",
    "total_session_time" integer DEFAULT 0,
    "average_session_duration" integer DEFAULT 0,
    "page_views_total" integer DEFAULT 0,
    "content_interactions_total" integer DEFAULT 0,
    "collaboration_initiated" integer DEFAULT 0,
    "engagement_score" numeric DEFAULT 0,
    "community_contribution_score" numeric DEFAULT 0,
    "content_quality_score" numeric DEFAULT 0,
    "collaboration_effectiveness_score" numeric DEFAULT 0,
    "analysis_period_start" "date" NOT NULL,
    "analysis_period_end" "date" NOT NULL,
    "last_calculated_at" timestamp with time zone DEFAULT "now"(),
    "calculation_version" "text" DEFAULT '1.0'::"text",
    "insights_consent" boolean DEFAULT false,
    "data_sharing_consent" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_behavior_insights" OWNER TO "postgres";


COMMENT ON TABLE "public"."user_behavior_insights" IS 'AI-generated insights about user behavior patterns';



CREATE TABLE IF NOT EXISTS "public"."user_community_engagement" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_profile_id" "uuid" NOT NULL,
    "participation_style" "jsonb" DEFAULT '{}'::"jsonb",
    "skill_sharing_preferences" "jsonb" DEFAULT '{}'::"jsonb",
    "availability" "jsonb" DEFAULT '{}'::"jsonb",
    "contribution_areas" "jsonb" DEFAULT '[]'::"jsonb",
    "leadership_interests" "jsonb" DEFAULT '[]'::"jsonb",
    "cultural_considerations" "jsonb" DEFAULT '{}'::"jsonb",
    "ethical_guidelines" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_community_engagement" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_profiles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "email" "text",
    "display_name" "text",
    "avatar_url" "text",
    "bio" "text",
    "location" "jsonb",
    "interests" "jsonb" DEFAULT '[]'::"jsonb",
    "expertise_areas" "jsonb" DEFAULT '[]'::"jsonb",
    "collaboration_preferences" "jsonb" DEFAULT '{}'::"jsonb",
    "dashboard_layout" "jsonb" DEFAULT '{}'::"jsonb",
    "content_preferences" "jsonb" DEFAULT '{}'::"jsonb",
    "notification_preferences" "jsonb" DEFAULT '{}'::"jsonb",
    "privacy_settings" "jsonb" DEFAULT '{}'::"jsonb",
    "preferred_languages" "jsonb" DEFAULT '["en"]'::"jsonb",
    "accessibility_needs" "jsonb" DEFAULT '{}'::"jsonb",
    "cultural_protocols" "jsonb" DEFAULT '{}'::"jsonb",
    "onboarding_completed" boolean DEFAULT false,
    "last_active_at" timestamp with time zone,
    "account_status" "text" DEFAULT 'active'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "valid_account_status" CHECK (("account_status" = ANY (ARRAY['active'::"text", 'inactive'::"text", 'suspended'::"text", 'deleted'::"text"])))
);


ALTER TABLE "public"."user_profiles" OWNER TO "postgres";


COMMENT ON TABLE "public"."user_profiles" IS 'Comprehensive user profiles with preferences and personalization data';



CREATE TABLE IF NOT EXISTS "public"."user_project_preferences" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_profile_id" "uuid" NOT NULL,
    "project_id" "uuid" NOT NULL,
    "preference_type" "text" NOT NULL,
    "engagement_level" "text" DEFAULT 'observer'::"text",
    "notification_enabled" boolean DEFAULT true,
    "collaboration_interest" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_project_preferences" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."user_dashboard_summary" AS
 SELECT "up"."id" AS "user_profile_id",
    "up"."user_id",
    "up"."display_name",
    "up"."location",
    "up"."interests",
    "count"(DISTINCT "upp"."project_id") AS "followed_projects",
    "count"(DISTINCT "pc"."project_id") AS "contributed_projects",
    COALESCE("ubi"."engagement_score", (0)::numeric) AS "engagement_score",
    "up"."last_active_at",
    "up"."onboarding_completed"
   FROM ((("public"."user_profiles" "up"
     LEFT JOIN "public"."user_project_preferences" "upp" ON ((("up"."id" = "upp"."user_profile_id") AND ("upp"."preference_type" = 'follow'::"text"))))
     LEFT JOIN "public"."project_contributions" "pc" ON ((("up"."user_id")::"text" = ("pc"."contributor_id")::"text")))
     LEFT JOIN "public"."user_behavior_insights" "ubi" ON ((("up"."user_id" = "ubi"."user_id") AND ("ubi"."analysis_period_end" = ( SELECT "max"("user_behavior_insights"."analysis_period_end") AS "max"
           FROM "public"."user_behavior_insights"
          WHERE ("user_behavior_insights"."user_id" = "up"."user_id"))))))
  GROUP BY "up"."id", "up"."user_id", "up"."display_name", "up"."location", "up"."interests", "ubi"."engagement_score", "up"."last_active_at", "up"."onboarding_completed";


ALTER VIEW "public"."user_dashboard_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_gamification_stats" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "text" DEFAULT 'act-finance'::"text",
    "total_points" integer DEFAULT 0,
    "points_this_week" integer DEFAULT 0,
    "points_this_month" integer DEFAULT 0,
    "current_streak" integer DEFAULT 0,
    "best_streak" integer DEFAULT 0,
    "last_perfect_week" "date",
    "receipts_resolved" integer DEFAULT 0,
    "quick_resolves" integer DEFAULT 0,
    "no_receipt_marked" integer DEFAULT 0,
    "achievements" "jsonb" DEFAULT '[]'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_gamification_stats" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_identities" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "canonical_name" "text" NOT NULL,
    "display_name" "text",
    "discord_id" "text",
    "discord_username" "text",
    "signal_number" "text",
    "whatsapp_number" "text",
    "telegram_id" "text",
    "telegram_username" "text",
    "email" "text",
    "ghl_contact_id" "text",
    "preferred_channel" "text" DEFAULT 'discord'::"text",
    "notification_preferences" "jsonb" DEFAULT '{"quiet_hours": {"end": "07:00", "start": "22:00"}, "urgent_only": false, "morning_brief": true}'::"jsonb",
    "timezone" "text" DEFAULT 'Australia/Brisbane'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_identities" OWNER TO "postgres";


COMMENT ON TABLE "public"."user_identities" IS 'Cross-channel identity mapping for team members';



CREATE TABLE IF NOT EXISTS "public"."users" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "email" "text" NOT NULL,
    "username" "text" NOT NULL,
    "name" "text" NOT NULL,
    "user_role" "text" DEFAULT 'staff'::"text" NOT NULL,
    "permissions" "text"[] DEFAULT ARRAY[]::"text"[],
    "password_hash" "text" NOT NULL,
    "last_login" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_active" boolean DEFAULT true
);


ALTER TABLE "public"."users" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_agent_activity_summary" AS
 SELECT "agent_id",
    "action",
    "count"(*) AS "action_count",
    "sum"(
        CASE
            WHEN "success" THEN 1
            ELSE 0
        END) AS "success_count",
    "sum"(
        CASE
            WHEN (NOT "success") THEN 1
            ELSE 0
        END) AS "error_count",
    ("avg"("duration_ms"))::integer AS "avg_duration_ms",
    "max"("timestamp") AS "last_run"
   FROM "public"."agent_audit_log"
  WHERE ("timestamp" > ("now"() - '7 days'::interval))
  GROUP BY "agent_id", "action"
  ORDER BY "agent_id", ("count"(*)) DESC;


ALTER VIEW "public"."v_agent_activity_summary" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_awaiting_response" AS
 SELECT "ch"."id",
    "ch"."ghl_contact_id",
    "ch"."channel",
    "ch"."direction",
    "ch"."from_identity",
    "ch"."to_identities",
    "ch"."subject",
    "ch"."content_preview",
    "ch"."full_content_ref",
    "ch"."summary",
    "ch"."sentiment",
    "ch"."topics",
    "ch"."action_items",
    "ch"."key_decisions",
    "ch"."waiting_for_response",
    "ch"."response_needed_by",
    "ch"."follow_up_date",
    "ch"."source_system",
    "ch"."source_id",
    "ch"."source_thread_id",
    "ch"."parent_id",
    "ch"."occurred_at",
    "ch"."synced_at",
    "ch"."enriched_at",
    "ch"."created_at",
    "ch"."updated_at",
    "c"."full_name" AS "contact_name",
    "c"."email" AS "contact_email",
    EXTRACT(day FROM ("now"() - "ch"."occurred_at")) AS "days_waiting"
   FROM ("public"."communications_history" "ch"
     JOIN "public"."ghl_contacts" "c" ON (("ch"."ghl_contact_id" = "c"."ghl_id")))
  WHERE (("ch"."waiting_for_response" = true) AND ("ch"."response_needed_by" = 'them'::"text"))
  ORDER BY "ch"."occurred_at";


ALTER VIEW "public"."v_awaiting_response" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_cache_efficiency" AS
 SELECT "script_name",
    "model",
    "count"(*) AS "total_calls",
    "sum"(
        CASE
            WHEN "cache_hit" THEN 1
            ELSE 0
        END) AS "cache_hits",
    "round"(((100.0 * ("sum"(
        CASE
            WHEN "cache_hit" THEN 1
            ELSE 0
        END))::numeric) / (NULLIF("count"(*), 0))::numeric), 1) AS "hit_rate",
    "round"("sum"(
        CASE
            WHEN (NOT "cache_hit") THEN "estimated_cost"
            ELSE (0)::numeric
        END), 4) AS "actual_cost",
    "round"("sum"("estimated_cost"), 4) AS "would_be_cost",
    "round"("sum"(
        CASE
            WHEN "cache_hit" THEN "estimated_cost"
            ELSE (0)::numeric
        END), 4) AS "savings"
   FROM "public"."api_usage"
  WHERE ("timestamp" > ("now"() - '7 days'::interval))
  GROUP BY "script_name", "model"
 HAVING ("count"(*) > 10)
  ORDER BY ("round"("sum"(
        CASE
            WHEN "cache_hit" THEN "estimated_cost"
            ELSE (0)::numeric
        END), 4)) DESC;


ALTER VIEW "public"."v_cache_efficiency" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_cache_efficiency" IS 'Analysis of cache effectiveness and savings';



CREATE OR REPLACE VIEW "public"."v_calendar_events_with_projects" AS
 SELECT "id",
    "google_event_id",
    "google_calendar_id",
    "calendar_name",
    "calendar_color",
    "title",
    "description",
    "start_time",
    "end_time",
    "location",
    "attendees",
    "organizer_email",
    "is_all_day",
    "recurrence_rule",
    "recurring_event_id",
    "status",
    "transparency",
    "visibility",
    "event_type",
    "project_code",
    "detected_project_code",
    "manual_project_code",
    "ghl_contact_ids",
    "attendee_contact_matches",
    "metadata",
    "html_link",
    "etag",
    "synced_at",
    "sync_source",
    "created_at",
    "updated_at",
        CASE
            WHEN ("project_code" IS NOT NULL) THEN "jsonb_build_object"('code', "project_code", 'has_manual_override', ("manual_project_code" IS NOT NULL))
            ELSE NULL::"jsonb"
        END AS "project_info",
    "jsonb_array_length"("attendees") AS "attendee_count",
    (EXTRACT(epoch FROM ("end_time" - "start_time")) / (3600)::numeric) AS "duration_hours"
   FROM "public"."calendar_events" "ce"
  WHERE ("status" <> 'cancelled'::"text");


ALTER VIEW "public"."v_calendar_events_with_projects" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_calibration_issues" AS
 SELECT "id",
    "decision_type",
    "agent_id",
    "confidence",
    "decision_summary",
    "reasoning",
    "feedback_notes",
    "timestamp"
   FROM "public"."decision_traces"
  WHERE (("human_feedback" = 'incorrect'::"text") AND ("confidence" > 0.8))
  ORDER BY "confidence" DESC, "timestamp" DESC;


ALTER VIEW "public"."v_calibration_issues" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_calibration_issues" IS 'High-confidence incorrect decisions indicating calibration problems';



CREATE OR REPLACE VIEW "public"."v_contact_communication_summary" AS
 SELECT "c"."ghl_id",
    "c"."full_name",
    "c"."email",
    "rh"."temperature",
    "rh"."lcaa_stage",
    "rh"."days_since_contact",
    "rh"."total_touchpoints",
    "rh"."overall_sentiment",
    ( SELECT "count"(*) AS "count"
           FROM "public"."communications_history" "ch"
          WHERE (("ch"."ghl_contact_id" = "c"."ghl_id") AND ("ch"."channel" = 'email'::"text"))) AS "email_count",
    ( SELECT "count"(*) AS "count"
           FROM "public"."communications_history" "ch"
          WHERE (("ch"."ghl_contact_id" = "c"."ghl_id") AND ("ch"."channel" = 'calendar'::"text"))) AS "meeting_count",
    ( SELECT "count"(*) AS "count"
           FROM "public"."communications_history" "ch"
          WHERE (("ch"."ghl_contact_id" = "c"."ghl_id") AND ("ch"."channel" = 'call'::"text"))) AS "call_count",
    ( SELECT "array_agg"(DISTINCT "topic"."topic") AS "array_agg"
           FROM "public"."communications_history" "ch",
            LATERAL "unnest"("ch"."topics") "topic"("topic")
          WHERE ("ch"."ghl_contact_id" = "c"."ghl_id")) AS "all_topics"
   FROM ("public"."ghl_contacts" "c"
     LEFT JOIN "public"."relationship_health" "rh" ON (("c"."ghl_id" = "rh"."ghl_contact_id")));


ALTER VIEW "public"."v_contact_communication_summary" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_contacts_with_protocols" AS
 SELECT "c"."id",
    "c"."ghl_id",
    "c"."ghl_location_id",
    "c"."first_name",
    "c"."last_name",
    "c"."full_name",
    "c"."email",
    "c"."phone",
    "c"."company_name",
    "c"."tags",
    "c"."custom_fields",
    "c"."projects",
    "c"."engagement_status",
    "c"."first_contact_date",
    "c"."last_contact_date",
    "c"."ghl_created_at",
    "c"."ghl_updated_at",
    "c"."last_synced_at",
    "c"."sync_status",
    "c"."sync_error",
    "c"."created_at",
    "c"."updated_at",
    "cp"."cultural_nation",
    "cp"."elder_status",
    "cp"."requires_elder_review",
    "cp"."review_status",
        CASE
            WHEN ("cp"."id" IS NOT NULL) THEN true
            ELSE false
        END AS "has_cultural_protocols"
   FROM ("public"."ghl_contacts" "c"
     LEFT JOIN "public"."cultural_protocols" "cp" ON (("c"."ghl_id" = "cp"."ghl_contact_id")));


ALTER VIEW "public"."v_contacts_with_protocols" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_cultural_data_access" AS
 SELECT "agent_id",
    "action",
    "target_table",
    "target_id",
    "user_context",
    "timestamp"
   FROM "public"."agent_audit_log"
  WHERE ("cultural_data_accessed" = true)
  ORDER BY "timestamp" DESC;


ALTER VIEW "public"."v_cultural_data_access" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_cultural_data_summary" AS
 SELECT "entity_type",
    "sensitivity_level",
    "count"(*) AS "item_count",
    "count"(DISTINCT "community_of_origin") AS "communities"
   FROM "public"."cultural_protocols"
  WHERE ("entity_type" IS NOT NULL)
  GROUP BY "entity_type", "sensitivity_level"
  ORDER BY "entity_type", "sensitivity_level";


ALTER VIEW "public"."v_cultural_data_summary" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_daily_api_costs" AS
 SELECT "date"("timestamp") AS "date",
    "provider",
    "model",
    "count"(*) AS "calls",
    "sum"("total_tokens") AS "tokens",
    "sum"(
        CASE
            WHEN "cache_hit" THEN 1
            ELSE 0
        END) AS "cache_hits",
    "round"("sum"(COALESCE("estimated_cost", (0)::numeric)), 4) AS "cost_usd"
   FROM "public"."api_usage"
  WHERE ("timestamp" > ("now"() - '30 days'::interval))
  GROUP BY ("date"("timestamp")), "provider", "model"
  ORDER BY ("date"("timestamp")) DESC, ("round"("sum"(COALESCE("estimated_cost", (0)::numeric)), 4)) DESC;


ALTER VIEW "public"."v_daily_api_costs" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_daily_api_costs" IS 'Daily breakdown of API costs by provider and model';



CREATE OR REPLACE VIEW "public"."v_decision_quality_dashboard" AS
 SELECT "agent_id",
    "decision_type",
    "date"("timestamp") AS "date",
    "count"(*) AS "decisions",
    "count"(*) FILTER (WHERE ("human_feedback" = 'correct'::"text")) AS "correct",
    "count"(*) FILTER (WHERE ("human_feedback" = 'incorrect'::"text")) AS "incorrect",
    ("avg"("confidence"))::numeric(3,2) AS "avg_confidence",
    "min"("confidence") AS "min_confidence",
    "max"("confidence") AS "max_confidence"
   FROM "public"."decision_traces"
  WHERE ("timestamp" > ("now"() - '30 days'::interval))
  GROUP BY "agent_id", "decision_type", ("date"("timestamp"))
  ORDER BY ("date"("timestamp")) DESC, ("count"(*)) DESC;


ALTER VIEW "public"."v_decision_quality_dashboard" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_decisions_needing_feedback" AS
 SELECT "id",
    "decision_type",
    "agent_id",
    "decision_summary",
    "confidence",
    "timestamp",
    ("input_context" ->> 'summary'::"text") AS "input_summary",
    ("decision" ->> 'action'::"text") AS "decision_action"
   FROM "public"."decision_traces"
  WHERE (("human_feedback" IS NULL) AND ("timestamp" > ("now"() - '7 days'::interval)))
  ORDER BY "confidence", "timestamp" DESC
 LIMIT 100;


ALTER VIEW "public"."v_decisions_needing_feedback" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_donor_summary" AS
 SELECT "c"."ghl_id",
    "c"."full_name",
    "c"."email",
    "count"("d"."id") AS "donation_count",
    "sum"("d"."amount") AS "lifetime_value",
    "min"("d"."donation_date") AS "first_donation",
    "max"("d"."donation_date") AS "last_donation",
        CASE
            WHEN ("max"("d"."donation_date") < ("now"() - '1 year'::interval)) THEN 'lapsed'::"text"
            WHEN ("count"("d"."id") >= 3) THEN 'regular'::"text"
            WHEN ("count"("d"."id") = 2) THEN 'repeat'::"text"
            WHEN ("count"("d"."id") = 1) THEN 'first_time'::"text"
            ELSE 'prospect'::"text"
        END AS "donor_status"
   FROM ("public"."ghl_contacts" "c"
     LEFT JOIN "public"."donations" "d" ON (("c"."ghl_id" = "d"."ghl_contact_id")))
  GROUP BY "c"."ghl_id", "c"."full_name", "c"."email";


ALTER VIEW "public"."v_donor_summary" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_duplicate_review_queue" AS
 SELECT "pm"."id" AS "match_id",
    "pm"."match_score",
    "pm"."match_reasons",
    "pm"."detected_at",
    "a"."id" AS "entity_a_id",
    "a"."canonical_name" AS "name_a",
    "a"."canonical_email" AS "email_a",
    "a"."canonical_company" AS "company_a",
    "b"."id" AS "entity_b_id",
    "b"."canonical_name" AS "name_b",
    "b"."canonical_email" AS "email_b",
    "b"."canonical_company" AS "company_b"
   FROM (("public"."entity_potential_matches" "pm"
     JOIN "public"."canonical_entities" "a" ON (("pm"."entity_a_id" = "a"."id")))
     JOIN "public"."canonical_entities" "b" ON (("pm"."entity_b_id" = "b"."id")))
  WHERE ("pm"."status" = 'pending'::"text")
  ORDER BY "pm"."match_score" DESC;


ALTER VIEW "public"."v_duplicate_review_queue" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_entity_resolution_stats" AS
 SELECT "entity_type",
    "count"(*) AS "total_entities",
    ("avg"("merge_count"))::numeric(4,1) AS "avg_merges",
    ("avg"("confidence"))::numeric(3,2) AS "avg_confidence",
    "count"(*) FILTER (WHERE ("merge_count" > 1)) AS "merged_entities",
    "count"(*) FILTER (WHERE ("verification_status" = 'verified'::"text")) AS "verified_entities"
   FROM "public"."canonical_entities"
  GROUP BY "entity_type";


ALTER VIEW "public"."v_entity_resolution_stats" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."youth_detention_facilities" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "slug" "text",
    "facility_type" "text" DEFAULT 'youth_detention'::"text" NOT NULL,
    "street_address" "text",
    "suburb" "text",
    "city" "text" NOT NULL,
    "state" "text" NOT NULL,
    "postcode" "text",
    "latitude" numeric(10,8),
    "longitude" numeric(11,8),
    "operational_status" "text" DEFAULT 'operational'::"text",
    "opened_date" "date",
    "closed_date" "date",
    "capacity_beds" integer,
    "current_population" integer,
    "male_capacity" integer,
    "female_capacity" integer,
    "age_range_min" integer DEFAULT 10,
    "age_range_max" integer DEFAULT 18,
    "government_department" "text" NOT NULL,
    "managing_agency" "text",
    "contact_phone" "text",
    "contact_email" "text",
    "website" "text",
    "security_level" "text" DEFAULT 'mixed'::"text",
    "has_remand_section" boolean DEFAULT true,
    "has_sentenced_section" boolean DEFAULT true,
    "has_therapeutic_programs" boolean DEFAULT false,
    "has_education_programs" boolean DEFAULT true,
    "indigenous_population_percentage" numeric(5,2),
    "has_cultural_programs" boolean DEFAULT false,
    "has_indigenous_liaison" boolean DEFAULT false,
    "data_source" "text",
    "data_source_url" "text",
    "last_data_update" "date",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "youth_detention_facilities_facility_type_check" CHECK (("facility_type" = ANY (ARRAY['youth_detention'::"text", 'remand_centre'::"text", 'training_centre'::"text", 'watch_house'::"text", 'therapeutic_facility'::"text", 'transition_facility'::"text"]))),
    CONSTRAINT "youth_detention_facilities_operational_status_check" CHECK (("operational_status" = ANY (ARRAY['operational'::"text", 'under_construction'::"text", 'closed'::"text", 'temporary_closure'::"text"]))),
    CONSTRAINT "youth_detention_facilities_security_level_check" CHECK (("security_level" = ANY (ARRAY['minimum'::"text", 'medium'::"text", 'maximum'::"text", 'mixed'::"text"]))),
    CONSTRAINT "youth_detention_facilities_state_check" CHECK (("state" = ANY (ARRAY['NSW'::"text", 'VIC'::"text", 'QLD'::"text", 'SA'::"text", 'WA'::"text", 'TAS'::"text", 'NT'::"text", 'ACT'::"text"])))
);


ALTER TABLE "public"."youth_detention_facilities" OWNER TO "postgres";


COMMENT ON TABLE "public"."youth_detention_facilities" IS 'All youth detention facilities in Australia with location and operational data';



CREATE OR REPLACE VIEW "public"."v_facilities_with_partnerships" AS
 SELECT "f"."id",
    "f"."name",
    "f"."slug",
    "f"."facility_type",
    "f"."street_address",
    "f"."suburb",
    "f"."city",
    "f"."state",
    "f"."postcode",
    "f"."latitude",
    "f"."longitude",
    "f"."operational_status",
    "f"."opened_date",
    "f"."closed_date",
    "f"."capacity_beds",
    "f"."current_population",
    "f"."male_capacity",
    "f"."female_capacity",
    "f"."age_range_min",
    "f"."age_range_max",
    "f"."government_department",
    "f"."managing_agency",
    "f"."contact_phone",
    "f"."contact_email",
    "f"."website",
    "f"."security_level",
    "f"."has_remand_section",
    "f"."has_sentenced_section",
    "f"."has_therapeutic_programs",
    "f"."has_education_programs",
    "f"."indigenous_population_percentage",
    "f"."has_cultural_programs",
    "f"."has_indigenous_liaison",
    "f"."data_source",
    "f"."data_source_url",
    "f"."last_data_update",
    "f"."created_at",
    "f"."updated_at",
    COALESCE("p"."partnership_count", (0)::bigint) AS "partnership_count",
    COALESCE("p"."active_partnerships", (0)::bigint) AS "active_partnerships",
    COALESCE("p"."organization_partners", (0)::bigint) AS "organization_partners",
    COALESCE("p"."program_partners", (0)::bigint) AS "program_partners",
    COALESCE("p"."service_partners", (0)::bigint) AS "service_partners"
   FROM ("public"."youth_detention_facilities" "f"
     LEFT JOIN ( SELECT "facility_partnerships"."facility_id",
            "count"(*) AS "partnership_count",
            "count"(*) FILTER (WHERE "facility_partnerships"."is_active") AS "active_partnerships",
            "count"(*) FILTER (WHERE ("facility_partnerships"."partner_type" = 'organization'::"text")) AS "organization_partners",
            "count"(*) FILTER (WHERE ("facility_partnerships"."partner_type" = 'community_program'::"text")) AS "program_partners",
            "count"(*) FILTER (WHERE ("facility_partnerships"."partner_type" = 'service'::"text")) AS "service_partners"
           FROM "public"."facility_partnerships"
          GROUP BY "facility_partnerships"."facility_id") "p" ON (("f"."id" = "p"."facility_id")))
  WHERE ("f"."operational_status" = 'operational'::"text");


ALTER VIEW "public"."v_facilities_with_partnerships" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_facilities_with_partnerships" IS 'Facilities with counts of connected partners for ecosystem mapping';



CREATE OR REPLACE VIEW "public"."v_funders_summary" AS
 SELECT "alma_funding_opportunities"."funder_name",
    "alma_funding_opportunities"."source_type",
    "count"(*) AS "total_opportunities",
    "count"(*) FILTER (WHERE ("alma_funding_opportunities"."status" = ANY (ARRAY['open'::"text", 'closing_soon'::"text"]))) AS "active_opportunities",
    "sum"("alma_funding_opportunities"."total_pool_amount") FILTER (WHERE ("alma_funding_opportunities"."status" = ANY (ARRAY['open'::"text", 'closing_soon'::"text"]))) AS "total_available",
    "avg"("alma_funding_opportunities"."max_grant_amount") AS "avg_max_grant",
    "array_agg"(DISTINCT "unnested_jurisdiction"."unnested_jurisdiction") AS "all_jurisdictions"
   FROM "public"."alma_funding_opportunities",
    LATERAL "unnest"(COALESCE("alma_funding_opportunities"."jurisdictions", ARRAY[]::"text"[])) "unnested_jurisdiction"("unnested_jurisdiction")
  GROUP BY "alma_funding_opportunities"."funder_name", "alma_funding_opportunities"."source_type"
  ORDER BY ("count"(*) FILTER (WHERE ("alma_funding_opportunities"."status" = ANY (ARRAY['open'::"text", 'closing_soon'::"text"])))) DESC, ("sum"("alma_funding_opportunities"."total_pool_amount") FILTER (WHERE ("alma_funding_opportunities"."status" = ANY (ARRAY['open'::"text", 'closing_soon'::"text"])))) DESC NULLS LAST;


ALTER VIEW "public"."v_funders_summary" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_funders_summary" IS 'Summary of funders and their opportunities';



CREATE OR REPLACE VIEW "public"."v_funding_pipeline" AS
 SELECT "id",
    "name",
    "funder_name",
    "source_type",
    "category",
    "total_pool_amount",
    "min_grant_amount",
    "max_grant_amount",
    "deadline",
    "status",
    "jurisdictions",
    "focus_areas",
    "source_url",
    "application_url",
    "relevance_score",
        CASE
            WHEN ("deadline" IS NULL) THEN NULL::integer
            WHEN ("deadline" <= "now"()) THEN 0
            ELSE (EXTRACT(day FROM ("deadline" - "now"())))::integer
        END AS "days_until_deadline",
    ( SELECT "count"(*) AS "count"
           FROM "public"."alma_funding_applications" "fa"
          WHERE ("fa"."opportunity_id" = "fo"."id")) AS "application_count",
    "created_at",
    "updated_at"
   FROM "public"."alma_funding_opportunities" "fo"
  WHERE ("status" <> 'archived'::"text")
  ORDER BY
        CASE "status"
            WHEN 'closing_soon'::"text" THEN 1
            WHEN 'open'::"text" THEN 2
            WHEN 'upcoming'::"text" THEN 3
            ELSE 4
        END, "deadline";


ALTER VIEW "public"."v_funding_pipeline" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_funding_pipeline" IS 'Active funding opportunities with days until deadline';



CREATE OR REPLACE VIEW "public"."v_incorrect_decisions" AS
 SELECT "id",
    "decision_type",
    "agent_id",
    "input_context",
    "reasoning",
    "decision",
    "human_feedback",
    "feedback_notes",
    "confidence",
    "timestamp"
   FROM "public"."decision_traces" "dt"
  WHERE ("human_feedback" = 'incorrect'::"text")
  ORDER BY "timestamp" DESC;


ALTER VIEW "public"."v_incorrect_decisions" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_latest_reports" AS
 SELECT DISTINCT ON ("report_type") "id",
    "week_start",
    "week_end",
    "report_type",
    "title",
    "executive_summary",
    "highlights",
    "alerts",
    "status",
    "published_at",
    "generated_at"
   FROM "public"."alma_weekly_reports"
  WHERE ("status" = 'published'::"text")
  ORDER BY "report_type", "week_start" DESC;


ALTER VIEW "public"."v_latest_reports" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_need_to_respond" AS
 SELECT "ch"."id",
    "ch"."ghl_contact_id",
    "ch"."channel",
    "ch"."direction",
    "ch"."from_identity",
    "ch"."to_identities",
    "ch"."subject",
    "ch"."content_preview",
    "ch"."full_content_ref",
    "ch"."summary",
    "ch"."sentiment",
    "ch"."topics",
    "ch"."action_items",
    "ch"."key_decisions",
    "ch"."waiting_for_response",
    "ch"."response_needed_by",
    "ch"."follow_up_date",
    "ch"."source_system",
    "ch"."source_id",
    "ch"."source_thread_id",
    "ch"."parent_id",
    "ch"."occurred_at",
    "ch"."synced_at",
    "ch"."enriched_at",
    "ch"."created_at",
    "ch"."updated_at",
    "c"."full_name" AS "contact_name",
    "c"."email" AS "contact_email",
    EXTRACT(day FROM ("now"() - "ch"."occurred_at")) AS "days_since"
   FROM ("public"."communications_history" "ch"
     JOIN "public"."ghl_contacts" "c" ON (("ch"."ghl_contact_id" = "c"."ghl_id")))
  WHERE (("ch"."waiting_for_response" = true) AND ("ch"."response_needed_by" = 'us'::"text"))
  ORDER BY "ch"."occurred_at";


ALTER VIEW "public"."v_need_to_respond" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_pending_contacts_review" AS
 SELECT "id",
    "email",
    "name",
    "company",
    "title",
    "first_seen_at",
    "last_seen_at",
    "communication_count",
    "topics",
    "importance_score",
    "suggested_tags",
    "status",
    "reviewed_by",
    "reviewed_at",
    "ghl_contact_id",
    "rejection_reason",
    "metadata",
    "created_at",
    "updated_at",
    ( SELECT "count"(*) AS "count"
           FROM "public"."communications_history" "ch"
          WHERE (("ch"."source_system" = 'gmail'::"text") AND (("ch"."content_preview" ~~* (('%'::"text" || "pc"."email") || '%'::"text")) OR ("ch"."subject" ~~* (('%'::"text" || "pc"."email") || '%'::"text"))))) AS "recent_email_count",
    ( SELECT "max"("ch"."occurred_at") AS "max"
           FROM "public"."communications_history" "ch"
          WHERE (("ch"."source_system" = 'gmail'::"text") AND (("ch"."content_preview" ~~* (('%'::"text" || "pc"."email") || '%'::"text")) OR ("ch"."subject" ~~* (('%'::"text" || "pc"."email") || '%'::"text"))))) AS "last_communication_at"
   FROM "public"."pending_contacts" "pc"
  WHERE ("status" = 'pending'::"text")
  ORDER BY "importance_score" DESC, "communication_count" DESC;


ALTER VIEW "public"."v_pending_contacts_review" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_pending_cultural_reviews" AS
 SELECT "sq"."id" AS "sync_id",
    "sq"."source_table",
    "sq"."source_id",
    "sq"."target_system",
    "sq"."created_at",
    "cp"."sensitivity_level",
    "cp"."cultural_liaison_id",
    "cp"."community_of_origin"
   FROM ("public"."sync_queue" "sq"
     LEFT JOIN "public"."cultural_protocols" "cp" ON ((("cp"."entity_type" = "sq"."source_table") AND ("cp"."entity_id" = "sq"."source_id"))))
  WHERE (("sq"."status" = 'blocked'::"text") AND ("sq"."cultural_check_passed" = false))
  ORDER BY "sq"."created_at";


ALTER VIEW "public"."v_pending_cultural_reviews" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_pending_receipts" AS
 SELECT "id",
    "source_type",
    "source_id",
    "vendor_name",
    "amount",
    "transaction_date",
    "category",
    "description",
    "status",
    "match_confidence",
    "suggested_email_subject",
    "suggested_email_from",
    "week_start",
    "deferred_count",
    (CURRENT_DATE - "transaction_date") AS "days_old",
        CASE
            WHEN ("transaction_date" >= (CURRENT_DATE - 7)) THEN 'quick_resolve_eligible'::"text"
            WHEN ("transaction_date" >= (CURRENT_DATE - 30)) THEN 'recent'::"text"
            WHEN ("transaction_date" >= (CURRENT_DATE - 60)) THEN 'aging'::"text"
            ELSE 'backlog'::"text"
        END AS "age_category"
   FROM "public"."receipt_matches" "rm"
  WHERE ("status" = ANY (ARRAY['pending'::"text", 'email_suggested'::"text", 'deferred'::"text"]))
  ORDER BY "match_confidence" DESC NULLS LAST, "transaction_date" DESC;


ALTER VIEW "public"."v_pending_receipts" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_project_actions" AS
 SELECT "id",
    "project_code",
    "title",
    "action_items",
    "follow_up_date",
    "recorded_at"
   FROM "public"."project_knowledge" "pk"
  WHERE (("action_required" = true) OR ("follow_up_date" IS NOT NULL))
  ORDER BY "follow_up_date", "recorded_at" DESC;


ALTER VIEW "public"."v_project_actions" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_project_decisions" AS
 SELECT "project_code",
    "project_name",
    "title",
    "content",
    "decision_status",
    "decision_rationale",
    "recorded_at",
    "participants"
   FROM "public"."project_knowledge" "pk"
  WHERE ("knowledge_type" = 'decision'::"text")
  ORDER BY "project_code", "recorded_at" DESC;


ALTER VIEW "public"."v_project_decisions" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_project_health_summary" AS
 SELECT "health_status",
    "count"(*) AS "project_count",
    "round"("avg"("overall_score"), 1) AS "avg_score",
    "min"("overall_score") AS "min_score",
    "max"("overall_score") AS "max_score"
   FROM "public"."project_health"
  GROUP BY "health_status";


ALTER VIEW "public"."v_project_health_summary" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_project_questions" AS
 SELECT "project_code",
    "project_name",
    "title",
    "content",
    "recorded_at",
    "follow_up_date",
    "importance"
   FROM "public"."project_knowledge" "pk"
  WHERE (("knowledge_type" = 'question'::"text") AND ("action_required" = true))
  ORDER BY "importance" DESC, "recorded_at" DESC;


ALTER VIEW "public"."v_project_questions" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_projects_needing_attention" AS
 SELECT "project_code",
    "project_name",
    "overall_score",
    "health_status",
    "momentum_score",
    "alerts",
    "calculated_at",
    (CURRENT_TIMESTAMP - "calculated_at") AS "time_since_calculation"
   FROM "public"."project_health"
  WHERE (("health_status" = ANY (ARRAY['attention'::"text", 'critical'::"text"])) OR ("overall_score" < 50))
  ORDER BY "overall_score";


ALTER VIEW "public"."v_projects_needing_attention" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_receipt_weekly_summary" AS
 SELECT "week_start",
    "total_pending",
    "resolved_count",
    "no_receipt_count",
    "deferred_count",
    ("resolved_count" + "no_receipt_count") AS "completed_count",
        CASE
            WHEN ("total_pending" > 0) THEN "round"(((100.0 * (("resolved_count" + "no_receipt_count"))::numeric) / ("total_pending")::numeric), 1)
            ELSE (100)::numeric
        END AS "completion_rate",
    "total_amount_pending",
    "total_amount_resolved",
    "is_perfect_week",
    "points_earned"
   FROM "public"."receipt_reconciliation_weeks"
  ORDER BY "week_start" DESC;


ALTER VIEW "public"."v_receipt_weekly_summary" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_recent_agent_errors" AS
 SELECT "agent_id",
    "action",
    "target_table",
    "error_message",
    "error_code",
    "timestamp",
    "duration_ms"
   FROM "public"."agent_audit_log"
  WHERE (("success" = false) AND ("timestamp" > ("now"() - '24:00:00'::interval)))
  ORDER BY "timestamp" DESC;


ALTER VIEW "public"."v_recent_agent_errors" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_recent_communications" AS
 SELECT "ch"."id",
    "ch"."ghl_contact_id",
    "ch"."channel",
    "ch"."direction",
    "ch"."from_identity",
    "ch"."to_identities",
    "ch"."subject",
    "ch"."content_preview",
    "ch"."full_content_ref",
    "ch"."summary",
    "ch"."sentiment",
    "ch"."topics",
    "ch"."action_items",
    "ch"."key_decisions",
    "ch"."waiting_for_response",
    "ch"."response_needed_by",
    "ch"."follow_up_date",
    "ch"."source_system",
    "ch"."source_id",
    "ch"."source_thread_id",
    "ch"."parent_id",
    "ch"."occurred_at",
    "ch"."synced_at",
    "ch"."enriched_at",
    "ch"."created_at",
    "ch"."updated_at",
    "c"."full_name" AS "contact_name",
    "c"."email" AS "contact_email",
    "c"."company_name",
    "rh"."temperature",
    "rh"."lcaa_stage"
   FROM (("public"."communications_history" "ch"
     LEFT JOIN "public"."ghl_contacts" "c" ON (("ch"."ghl_contact_id" = "c"."ghl_id")))
     LEFT JOIN "public"."relationship_health" "rh" ON (("ch"."ghl_contact_id" = "rh"."ghl_contact_id")))
  ORDER BY "ch"."occurred_at" DESC;


ALTER VIEW "public"."v_recent_communications" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_recent_project_knowledge" AS
 SELECT "id",
    "project_code",
    "project_name",
    "knowledge_type",
    "title",
    "content",
    "source_type",
    "source_ref",
    "source_url",
    "voice_note_id",
    "communication_id",
    "recorded_by",
    "recorded_at",
    "participants",
    "contact_ids",
    "summary",
    "topics",
    "sentiment",
    "importance",
    "action_required",
    "action_items",
    "follow_up_date",
    "decision_status",
    "decision_rationale",
    "embedding",
    "created_at",
    "updated_at",
        CASE
            WHEN ("recorded_at" >= ("now"() - '7 days'::interval)) THEN 'this_week'::"text"
            WHEN ("recorded_at" >= ("now"() - '30 days'::interval)) THEN 'this_month'::"text"
            ELSE 'older'::"text"
        END AS "recency"
   FROM "public"."project_knowledge" "pk"
  WHERE ("recorded_at" >= ("now"() - '30 days'::interval))
  ORDER BY "recorded_at" DESC;


ALTER VIEW "public"."v_recent_project_knowledge" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_script_api_costs" AS
 SELECT "script_name",
    "provider",
    "model",
    "count"(*) AS "calls",
    "sum"("total_tokens") AS "tokens",
    "round"("sum"(COALESCE("estimated_cost", (0)::numeric)), 4) AS "cost_usd",
    ("avg"("latency_ms"))::integer AS "avg_latency_ms",
    "round"(((100.0 * ("sum"(
        CASE
            WHEN "cache_hit" THEN 1
            ELSE 0
        END))::numeric) / (NULLIF("count"(*), 0))::numeric), 1) AS "cache_hit_pct"
   FROM "public"."api_usage"
  WHERE (("timestamp" > ("now"() - '7 days'::interval)) AND ("script_name" IS NOT NULL))
  GROUP BY "script_name", "provider", "model"
  ORDER BY ("round"("sum"(COALESCE("estimated_cost", (0)::numeric)), 4)) DESC;


ALTER VIEW "public"."v_script_api_costs" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_script_api_costs" IS 'Cost breakdown by script for optimization targeting';



CREATE OR REPLACE VIEW "public"."v_state_ecosystem_summary" AS
 SELECT "state",
    "count"(*) FILTER (WHERE ("operational_status" = 'operational'::"text")) AS "operational_facilities",
    "sum"("capacity_beds") AS "total_capacity",
    "sum"("current_population") AS "total_population",
    ( SELECT "count"(*) AS "count"
           FROM "public"."registered_services" "cp"
          WHERE ("cp"."state" = "ydf"."state")) AS "community_programs",
    ( SELECT "count"(*) AS "count"
           FROM "public"."services" "s"
          WHERE ("s"."location_state" = "ydf"."state")) AS "services",
    ( SELECT "count"(*) AS "count"
           FROM "public"."organizations" "o"
          WHERE (("o"."state" = "ydf"."state") AND "o"."is_active")) AS "organizations"
   FROM "public"."youth_detention_facilities" "ydf"
  GROUP BY "state";


ALTER VIEW "public"."v_state_ecosystem_summary" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_state_ecosystem_summary" IS 'State-level summary of detention facilities and community ecosystem';



CREATE TABLE IF NOT EXISTS "public"."voice_notes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "source_channel" "text" NOT NULL,
    "recorded_by" "uuid",
    "recorded_by_name" "text",
    "duration_seconds" integer,
    "file_size_bytes" integer,
    "audio_url" "text",
    "audio_format" "text" DEFAULT 'ogg'::"text",
    "transcript" "text",
    "transcript_confidence" numeric(3,2),
    "transcript_language" "text" DEFAULT 'en'::"text",
    "transcribed_at" timestamp with time zone,
    "transcription_model" "text",
    "summary" "text",
    "topics" "text"[],
    "action_items" "jsonb",
    "key_points" "text"[],
    "mentioned_people" "text"[],
    "mentioned_contacts" "uuid"[],
    "embedding" "public"."vector"(384),
    "visibility" "text" DEFAULT 'private'::"text",
    "shared_with" "uuid"[],
    "project_context" "text",
    "related_contact_id" "text",
    "related_communication_id" "uuid",
    "reply_to_voice_note_id" "uuid",
    "mentions_elders" boolean DEFAULT false,
    "requires_cultural_review" boolean DEFAULT false,
    "cultural_review_status" "text",
    "cultural_reviewer_notes" "text",
    "recorded_at" timestamp with time zone NOT NULL,
    "uploaded_at" timestamp with time zone DEFAULT "now"(),
    "enriched_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."voice_notes" OWNER TO "postgres";


COMMENT ON TABLE "public"."voice_notes" IS 'Voice notes with transcription, AI enrichment, and semantic search';



COMMENT ON COLUMN "public"."voice_notes"."embedding" IS 'all-MiniLM-L6-v2 embeddings for semantic search (384 dimensions)';



COMMENT ON COLUMN "public"."voice_notes"."mentions_elders" IS 'Auto-flagged if transcript mentions cultural keywords';



COMMENT ON COLUMN "public"."voice_notes"."requires_cultural_review" IS 'If true, note needs cultural liaison review before sharing';



CREATE OR REPLACE VIEW "public"."v_team_voice_notes" AS
 SELECT "vn"."id",
    "vn"."source_channel",
    "vn"."recorded_by",
    "vn"."recorded_by_name",
    "vn"."duration_seconds",
    "vn"."file_size_bytes",
    "vn"."audio_url",
    "vn"."audio_format",
    "vn"."transcript",
    "vn"."transcript_confidence",
    "vn"."transcript_language",
    "vn"."transcribed_at",
    "vn"."transcription_model",
    "vn"."summary",
    "vn"."topics",
    "vn"."action_items",
    "vn"."key_points",
    "vn"."mentioned_people",
    "vn"."mentioned_contacts",
    "vn"."embedding",
    "vn"."visibility",
    "vn"."shared_with",
    "vn"."project_context",
    "vn"."related_contact_id",
    "vn"."related_communication_id",
    "vn"."reply_to_voice_note_id",
    "vn"."mentions_elders",
    "vn"."requires_cultural_review",
    "vn"."cultural_review_status",
    "vn"."cultural_reviewer_notes",
    "vn"."recorded_at",
    "vn"."uploaded_at",
    "vn"."enriched_at",
    "vn"."created_at",
    "vn"."updated_at",
    "ui"."display_name" AS "recorder_display_name",
    "ui"."preferred_channel" AS "recorder_channel"
   FROM ("public"."voice_notes" "vn"
     LEFT JOIN "public"."user_identities" "ui" ON (("vn"."recorded_by" = "ui"."id")))
  WHERE ("vn"."visibility" = ANY (ARRAY['team'::"text", 'public'::"text"]))
  ORDER BY "vn"."recorded_at" DESC;


ALTER VIEW "public"."v_team_voice_notes" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_unified_contacts" AS
SELECT
    NULL::"uuid" AS "id",
    NULL::"text" AS "name",
    NULL::"text" AS "email",
    NULL::"text" AS "phone",
    NULL::"text" AS "company",
    NULL::numeric(3,2) AS "confidence",
    NULL::"text" AS "relationship_strength",
    NULL::"text"[] AS "primary_project_codes",
    NULL::"text"[] AS "sources",
    NULL::"text" AS "ghl_id",
    NULL::"text" AS "notion_id",
    NULL::bigint AS "identifier_count",
    NULL::timestamp with time zone AS "created_at",
    NULL::timestamp with time zone AS "updated_at";


ALTER VIEW "public"."v_unified_contacts" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_voice_notes_cultural_review" AS
 SELECT "vn"."id",
    "vn"."source_channel",
    "vn"."recorded_by",
    "vn"."recorded_by_name",
    "vn"."duration_seconds",
    "vn"."file_size_bytes",
    "vn"."audio_url",
    "vn"."audio_format",
    "vn"."transcript",
    "vn"."transcript_confidence",
    "vn"."transcript_language",
    "vn"."transcribed_at",
    "vn"."transcription_model",
    "vn"."summary",
    "vn"."topics",
    "vn"."action_items",
    "vn"."key_points",
    "vn"."mentioned_people",
    "vn"."mentioned_contacts",
    "vn"."embedding",
    "vn"."visibility",
    "vn"."shared_with",
    "vn"."project_context",
    "vn"."related_contact_id",
    "vn"."related_communication_id",
    "vn"."reply_to_voice_note_id",
    "vn"."mentions_elders",
    "vn"."requires_cultural_review",
    "vn"."cultural_review_status",
    "vn"."cultural_reviewer_notes",
    "vn"."recorded_at",
    "vn"."uploaded_at",
    "vn"."enriched_at",
    "vn"."created_at",
    "vn"."updated_at",
    "ui"."display_name" AS "recorder_display_name"
   FROM ("public"."voice_notes" "vn"
     LEFT JOIN "public"."user_identities" "ui" ON (("vn"."recorded_by" = "ui"."id")))
  WHERE (("vn"."requires_cultural_review" = true) AND ("vn"."cultural_review_status" = 'pending'::"text"))
  ORDER BY "vn"."recorded_at";


ALTER VIEW "public"."v_voice_notes_cultural_review" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_voice_notes_with_actions" AS
 SELECT "id",
    "summary",
    "recorded_by_name",
    "recorded_at",
    "project_context",
    "jsonb_array_elements"("action_items") AS "action_item"
   FROM "public"."voice_notes" "vn"
  WHERE (("action_items" IS NOT NULL) AND ("jsonb_array_length"("action_items") > 0))
  ORDER BY "recorded_at" DESC;


ALTER VIEW "public"."v_voice_notes_with_actions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."volunteer_hours" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ghl_contact_id" "text",
    "hours" numeric(6,2) NOT NULL,
    "date" "date" NOT NULL,
    "activity" "text" NOT NULL,
    "project" "text",
    "verified" boolean DEFAULT false,
    "verified_by" "text",
    "verified_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."volunteer_hours" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_volunteer_summary" AS
 SELECT "c"."ghl_id",
    "c"."full_name",
    "c"."email",
    COALESCE("sum"("vh"."hours"), (0)::numeric) AS "total_hours",
    "count"("vh"."id") AS "session_count",
    "max"("vh"."date") AS "last_volunteered",
    "array_agg"(DISTINCT "vh"."project") FILTER (WHERE ("vh"."project" IS NOT NULL)) AS "projects_volunteered"
   FROM ("public"."ghl_contacts" "c"
     LEFT JOIN "public"."volunteer_hours" "vh" ON (("c"."ghl_id" = "vh"."ghl_contact_id")))
  GROUP BY "c"."ghl_id", "c"."full_name", "c"."email";


ALTER VIEW "public"."v_volunteer_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."vendor_contact_log" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "subscription_id" "uuid" NOT NULL,
    "vendor_email" "text" NOT NULL,
    "email_subject" "text",
    "email_body" "text",
    "sent_at" timestamp with time zone,
    "status" "text" DEFAULT 'queued'::"text",
    "retry_count" integer DEFAULT 0,
    "last_retry_at" timestamp with time zone,
    "error_message" "text",
    "gmail_message_id" "text",
    "gmail_thread_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "vendor_contact_log_status_check" CHECK (("status" = ANY (ARRAY['queued'::"text", 'sent'::"text", 'failed'::"text", 'bounced'::"text", 'replied'::"text"])))
);


ALTER TABLE "public"."vendor_contact_log" OWNER TO "postgres";


COMMENT ON TABLE "public"."vendor_contact_log" IS 'Tracks all automated vendor contact emails sent for email migration';



CREATE TABLE IF NOT EXISTS "public"."video_embeds" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "platform" "text" NOT NULL,
    "video_id" "text" NOT NULL,
    "embed_url" "text" NOT NULL,
    "thumbnail_url" "text",
    "title" "text",
    "description" "text",
    "duration_seconds" integer,
    "link_type" "text",
    "link_id" "text",
    "display_order" integer DEFAULT 0,
    "is_featured" boolean DEFAULT false,
    "autoplay" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "video_embeds_link_type_check" CHECK (("link_type" = ANY (ARRAY['project_page'::"text", 'blog_post'::"text", 'gallery'::"text", 'timeline_entry'::"text", 'standalone'::"text"]))),
    CONSTRAINT "video_embeds_platform_check" CHECK (("platform" = ANY (ARRAY['youtube'::"text", 'vimeo'::"text", 'loom'::"text", 'descript'::"text", 'direct'::"text"])))
);


ALTER TABLE "public"."video_embeds" OWNER TO "postgres";


COMMENT ON TABLE "public"."video_embeds" IS 'External video embeds from YouTube, Vimeo, Loom, etc.';



COMMENT ON CONSTRAINT "video_embeds_platform_check" ON "public"."video_embeds" IS 'Supports YouTube, Vimeo, Loom, Descript, and direct video files';



CREATE TABLE IF NOT EXISTS "public"."voice_note_shares" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "voice_note_id" "uuid" NOT NULL,
    "shared_with" "uuid" NOT NULL,
    "shared_by" "uuid",
    "share_method" "text",
    "accessed_at" timestamp with time zone,
    "access_count" integer DEFAULT 0,
    "can_reshare" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."voice_note_shares" OWNER TO "postgres";


COMMENT ON TABLE "public"."voice_note_shares" IS 'Tracks sharing and access to voice notes';



CREATE TABLE IF NOT EXISTS "public"."volunteer_interest" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "name" "text" NOT NULL,
    "email" "text" NOT NULL,
    "phone" "text",
    "skills" "text"[],
    "interests" "text"[],
    "availability" "text",
    "location" "text",
    "experience_level" "text",
    "preferred_contribution" "text",
    "message" "text",
    "status" "text" DEFAULT 'pending'::"text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."volunteer_interest" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_alma_intervention_matches" AS
 SELECT "pcm"."id",
    "pcm"."contact_id",
    "pcm"."person_id",
    "pcm"."project_notion_id",
    "pcm"."project_name",
    "pcm"."project_source",
    "pcm"."alignment_score",
    "pcm"."matched_keywords",
    "pcm"."match_reason",
    "pcm"."alma_intervention_id",
    "pcm"."alma_signal_boost",
    "pcm"."engagement_status",
    "pcm"."created_at",
    "pcm"."updated_at",
    "lc"."full_name",
    "lc"."email_address",
    "lc"."alignment_tags",
    "lc"."strategic_value"
   FROM ("public"."project_contact_matches" "pcm"
     LEFT JOIN "public"."linkedin_contacts" "lc" ON (("pcm"."contact_id" = "lc"."id")))
  WHERE (("pcm"."project_source" = 'justicehub'::"text") AND ("pcm"."alma_intervention_id" IS NOT NULL) AND ("pcm"."alignment_score" >= 60))
  ORDER BY "pcm"."alignment_score" DESC;


ALTER VIEW "public"."vw_alma_intervention_matches" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_alma_intervention_matches" IS 'Shows contacts matched to ALMA interventions (JusticeHub youth justice domain).
Filtered to high-alignment matches (â‰¥60%) for funder intelligence packs.';



CREATE OR REPLACE VIEW "public"."vw_auto_mapped_contacts" AS
 SELECT "lc"."id" AS "linkedin_contact_id",
    "lc"."full_name",
    "lc"."email_address",
    "lc"."current_company",
    "lc"."bio",
    "lc"."exa_confidence_score",
    "lc"."exa_last_enriched",
    "pim"."person_id",
    "pim"."engagement_priority",
    "pim"."data_source",
    "pim"."discovered_via",
    "pim"."created_at" AS "person_created_at"
   FROM ("public"."linkedin_contacts" "lc"
     JOIN "public"."person_identity_map" "pim" ON (("pim"."person_id" = "lc"."person_id")))
  WHERE (("lc"."exa_enriched" = true) AND ("pim"."data_source" = 'exa_enrichment'::"text"))
  ORDER BY "lc"."exa_last_enriched" DESC;


ALTER VIEW "public"."vw_auto_mapped_contacts" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_auto_mapped_contacts" IS 'Shows linkedin_contacts that were auto-mapped to person_identity_map via Exa enrichment trigger';



CREATE OR REPLACE VIEW "public"."vw_beautiful_obsolescence_progress" AS
 SELECT "pipeline_type",
    "current_stage",
    "act_energy_percent",
    "count"(*) AS "contact_count",
    "sum"(
        CASE
            WHEN "obsolescence_achieved" THEN 1
            ELSE 0
        END) AS "obsolete_count",
    "round"(((100.0 * ("sum"(
        CASE
            WHEN "obsolescence_achieved" THEN 1
            ELSE 0
        END))::numeric) / ("count"(*))::numeric), 2) AS "obsolescence_rate_percent"
   FROM "public"."ghl_engagement_metrics" "gem"
  GROUP BY "pipeline_type", "current_stage", "act_energy_percent"
  ORDER BY "pipeline_type", "act_energy_percent" DESC;


ALTER VIEW "public"."vw_beautiful_obsolescence_progress" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_beautiful_obsolescence_progress" IS 'Dashboard view showing Beautiful Obsolescence progress by pipeline.
Tracks how many contacts have achieved independence (obsolescence_achieved = true).
Higher obsolescence_rate_percent = more mission success!';



CREATE OR REPLACE VIEW "public"."vw_engagement_tier_stats" AS
 SELECT "engagement_priority" AS "tier",
    "count"(*) AS "total_contacts",
    "count"(
        CASE
            WHEN ("notion_person_id" IS NOT NULL) THEN 1
            ELSE NULL::integer
        END) AS "synced_to_notion",
    "count"(
        CASE
            WHEN ("sector" = 'government'::"text") THEN 1
            ELSE NULL::integer
        END) AS "government_contacts"
   FROM "public"."person_identity_map"
  WHERE ("email" IS NOT NULL)
  GROUP BY "engagement_priority";


ALTER VIEW "public"."vw_engagement_tier_stats" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_exa_queue_summary" AS
 SELECT "campaign_type",
    "status",
    "count"(*) AS "count",
    "avg"("priority") AS "avg_priority",
    "min"("queued_at") AS "oldest_queued",
    "max"("queued_at") AS "newest_queued"
   FROM "public"."exa_enrichment_queue"
  GROUP BY "campaign_type", "status"
  ORDER BY "campaign_type", "status";


ALTER VIEW "public"."vw_exa_queue_summary" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_exa_usage_summary" AS
 SELECT "period_month",
    "total_requests",
    "successful_requests",
    "failed_requests",
    "free_tier_limit",
    "free_tier_remaining",
    "free_tier_exceeded",
    "linkedin_requests",
    "company_requests",
    "media_requests",
    "network_discovery_requests",
    "round"(((("total_requests")::numeric / ("free_tier_limit")::numeric) * (100)::numeric), 2) AS "usage_percentage",
    "estimated_cost_usd"
   FROM "public"."exa_api_usage"
  ORDER BY "period_month" DESC;


ALTER VIEW "public"."vw_exa_usage_summary" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_goods_enrichment_candidates" AS
 SELECT "p"."person_id",
    "p"."full_name",
    "p"."email",
    "p"."current_company",
    "p"."current_position",
    "p"."tags",
    "p"."engagement_priority",
    "p"."exa_enriched",
    "p"."exa_enriched_at",
    "cis"."composite_score",
    "cis"."influence_score",
        CASE
            WHEN ("p"."engagement_priority" = 'critical'::"text") THEN 100
            WHEN ("p"."engagement_priority" = 'high'::"text") THEN 75
            WHEN ("p"."engagement_priority" = 'medium'::"text") THEN 50
            ELSE 25
        END AS "enrichment_priority"
   FROM ("public"."person_identity_map" "p"
     LEFT JOIN "public"."contact_intelligence_scores" "cis" ON (("p"."person_id" = "cis"."person_id")))
  WHERE (("p"."exa_enriched" = false) AND ("p"."email" IS NOT NULL) AND (('goods-on-country'::"text" = ANY ("p"."tags")) OR ('circular-economy'::"text" = ANY ("p"."tags")) OR ('indigenous-business'::"text" = ANY ("p"."tags")) OR ('sustainable-products'::"text" = ANY ("p"."tags")) OR ("p"."sector" = 'retail'::"text") OR ("p"."sector" = 'manufacturing'::"text")))
  ORDER BY
        CASE
            WHEN ("p"."engagement_priority" = 'critical'::"text") THEN 100
            WHEN ("p"."engagement_priority" = 'high'::"text") THEN 75
            WHEN ("p"."engagement_priority" = 'medium'::"text") THEN 50
            ELSE 25
        END DESC, "cis"."composite_score" DESC NULLS LAST;


ALTER VIEW "public"."vw_goods_enrichment_candidates" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_high_value_project_matches" AS
 SELECT "pcm"."id",
    "pcm"."contact_id",
    "pcm"."person_id",
    "pcm"."project_notion_id",
    "pcm"."project_name",
    "pcm"."project_source",
    "pcm"."alignment_score",
    "pcm"."matched_keywords",
    "pcm"."match_reason",
    "pcm"."alma_intervention_id",
    "pcm"."alma_signal_boost",
    "pcm"."engagement_status",
    "pcm"."created_at",
    "pcm"."updated_at",
    "lc"."full_name",
    "lc"."email_address",
    "lc"."linkedin_url",
    "lc"."current_company",
    "lc"."current_position",
    "lc"."strategic_value",
    "lc"."alignment_tags",
    "pim"."notion_person_id",
    "pim"."ghl_contact_id"
   FROM (("public"."project_contact_matches" "pcm"
     LEFT JOIN "public"."linkedin_contacts" "lc" ON (("pcm"."contact_id" = "lc"."id")))
     LEFT JOIN "public"."person_identity_map" "pim" ON (("pcm"."person_id" = "pim"."person_id")))
  WHERE (("pcm"."alignment_score" >= 60) AND ("pcm"."engagement_status" <> 'obsolete'::"text"))
  ORDER BY "pcm"."alignment_score" DESC, "pcm"."created_at" DESC;


ALTER VIEW "public"."vw_high_value_project_matches" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_high_value_project_matches" IS 'Shows all project-contact matches with alignment score â‰¥ 60.
Includes contact details, strategic value, and cross-system IDs (Notion, GHL).
Used for prioritizing outreach and CRM workflows.';



CREATE OR REPLACE VIEW "public"."vw_justice_enrichment_candidates" AS
 SELECT "p"."person_id",
    "p"."full_name",
    "p"."email",
    "p"."current_company",
    "p"."current_position",
    "p"."tags",
    "p"."engagement_priority",
    "p"."youth_justice_relevance_score",
    "p"."exa_enriched",
    "p"."exa_enriched_at",
    "cis"."composite_score",
    "cis"."influence_score",
        CASE
            WHEN ("p"."engagement_priority" = 'critical'::"text") THEN 100
            WHEN ("p"."engagement_priority" = 'high'::"text") THEN 75
            WHEN ("p"."youth_justice_relevance_score" > 70) THEN 80
            WHEN ("p"."engagement_priority" = 'medium'::"text") THEN 50
            ELSE 25
        END AS "enrichment_priority"
   FROM ("public"."person_identity_map" "p"
     LEFT JOIN "public"."contact_intelligence_scores" "cis" ON (("p"."person_id" = "cis"."person_id")))
  WHERE (("p"."exa_enriched" = false) AND ("p"."email" IS NOT NULL) AND (("p"."youth_justice_relevance_score" > 50) OR ('youth-justice'::"text" = ANY ("p"."tags")) OR ('juvenile-justice'::"text" = ANY ("p"."tags")) OR ('restorative-justice'::"text" = ANY ("p"."tags")) OR ('indigenous-youth'::"text" = ANY ("p"."tags"))))
  ORDER BY
        CASE
            WHEN ("p"."engagement_priority" = 'critical'::"text") THEN 100
            WHEN ("p"."engagement_priority" = 'high'::"text") THEN 75
            WHEN ("p"."youth_justice_relevance_score" > 70) THEN 80
            WHEN ("p"."engagement_priority" = 'medium'::"text") THEN 50
            ELSE 25
        END DESC, "p"."youth_justice_relevance_score" DESC NULLS LAST, "cis"."composite_score" DESC NULLS LAST;


ALTER VIEW "public"."vw_justice_enrichment_candidates" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_newsletter_segments" AS
 SELECT "p"."person_id",
    "p"."full_name",
    "p"."email",
    "p"."engagement_priority",
    "p"."alignment_tags",
    "p"."sector",
    "s"."composite_score",
        CASE "p"."engagement_priority"
            WHEN 'critical'::"text" THEN 'executive_summary'::"text"
            WHEN 'high'::"text" THEN 'tailored_content'::"text"
            WHEN 'medium'::"text" THEN 'general_newsletter'::"text"
            WHEN 'low'::"text" THEN 'annual_summary'::"text"
            ELSE NULL::"text"
        END AS "newsletter_type"
   FROM ("public"."person_identity_map" "p"
     LEFT JOIN "public"."contact_intelligence_scores" "s" ON (("p"."person_id" = "s"."person_id")))
  WHERE ("p"."email" IS NOT NULL);


ALTER VIEW "public"."vw_newsletter_segments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."wiki_articles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "slug" "text" NOT NULL,
    "title" "text" NOT NULL,
    "category" "text" NOT NULL,
    "content" "text" NOT NULL,
    "excerpt" "text",
    "tags" "text"[] DEFAULT '{}'::"text"[],
    "author_id" "uuid",
    "parent_id" "uuid",
    "order_index" integer DEFAULT 0,
    "is_published" boolean DEFAULT true,
    "view_count" integer DEFAULT 0,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "wiki_articles_category_check" CHECK (("category" = ANY (ARRAY['philosophy'::"text", 'process'::"text", 'project'::"text", 'reference'::"text", 'template'::"text"])))
);


ALTER TABLE "public"."wiki_articles" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."wiki_hierarchy" AS
 WITH RECURSIVE "hierarchy" AS (
         SELECT "wiki_pages"."id",
            "wiki_pages"."title",
            "wiki_pages"."slug",
            "wiki_pages"."page_type",
            ARRAY["wiki_pages"."id"] AS "path",
            ARRAY["wiki_pages"."title"] AS "breadcrumb",
            1 AS "level"
           FROM "public"."wiki_pages"
          WHERE (("wiki_pages"."page_type" = 'principle'::"text") AND ("wiki_pages"."status" = 'active'::"text"))
        UNION ALL
         SELECT "w"."id",
            "w"."title",
            "w"."slug",
            "w"."page_type",
            ("h"."path" || "w"."id"),
            ("h"."breadcrumb" || "w"."title"),
            ("h"."level" + 1)
           FROM ("public"."wiki_pages" "w"
             JOIN "hierarchy" "h" ON ((("w"."parent_principle_id" = "h"."id") OR ("w"."parent_method_id" = "h"."id") OR ("w"."parent_practice_id" = "h"."id"))))
          WHERE ("w"."status" = 'active'::"text")
        )
 SELECT "id",
    "title",
    "slug",
    "page_type",
    "path",
    "breadcrumb",
    "level"
   FROM "hierarchy";


ALTER VIEW "public"."wiki_hierarchy" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."wiki_page_versions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "page_id" "uuid" NOT NULL,
    "version" integer NOT NULL,
    "title" "text" NOT NULL,
    "content" "text" NOT NULL,
    "excerpt" "text",
    "changed_by" "uuid",
    "change_reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."wiki_page_versions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."wisdom_extracts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "storyteller_id" "uuid",
    "transcript_analysis_id" "uuid",
    "wisdom_type" "public"."wisdom_type_enum" NOT NULL,
    "extracted_quote" "text" NOT NULL,
    "context_before" "text",
    "context_after" "text",
    "ai_confidence_score" numeric(4,3),
    "cultural_appropriateness_score" numeric(4,3),
    "human_validated" boolean DEFAULT false,
    "validation_notes" "text",
    "sharing_approved" boolean DEFAULT false,
    "attribution_required" boolean DEFAULT true,
    "context_required" boolean DEFAULT true,
    "themes" "text"[],
    "emotional_tone" character varying(50),
    "life_stage" character varying(50),
    "relevance_keywords" "text"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."wisdom_extracts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."wisdom_insights" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "storyteller_id" "uuid",
    "insight_text" "text" NOT NULL,
    "context" "text",
    "life_area" "text",
    "universality_score" double precision,
    "source_story" "uuid",
    "source_transcript" "uuid",
    "sharing_level" "text" DEFAULT 'community'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "wisdom_insights_sharing_level_check" CHECK (("sharing_level" = ANY (ARRAY['private'::"text", 'community'::"text", 'public'::"text", 'universal'::"text"]))),
    CONSTRAINT "wisdom_insights_universality_score_check" CHECK ((("universality_score" >= (0)::double precision) AND ("universality_score" <= (1)::double precision)))
);


ALTER TABLE "public"."wisdom_insights" OWNER TO "postgres";


COMMENT ON TABLE "public"."wisdom_insights" IS 'Universal wisdom and insights shared by storytellers in their natural voice';



CREATE TABLE IF NOT EXISTS "public"."xero_bas_tracking" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "tenant_id" "text" NOT NULL,
    "period_start" "date" NOT NULL,
    "period_end" "date" NOT NULL,
    "gst_on_sales" numeric(15,2) DEFAULT 0,
    "gst_on_purchases" numeric(15,2) DEFAULT 0,
    "payg_withheld" numeric(15,2) DEFAULT 0,
    "net_gst" numeric(15,2) DEFAULT 0,
    "status" "text" DEFAULT 'draft'::"text",
    "lodged_date" "date",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "xero_bas_tracking_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'ready_to_lodge'::"text", 'lodged'::"text", 'overdue'::"text"])))
);


ALTER TABLE "public"."xero_bas_tracking" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."xero_contacts" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "xero_id" "text" NOT NULL,
    "tenant_id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "email" "text",
    "first_name" "text",
    "last_name" "text",
    "is_customer" boolean DEFAULT false,
    "is_supplier" boolean DEFAULT false,
    "abn" "text",
    "tax_number" "text",
    "account_number" "text",
    "balance" numeric(15,2) DEFAULT 0,
    "outstanding_receivable" numeric(15,2) DEFAULT 0,
    "outstanding_payable" numeric(15,2) DEFAULT 0,
    "addresses" "jsonb",
    "phones" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "synced_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."xero_contacts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."xero_financial_alerts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "alert_type" character varying(100) NOT NULL,
    "priority" character varying(20) DEFAULT 'medium'::character varying NOT NULL,
    "message" "text" NOT NULL,
    "related_invoice_id" "uuid",
    "related_xero_id" character varying(255),
    "amount" numeric(15,2),
    "detected_at" timestamp with time zone DEFAULT "now"(),
    "acknowledged_at" timestamp with time zone,
    "resolved_at" timestamp with time zone,
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."xero_financial_alerts" OWNER TO "postgres";


COMMENT ON TABLE "public"."xero_financial_alerts" IS 'Financial alerts (overdue invoices, large amounts, etc.) with lifecycle tracking';



CREATE TABLE IF NOT EXISTS "public"."xero_invoices" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "xero_id" "text" NOT NULL,
    "tenant_id" "text" NOT NULL,
    "invoice_number" "text",
    "type" "text" NOT NULL,
    "status" "text",
    "contact_id" "text",
    "contact_name" "text",
    "date" "date",
    "due_date" "date",
    "total" numeric(15,2),
    "subtotal" numeric(15,2),
    "total_tax" numeric(15,2),
    "amount_due" numeric(15,2),
    "amount_paid" numeric(15,2),
    "currency_code" "text" DEFAULT 'AUD'::"text",
    "line_items" "jsonb",
    "has_attachments" boolean DEFAULT false,
    "reference" "text",
    "url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "synced_at" timestamp with time zone DEFAULT "now"(),
    "invoice_type" character varying(50),
    "tracking_category_1" character varying(255),
    "tracking_option_1" character varying(255),
    "tracking_category_2" character varying(255),
    "tracking_option_2" character varying(255),
    "contact_xero_id" character varying(255),
    CONSTRAINT "xero_invoices_type_check" CHECK (("type" = ANY (ARRAY['ACCREC'::"text", 'ACCPAY'::"text"])))
);


ALTER TABLE "public"."xero_invoices" OWNER TO "postgres";


COMMENT ON TABLE "public"."xero_invoices" IS 'Xero invoices and bills for financial tracking. Type: ACCREC (receivable) or ACCPAY (payable)';



CREATE OR REPLACE VIEW "public"."xero_financial_health" AS
 SELECT ( SELECT COALESCE("sum"("xero_invoices"."amount_due"), (0)::numeric) AS "coalesce"
           FROM "public"."xero_invoices"
          WHERE ((("xero_invoices"."invoice_type")::"text" = 'ACCREC'::"text") AND ("xero_invoices"."status" = ANY (ARRAY['AUTHORISED'::"text", 'SUBMITTED'::"text"])) AND ("xero_invoices"."amount_due" > (0)::numeric))) AS "total_receivables",
    ( SELECT "count"(*) AS "count"
           FROM "public"."xero_invoices"
          WHERE ((("xero_invoices"."invoice_type")::"text" = 'ACCREC'::"text") AND ("xero_invoices"."status" = ANY (ARRAY['AUTHORISED'::"text", 'SUBMITTED'::"text"])) AND ("xero_invoices"."amount_due" > (0)::numeric))) AS "receivable_count",
    ( SELECT COALESCE("sum"("xero_invoices"."amount_due"), (0)::numeric) AS "coalesce"
           FROM "public"."xero_invoices"
          WHERE ((("xero_invoices"."invoice_type")::"text" = 'ACCREC'::"text") AND ("xero_invoices"."status" = ANY (ARRAY['AUTHORISED'::"text", 'SUBMITTED'::"text"])) AND ("xero_invoices"."amount_due" > (0)::numeric) AND ("xero_invoices"."due_date" < CURRENT_DATE))) AS "overdue_receivables",
    ( SELECT "count"(*) AS "count"
           FROM "public"."xero_invoices"
          WHERE ((("xero_invoices"."invoice_type")::"text" = 'ACCREC'::"text") AND ("xero_invoices"."status" = ANY (ARRAY['AUTHORISED'::"text", 'SUBMITTED'::"text"])) AND ("xero_invoices"."amount_due" > (0)::numeric) AND ("xero_invoices"."due_date" < CURRENT_DATE))) AS "overdue_count",
    ( SELECT COALESCE("sum"("xero_invoices"."amount_due"), (0)::numeric) AS "coalesce"
           FROM "public"."xero_invoices"
          WHERE ((("xero_invoices"."invoice_type")::"text" = 'ACCPAY'::"text") AND ("xero_invoices"."status" = ANY (ARRAY['AUTHORISED'::"text", 'SUBMITTED'::"text"])) AND ("xero_invoices"."amount_due" > (0)::numeric))) AS "total_payables",
    ( SELECT "count"(*) AS "count"
           FROM "public"."xero_invoices"
          WHERE ((("xero_invoices"."invoice_type")::"text" = 'ACCPAY'::"text") AND ("xero_invoices"."status" = ANY (ARRAY['AUTHORISED'::"text", 'SUBMITTED'::"text"])) AND ("xero_invoices"."amount_due" > (0)::numeric))) AS "payable_count",
    ( SELECT COALESCE("sum"("xero_invoices"."amount_due"), (0)::numeric) AS "coalesce"
           FROM "public"."xero_invoices"
          WHERE ((("xero_invoices"."invoice_type")::"text" = 'ACCPAY'::"text") AND ("xero_invoices"."status" = ANY (ARRAY['AUTHORISED'::"text", 'SUBMITTED'::"text"])) AND ("xero_invoices"."amount_due" > (0)::numeric) AND ("xero_invoices"."due_date" <= (CURRENT_DATE + '7 days'::interval)))) AS "payables_due_this_week",
    ( SELECT "max"("xero_invoices"."synced_at") AS "max"
           FROM "public"."xero_invoices") AS "last_sync";


ALTER VIEW "public"."xero_financial_health" OWNER TO "postgres";


COMMENT ON VIEW "public"."xero_financial_health" IS 'Summary view of current financial position';



CREATE TABLE IF NOT EXISTS "public"."xero_financial_snapshots" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "snapshot_date" "date" NOT NULL,
    "snapshot_type" character varying(20) DEFAULT 'daily'::character varying NOT NULL,
    "ar_total" numeric(15,2) DEFAULT 0,
    "ar_count" integer DEFAULT 0,
    "ar_overdue_total" numeric(15,2) DEFAULT 0,
    "ar_overdue_count" integer DEFAULT 0,
    "ar_overdue_1_30_days" numeric(15,2) DEFAULT 0,
    "ar_overdue_31_60_days" numeric(15,2) DEFAULT 0,
    "ar_overdue_61_90_days" numeric(15,2) DEFAULT 0,
    "ar_overdue_90_plus_days" numeric(15,2) DEFAULT 0,
    "ap_total" numeric(15,2) DEFAULT 0,
    "ap_count" integer DEFAULT 0,
    "ap_due_this_week" numeric(15,2) DEFAULT 0,
    "ap_due_this_month" numeric(15,2) DEFAULT 0,
    "net_position" numeric(15,2) DEFAULT 0,
    "revenue_this_period" numeric(15,2) DEFAULT 0,
    "invoices_issued_this_period" integer DEFAULT 0,
    "rd_spend_this_period" numeric(15,2) DEFAULT 0,
    "rd_tracking_category" character varying(255),
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."xero_financial_snapshots" OWNER TO "postgres";


COMMENT ON TABLE "public"."xero_financial_snapshots" IS 'Daily/weekly financial snapshots for trend analysis and reporting';



CREATE OR REPLACE VIEW "public"."xero_overdue_receivables" AS
 SELECT "id",
    "xero_id",
    "tenant_id",
    "invoice_number",
    "type",
    "status",
    "contact_id",
    "contact_name",
    "date",
    "due_date",
    "total",
    "subtotal",
    "total_tax",
    "amount_due",
    "amount_paid",
    "currency_code",
    "line_items",
    "has_attachments",
    "reference",
    "url",
    "created_at",
    "updated_at",
    "synced_at",
    "invoice_type",
    "tracking_category_1",
    "tracking_option_1",
    "tracking_category_2",
    "tracking_option_2",
    "contact_xero_id",
    (CURRENT_DATE - "due_date") AS "days_overdue",
        CASE
            WHEN ((CURRENT_DATE - "due_date") <= 30) THEN '1-30 days'::"text"
            WHEN ((CURRENT_DATE - "due_date") <= 60) THEN '31-60 days'::"text"
            WHEN ((CURRENT_DATE - "due_date") <= 90) THEN '61-90 days'::"text"
            ELSE '90+ days'::"text"
        END AS "aging_bucket"
   FROM "public"."xero_invoices" "xi"
  WHERE ((("invoice_type")::"text" = 'ACCREC'::"text") AND ("status" = ANY (ARRAY['AUTHORISED'::"text", 'SUBMITTED'::"text"])) AND ("amount_due" > (0)::numeric) AND ("due_date" < CURRENT_DATE))
  ORDER BY "due_date";


ALTER VIEW "public"."xero_overdue_receivables" OWNER TO "postgres";


COMMENT ON VIEW "public"."xero_overdue_receivables" IS 'Current overdue receivables with aging analysis';



CREATE TABLE IF NOT EXISTS "public"."xero_sync_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "sync_type" "text" NOT NULL,
    "records_synced" integer DEFAULT 0,
    "records_failed" integer DEFAULT 0,
    "duration_ms" integer,
    "errors" "jsonb" DEFAULT '[]'::"jsonb",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "started_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    "status" "text" DEFAULT 'running'::"text"
);


ALTER TABLE "public"."xero_sync_log" OWNER TO "postgres";


COMMENT ON TABLE "public"."xero_sync_log" IS 'Audit trail for Xero sync operations';



CREATE TABLE IF NOT EXISTS "public"."xero_sync_status" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "tenant_id" "text" NOT NULL,
    "organization_name" "text",
    "sync_status" "text" DEFAULT 'idle'::"text",
    "last_sync" timestamp with time zone,
    "next_sync" timestamp with time zone,
    "total_invoices" integer DEFAULT 0,
    "total_bills" integer DEFAULT 0,
    "total_contacts" integer DEFAULT 0,
    "synced_items" integer DEFAULT 0,
    "error_count" integer DEFAULT 0,
    "error_message" "text",
    "last_error" timestamp with time zone,
    "sync_duration_ms" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "xero_sync_status_sync_status_check" CHECK (("sync_status" = ANY (ARRAY['idle'::"text", 'syncing'::"text", 'completed'::"text", 'error'::"text"])))
);


ALTER TABLE "public"."xero_sync_status" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."xero_tokens" (
    "id" "text" DEFAULT 'default'::"text" NOT NULL,
    "refresh_token" "text" NOT NULL,
    "access_token" "text",
    "expires_at" timestamp with time zone,
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "updated_by" "text" DEFAULT 'system'::"text"
);


ALTER TABLE "public"."xero_tokens" OWNER TO "postgres";


COMMENT ON TABLE "public"."xero_tokens" IS 'Secure storage for Xero OAuth tokens - shared between local and CI';



CREATE TABLE IF NOT EXISTS "public"."xero_transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "xero_transaction_id" "text" NOT NULL,
    "type" "text",
    "contact_name" "text",
    "bank_account" "text",
    "project_code" "text",
    "total" numeric(12,2),
    "status" "text" DEFAULT 'ACTIVE'::"text",
    "date" "date",
    "line_items" "jsonb" DEFAULT '[]'::"jsonb",
    "synced_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "has_attachments" boolean DEFAULT false
);


ALTER TABLE "public"."xero_transactions" OWNER TO "postgres";


COMMENT ON TABLE "public"."xero_transactions" IS 'Bank transactions synced from Xero for project cost tracking';



CREATE OR REPLACE VIEW "public"."xero_upcoming_payables" AS
 SELECT "id",
    "xero_id",
    "tenant_id",
    "invoice_number",
    "type",
    "status",
    "contact_id",
    "contact_name",
    "date",
    "due_date",
    "total",
    "subtotal",
    "total_tax",
    "amount_due",
    "amount_paid",
    "currency_code",
    "line_items",
    "has_attachments",
    "reference",
    "url",
    "created_at",
    "updated_at",
    "synced_at",
    "invoice_type",
    "tracking_category_1",
    "tracking_option_1",
    "tracking_category_2",
    "tracking_option_2",
    "contact_xero_id",
    ("due_date" - CURRENT_DATE) AS "days_until_due"
   FROM "public"."xero_invoices" "xi"
  WHERE ((("invoice_type")::"text" = 'ACCPAY'::"text") AND ("status" = ANY (ARRAY['AUTHORISED'::"text", 'SUBMITTED'::"text"])) AND ("amount_due" > (0)::numeric) AND ("due_date" >= CURRENT_DATE))
  ORDER BY "due_date";


ALTER VIEW "public"."xero_upcoming_payables" OWNER TO "postgres";


COMMENT ON VIEW "public"."xero_upcoming_payables" IS 'Bills due in the future, sorted by due date';



ALTER TABLE ONLY "drizzle"."__drizzle_migrations" ALTER COLUMN "id" SET DEFAULT "nextval"('"drizzle"."__drizzle_migrations_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."_act_migrations" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."_act_migrations_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."app_users" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."app_users_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."billing_coupons" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."billing_coupons_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."billing_customers" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."billing_customers_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."billing_invoice_lines" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."billing_invoice_lines_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."billing_invoices" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."billing_invoices_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."billing_payments" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."billing_payments_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."billing_prices" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."billing_prices_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."billing_products" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."billing_products_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."billing_subscription_items" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."billing_subscription_items_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."billing_subscriptions" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."billing_subscriptions_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."billing_tax_rates" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."billing_tax_rates_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."billing_webhook_events" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."billing_webhook_events_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."bookkeeping_project_links" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."bookkeeping_project_links_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."bookkeeping_receipts" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."bookkeeping_receipts_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."bookkeeping_rules" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."bookkeeping_rules_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."bookkeeping_transactions" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."bookkeeping_transactions_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."businesses" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."businesses_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."contact_edges" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."contact_edges_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."contact_invites" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."contact_invites_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."events_old_backup" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."events_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."fellows" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."fellows_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."harvest_businesses" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."harvest_businesses_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."harvest_events" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."harvest_events_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."interactions" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."interactions_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."linkedin_imports" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."linkedin_imports_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."opportunities" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."opportunities_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."privacy_audit_log" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."privacy_audit_log_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."privacy_dsr_requests" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."privacy_dsr_requests_id_seq"'::"regclass");



ALTER TABLE ONLY "drizzle"."__drizzle_migrations"
    ADD CONSTRAINT "__drizzle_migrations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."_act_migrations"
    ADD CONSTRAINT "_act_migrations_filename_key" UNIQUE ("filename");



ALTER TABLE ONLY "public"."_act_migrations"
    ADD CONSTRAINT "_act_migrations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."activities"
    ADD CONSTRAINT "activities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."agent_actions"
    ADD CONSTRAINT "agent_actions_action_name_key" UNIQUE ("action_name");



ALTER TABLE ONLY "public"."agent_actions"
    ADD CONSTRAINT "agent_actions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."agent_audit_log"
    ADD CONSTRAINT "agent_audit_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."agent_learnings"
    ADD CONSTRAINT "agent_learnings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."agent_performance"
    ADD CONSTRAINT "agent_performance_agent_id_task_type_period_start_key" UNIQUE ("agent_id", "task_type", "period_start");



ALTER TABLE ONLY "public"."agent_performance"
    ADD CONSTRAINT "agent_performance_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."agent_proposals"
    ADD CONSTRAINT "agent_proposals_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."agent_registry"
    ADD CONSTRAINT "agent_registry_pkey" PRIMARY KEY ("agent_id");



ALTER TABLE ONLY "public"."agent_requests"
    ADD CONSTRAINT "agent_requests_pkey" PRIMARY KEY ("request_id");



ALTER TABLE ONLY "public"."agent_task_queue"
    ADD CONSTRAINT "agent_task_queue_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."agentic_chat"
    ADD CONSTRAINT "agentic_chat_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."agentic_projects"
    ADD CONSTRAINT "agentic_projects_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."agentic_tasks"
    ADD CONSTRAINT "agentic_tasks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."agentic_work_log"
    ADD CONSTRAINT "agentic_work_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."agents"
    ADD CONSTRAINT "agents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_content_verifications"
    ADD CONSTRAINT "ai_content_verifications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_discoveries"
    ADD CONSTRAINT "ai_discoveries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_community_contexts"
    ADD CONSTRAINT "alma_community_contexts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_consent_ledger"
    ADD CONSTRAINT "alma_consent_ledger_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_content_entities"
    ADD CONSTRAINT "alma_content_entities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_content_entities"
    ADD CONSTRAINT "alma_content_entities_raw_content_id_entity_type_entity_id_key" UNIQUE ("raw_content_id", "entity_type", "entity_id");



ALTER TABLE ONLY "public"."alma_coverage_metrics"
    ADD CONSTRAINT "alma_coverage_metrics_dimension_type_dimension_value_key" UNIQUE ("dimension_type", "dimension_value");



ALTER TABLE ONLY "public"."alma_coverage_metrics"
    ADD CONSTRAINT "alma_coverage_metrics_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_discovered_links"
    ADD CONSTRAINT "alma_discovered_links_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_discovered_links"
    ADD CONSTRAINT "alma_discovered_links_url_key" UNIQUE ("url");



ALTER TABLE ONLY "public"."alma_embeddings"
    ADD CONSTRAINT "alma_embeddings_entity_type_entity_id_embedding_model_key" UNIQUE ("entity_type", "entity_id", "embedding_model");



ALTER TABLE ONLY "public"."alma_embeddings"
    ADD CONSTRAINT "alma_embeddings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_entity_sources"
    ADD CONSTRAINT "alma_entity_sources_entity_type_entity_id_source_document_i_key" UNIQUE ("entity_type", "entity_id", "source_document_id");



ALTER TABLE ONLY "public"."alma_entity_sources"
    ADD CONSTRAINT "alma_entity_sources_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_entity_tags"
    ADD CONSTRAINT "alma_entity_tags_entity_type_entity_id_tag_id_key" UNIQUE ("entity_type", "entity_id", "tag_id");



ALTER TABLE ONLY "public"."alma_entity_tags"
    ADD CONSTRAINT "alma_entity_tags_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_evidence_outcomes"
    ADD CONSTRAINT "alma_evidence_outcomes_evidence_id_outcome_id_key" UNIQUE ("evidence_id", "outcome_id");



ALTER TABLE ONLY "public"."alma_evidence_outcomes"
    ADD CONSTRAINT "alma_evidence_outcomes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_evidence"
    ADD CONSTRAINT "alma_evidence_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_external_source_cache"
    ADD CONSTRAINT "alma_external_source_cache_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_external_source_cache"
    ADD CONSTRAINT "alma_external_source_cache_url_key" UNIQUE ("url");



ALTER TABLE ONLY "public"."alma_extraction_patterns"
    ADD CONSTRAINT "alma_extraction_patterns_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_extraction_patterns"
    ADD CONSTRAINT "alma_extraction_patterns_source_type_pattern_name_pattern_v_key" UNIQUE ("source_type", "pattern_name", "pattern_version");



ALTER TABLE ONLY "public"."alma_funding_applications"
    ADD CONSTRAINT "alma_funding_applications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_funding_data"
    ADD CONSTRAINT "alma_funding_data_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_funding_data"
    ADD CONSTRAINT "alma_funding_data_source_url_jurisdiction_key" UNIQUE ("source_url", "jurisdiction");



ALTER TABLE ONLY "public"."alma_funding_opportunities"
    ADD CONSTRAINT "alma_funding_opportunities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_government_programs"
    ADD CONSTRAINT "alma_government_programs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_ingestion_jobs"
    ADD CONSTRAINT "alma_ingestion_jobs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_intervention_contexts"
    ADD CONSTRAINT "alma_intervention_contexts_intervention_id_context_id_key" UNIQUE ("intervention_id", "context_id");



ALTER TABLE ONLY "public"."alma_intervention_contexts"
    ADD CONSTRAINT "alma_intervention_contexts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_intervention_evidence"
    ADD CONSTRAINT "alma_intervention_evidence_intervention_id_evidence_id_key" UNIQUE ("intervention_id", "evidence_id");



ALTER TABLE ONLY "public"."alma_intervention_evidence"
    ADD CONSTRAINT "alma_intervention_evidence_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_intervention_funding"
    ADD CONSTRAINT "alma_intervention_funding_intervention_id_funding_data_id_key" UNIQUE ("intervention_id", "funding_data_id");



ALTER TABLE ONLY "public"."alma_intervention_funding"
    ADD CONSTRAINT "alma_intervention_funding_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_intervention_outcomes"
    ADD CONSTRAINT "alma_intervention_outcomes_intervention_id_outcome_id_key" UNIQUE ("intervention_id", "outcome_id");



ALTER TABLE ONLY "public"."alma_intervention_outcomes"
    ADD CONSTRAINT "alma_intervention_outcomes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_intervention_profiles"
    ADD CONSTRAINT "alma_intervention_profiles_intervention_id_public_profile_i_key" UNIQUE ("intervention_id", "public_profile_id", "role");



ALTER TABLE ONLY "public"."alma_intervention_profiles"
    ADD CONSTRAINT "alma_intervention_profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_interventions"
    ADD CONSTRAINT "alma_interventions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_locations"
    ADD CONSTRAINT "alma_locations_name_state_key" UNIQUE ("name", "state");



ALTER TABLE ONLY "public"."alma_locations"
    ADD CONSTRAINT "alma_locations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_media_articles"
    ADD CONSTRAINT "alma_media_articles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_metrics_history"
    ADD CONSTRAINT "alma_metrics_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_outcomes"
    ADD CONSTRAINT "alma_outcomes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_program_interventions"
    ADD CONSTRAINT "alma_program_interventions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_raw_content"
    ADD CONSTRAINT "alma_raw_content_content_hash_key" UNIQUE ("content_hash");



ALTER TABLE ONLY "public"."alma_raw_content"
    ADD CONSTRAINT "alma_raw_content_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_report_deliveries"
    ADD CONSTRAINT "alma_report_deliveries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_report_subscriptions"
    ADD CONSTRAINT "alma_report_subscriptions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_research_findings"
    ADD CONSTRAINT "alma_research_findings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_research_sessions"
    ADD CONSTRAINT "alma_research_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_research_tool_logs"
    ADD CONSTRAINT "alma_research_tool_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_scrape_history"
    ADD CONSTRAINT "alma_scrape_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_source_documents"
    ADD CONSTRAINT "alma_source_documents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_source_documents"
    ADD CONSTRAINT "alma_source_documents_source_url_key" UNIQUE ("source_url");



ALTER TABLE ONLY "public"."alma_source_registry"
    ADD CONSTRAINT "alma_source_registry_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_source_registry"
    ADD CONSTRAINT "alma_source_registry_url_key" UNIQUE ("url");



ALTER TABLE ONLY "public"."alma_tags"
    ADD CONSTRAINT "alma_tags_category_slug_key" UNIQUE ("category", "slug");



ALTER TABLE ONLY "public"."alma_tags"
    ADD CONSTRAINT "alma_tags_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_usage_log"
    ADD CONSTRAINT "alma_usage_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_weekly_reports"
    ADD CONSTRAINT "alma_weekly_reports_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."alma_weekly_reports"
    ADD CONSTRAINT "alma_weekly_reports_week_start_report_type_organization_id_key" UNIQUE ("week_start", "report_type", "organization_id");



ALTER TABLE ONLY "public"."analysis_jobs"
    ADD CONSTRAINT "analysis_jobs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."api_pricing"
    ADD CONSTRAINT "api_pricing_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."api_pricing"
    ADD CONSTRAINT "api_pricing_provider_model_endpoint_effective_from_key" UNIQUE ("provider", "model", "endpoint", "effective_from");



ALTER TABLE ONLY "public"."api_usage"
    ADD CONSTRAINT "api_usage_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."app_users"
    ADD CONSTRAINT "app_users_openId_unique" UNIQUE ("openId");



ALTER TABLE ONLY "public"."app_users"
    ADD CONSTRAINT "app_users_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."art_innovation"
    ADD CONSTRAINT "art_innovation_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."art_innovation_profiles"
    ADD CONSTRAINT "art_innovation_profiles_art_innovation_id_public_profile_id_key" UNIQUE ("art_innovation_id", "public_profile_id");



ALTER TABLE ONLY "public"."art_innovation_profiles"
    ADD CONSTRAINT "art_innovation_profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."art_innovation"
    ADD CONSTRAINT "art_innovation_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."article_locations"
    ADD CONSTRAINT "article_locations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."article_related_art"
    ADD CONSTRAINT "article_related_art_article_id_art_innovation_id_key" UNIQUE ("article_id", "art_innovation_id");



ALTER TABLE ONLY "public"."article_related_art"
    ADD CONSTRAINT "article_related_art_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."article_related_articles"
    ADD CONSTRAINT "article_related_articles_article_id_related_article_id_key" UNIQUE ("article_id", "related_article_id");



ALTER TABLE ONLY "public"."article_related_articles"
    ADD CONSTRAINT "article_related_articles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."article_related_evidence"
    ADD CONSTRAINT "article_related_evidence_article_id_evidence_id_key" UNIQUE ("article_id", "evidence_id");



ALTER TABLE ONLY "public"."article_related_evidence"
    ADD CONSTRAINT "article_related_evidence_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."article_related_interventions"
    ADD CONSTRAINT "article_related_interventions_article_id_intervention_id_key" UNIQUE ("article_id", "intervention_id");



ALTER TABLE ONLY "public"."article_related_interventions"
    ADD CONSTRAINT "article_related_interventions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."article_related_programs"
    ADD CONSTRAINT "article_related_programs_article_id_program_id_key" UNIQUE ("article_id", "program_id");



ALTER TABLE ONLY "public"."article_related_programs"
    ADD CONSTRAINT "article_related_programs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."article_related_services"
    ADD CONSTRAINT "article_related_services_article_id_service_id_key" UNIQUE ("article_id", "service_id");



ALTER TABLE ONLY "public"."article_related_services"
    ADD CONSTRAINT "article_related_services_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."article_tags"
    ADD CONSTRAINT "article_tags_article_id_tag_key" UNIQUE ("article_id", "tag");



ALTER TABLE ONLY "public"."article_tags"
    ADD CONSTRAINT "article_tags_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."articles"
    ADD CONSTRAINT "articles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."articles"
    ADD CONSTRAINT "articles_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."audit_logs"
    ADD CONSTRAINT "audit_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."australian_frameworks"
    ADD CONSTRAINT "australian_frameworks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."australian_frameworks"
    ADD CONSTRAINT "australian_frameworks_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."authors"
    ADD CONSTRAINT "authors_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."authors"
    ADD CONSTRAINT "authors_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."automated_insights"
    ADD CONSTRAINT "automated_insights_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."autonomous_executions"
    ADD CONSTRAINT "autonomous_executions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."backups"
    ADD CONSTRAINT "backups_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."best_practices"
    ADD CONSTRAINT "best_practices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."best_practices"
    ADD CONSTRAINT "best_practices_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."billing_coupons"
    ADD CONSTRAINT "billing_coupons_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."billing_customers"
    ADD CONSTRAINT "billing_customers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."billing_invoice_lines"
    ADD CONSTRAINT "billing_invoice_lines_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."billing_invoices"
    ADD CONSTRAINT "billing_invoices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."billing_payments"
    ADD CONSTRAINT "billing_payments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."billing_prices"
    ADD CONSTRAINT "billing_prices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."billing_products"
    ADD CONSTRAINT "billing_products_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."billing_subscription_items"
    ADD CONSTRAINT "billing_subscription_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."billing_subscriptions"
    ADD CONSTRAINT "billing_subscriptions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."billing_tax_rates"
    ADD CONSTRAINT "billing_tax_rates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."billing_tax_settings"
    ADD CONSTRAINT "billing_tax_settings_pkey" PRIMARY KEY ("tenant_id");



ALTER TABLE ONLY "public"."billing_webhook_events"
    ADD CONSTRAINT "billing_webhook_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."blog_comments"
    ADD CONSTRAINT "blog_comments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."blog_content_links"
    ADD CONSTRAINT "blog_content_links_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."blog_media"
    ADD CONSTRAINT "blog_media_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."blog_posts"
    ADD CONSTRAINT "blog_posts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."blog_posts_profiles"
    ADD CONSTRAINT "blog_posts_profiles_blog_post_id_public_profile_id_key" UNIQUE ("blog_post_id", "public_profile_id");



ALTER TABLE ONLY "public"."blog_posts_profiles"
    ADD CONSTRAINT "blog_posts_profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."blog_posts"
    ADD CONSTRAINT "blog_posts_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."bookkeeping_project_links"
    ADD CONSTRAINT "bookkeeping_project_links_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bookkeeping_receipts"
    ADD CONSTRAINT "bookkeeping_receipts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bookkeeping_rules"
    ADD CONSTRAINT "bookkeeping_rules_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bookkeeping_sync_state"
    ADD CONSTRAINT "bookkeeping_sync_state_pkey" PRIMARY KEY ("tenant_id");



ALTER TABLE ONLY "public"."bookkeeping_transactions"
    ADD CONSTRAINT "bookkeeping_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bookkeeping_transactions"
    ADD CONSTRAINT "bookkeeping_transactions_xero_id_key" UNIQUE ("xero_id");



ALTER TABLE ONLY "public"."brand_tests"
    ADD CONSTRAINT "brand_tests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."business_agent_queries"
    ADD CONSTRAINT "business_agent_queries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."business_alerts"
    ADD CONSTRAINT "business_alerts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."businesses"
    ADD CONSTRAINT "businesses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."calendar_events"
    ADD CONSTRAINT "calendar_events_google_event_id_key" UNIQUE ("google_event_id");



ALTER TABLE ONLY "public"."calendar_events"
    ADD CONSTRAINT "calendar_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."canonical_entities"
    ADD CONSTRAINT "canonical_entities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ce_activities"
    ADD CONSTRAINT "ce_activities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ce_backups"
    ADD CONSTRAINT "ce_backups_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ce_brand_analyses"
    ADD CONSTRAINT "ce_brand_analyses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ce_brand_tests"
    ADD CONSTRAINT "ce_brand_tests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ce_media_assets"
    ADD CONSTRAINT "ce_media_assets_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ce_metrics"
    ADD CONSTRAINT "ce_metrics_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ce_saved_searches"
    ADD CONSTRAINT "ce_saved_searches_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ce_search_history"
    ADD CONSTRAINT "ce_search_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ce_stories"
    ADD CONSTRAINT "ce_stories_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ce_users"
    ADD CONSTRAINT "ce_users_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."ce_users"
    ADD CONSTRAINT "ce_users_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ce_users"
    ADD CONSTRAINT "ce_users_username_key" UNIQUE ("username");



ALTER TABLE ONLY "public"."channel_messages"
    ADD CONSTRAINT "channel_messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."clearinghouse_documents"
    ADD CONSTRAINT "clearinghouse_documents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cms_content_blocks"
    ADD CONSTRAINT "cms_content_blocks_name_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."cms_content_blocks"
    ADD CONSTRAINT "cms_content_blocks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cms_media"
    ADD CONSTRAINT "cms_media_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cms_pages"
    ADD CONSTRAINT "cms_pages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cms_pages"
    ADD CONSTRAINT "cms_pages_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."coe_key_people"
    ADD CONSTRAINT "coe_key_people_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."coe_key_people"
    ADD CONSTRAINT "coe_key_people_profile_id_key" UNIQUE ("profile_id");



ALTER TABLE ONLY "public"."collection_media"
    ADD CONSTRAINT "collection_media_pkey" PRIMARY KEY ("collection_id", "media_id");



ALTER TABLE ONLY "public"."communications_history"
    ADD CONSTRAINT "communications_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."communications_history"
    ADD CONSTRAINT "communications_history_source_system_source_id_key" UNIQUE ("source_system", "source_id");



ALTER TABLE ONLY "public"."community_connections"
    ADD CONSTRAINT "community_connections_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."community_events"
    ADD CONSTRAINT "community_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."community_feedback"
    ADD CONSTRAINT "community_feedback_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."community_health_metrics"
    ADD CONSTRAINT "community_health_metrics_community_id_metric_date_metric_pe_key" UNIQUE ("community_id", "metric_date", "metric_period");



ALTER TABLE ONLY "public"."community_health_metrics"
    ADD CONSTRAINT "community_health_metrics_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."community_inquiries"
    ADD CONSTRAINT "community_inquiries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."registered_services"
    ADD CONSTRAINT "community_programs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."registered_services_profiles"
    ADD CONSTRAINT "community_programs_profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."registered_services_profiles"
    ADD CONSTRAINT "community_programs_profiles_program_id_public_profile_id_key" UNIQUE ("program_id", "public_profile_id");



ALTER TABLE ONLY "public"."registered_services_profiles"
    ADD CONSTRAINT "community_programs_profiles_program_public_profile_key" UNIQUE ("program_id", "public_profile_id");



ALTER TABLE ONLY "public"."compliance_tracking"
    ADD CONSTRAINT "compliance_tracking_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."consent_management"
    ADD CONSTRAINT "consent_management_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."consent_records"
    ADD CONSTRAINT "consent_records_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."contact_cadence_metrics"
    ADD CONSTRAINT "contact_cadence_metrics_pkey" PRIMARY KEY ("contact_id");



ALTER TABLE ONLY "public"."contact_communications"
    ADD CONSTRAINT "contact_communications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."contact_edges"
    ADD CONSTRAINT "contact_edges_contact_a_id_contact_b_id_key" UNIQUE ("contact_a_id", "contact_b_id");



ALTER TABLE ONLY "public"."contact_edges"
    ADD CONSTRAINT "contact_edges_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."contact_enrichments"
    ADD CONSTRAINT "contact_enrichments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."contact_intelligence_insights"
    ADD CONSTRAINT "contact_intelligence_insights_contact_source_unique" UNIQUE ("contact_id", "source");



ALTER TABLE ONLY "public"."contact_intelligence_insights"
    ADD CONSTRAINT "contact_intelligence_insights_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."contact_intelligence"
    ADD CONSTRAINT "contact_intelligence_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."contact_intelligence_scores"
    ADD CONSTRAINT "contact_intelligence_scores_person_id_key" UNIQUE ("person_id");



ALTER TABLE ONLY "public"."contact_intelligence_scores"
    ADD CONSTRAINT "contact_intelligence_scores_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."contact_interactions"
    ADD CONSTRAINT "contact_interactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."contact_invites"
    ADD CONSTRAINT "contact_invites_contact_id_opportunity_id_key" UNIQUE ("contact_id", "opportunity_id");



ALTER TABLE ONLY "public"."contact_invites"
    ADD CONSTRAINT "contact_invites_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."contact_project_links"
    ADD CONSTRAINT "contact_project_links_entity_id_project_code_key" UNIQUE ("entity_id", "project_code");



ALTER TABLE ONLY "public"."contact_project_links"
    ADD CONSTRAINT "contact_project_links_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."contact_review_decisions"
    ADD CONSTRAINT "contact_review_decisions_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."contact_review_decisions"
    ADD CONSTRAINT "contact_review_decisions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."contact_support_preferences"
    ADD CONSTRAINT "contact_support_preferences_pkey" PRIMARY KEY ("contact_id", "project_id");



ALTER TABLE ONLY "public"."contact_support_recommendations"
    ADD CONSTRAINT "contact_support_recommendations_pkey" PRIMARY KEY ("contact_id");



ALTER TABLE ONLY "public"."content_link_suggestions"
    ADD CONSTRAINT "content_link_suggestions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."content_link_suggestions"
    ADD CONSTRAINT "content_link_suggestions_source_type_source_id_target_type__key" UNIQUE ("source_type", "source_id", "target_type", "target_id");



ALTER TABLE ONLY "public"."conversation_context"
    ADD CONSTRAINT "conversation_context_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cultural_liaisons"
    ADD CONSTRAINT "cultural_liaisons_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."cultural_liaisons"
    ADD CONSTRAINT "cultural_liaisons_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cultural_protocols"
    ADD CONSTRAINT "cultural_protocols_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cultural_review_queue"
    ADD CONSTRAINT "cultural_review_queue_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."data_quality_audit"
    ADD CONSTRAINT "data_quality_audit_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."data_quality_metrics"
    ADD CONSTRAINT "data_quality_metrics_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."data_quality_metrics"
    ADD CONSTRAINT "data_quality_metrics_table_name_analysis_date_key" UNIQUE ("table_name", "analysis_date");



ALTER TABLE ONLY "public"."data_sources"
    ADD CONSTRAINT "data_sources_name_type_key" UNIQUE ("name", "type");



ALTER TABLE ONLY "public"."data_sources"
    ADD CONSTRAINT "data_sources_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."decision_outcomes"
    ADD CONSTRAINT "decision_outcomes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."decision_patterns"
    ADD CONSTRAINT "decision_patterns_pattern_name_key" UNIQUE ("pattern_name");



ALTER TABLE ONLY "public"."decision_patterns"
    ADD CONSTRAINT "decision_patterns_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."decision_traces"
    ADD CONSTRAINT "decision_traces_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."decisions"
    ADD CONSTRAINT "decisions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."discovered_subscriptions"
    ADD CONSTRAINT "discovered_subscriptions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."discovered_subscriptions"
    ADD CONSTRAINT "discovered_subscriptions_tenant_id_vendor_key" UNIQUE ("tenant_id", "vendor");



ALTER TABLE ONLY "public"."donations"
    ADD CONSTRAINT "donations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ecosystem_projects"
    ADD CONSTRAINT "ecosystem_projects_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ecosystem_projects"
    ADD CONSTRAINT "ecosystem_projects_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."ecosystem_sites"
    ADD CONSTRAINT "ecosystem_sites_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ecosystem_sites"
    ADD CONSTRAINT "ecosystem_sites_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."elder_review_queue"
    ADD CONSTRAINT "elder_review_queue_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."email_financial_documents"
    ADD CONSTRAINT "email_financial_documents_gmail_message_id_key" UNIQUE ("gmail_message_id");



ALTER TABLE ONLY "public"."email_financial_documents"
    ADD CONSTRAINT "email_financial_documents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."email_financial_documents"
    ADD CONSTRAINT "email_financial_documents_tenant_id_gmail_message_id_key" UNIQUE ("tenant_id", "gmail_message_id");



ALTER TABLE ONLY "public"."enrichment_reviews"
    ADD CONSTRAINT "enrichment_reviews_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."entities"
    ADD CONSTRAINT "entities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."entities"
    ADD CONSTRAINT "entities_primary_email_key" UNIQUE ("primary_email");



ALTER TABLE ONLY "public"."entity_identifiers"
    ADD CONSTRAINT "entity_identifiers_identifier_type_normalized_value_key" UNIQUE ("identifier_type", "normalized_value");



ALTER TABLE ONLY "public"."entity_identifiers"
    ADD CONSTRAINT "entity_identifiers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."entity_mappings"
    ADD CONSTRAINT "entity_mappings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."entity_mappings"
    ADD CONSTRAINT "entity_mappings_source_system_source_id_key" UNIQUE ("source_system", "source_id");



ALTER TABLE ONLY "public"."entity_merge_log"
    ADD CONSTRAINT "entity_merge_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."entity_potential_matches"
    ADD CONSTRAINT "entity_potential_matches_entity_a_id_entity_b_id_key" UNIQUE ("entity_a_id", "entity_b_id");



ALTER TABLE ONLY "public"."entity_potential_matches"
    ADD CONSTRAINT "entity_potential_matches_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."entity_relationships"
    ADD CONSTRAINT "entity_relationships_entity_type_entity_id_related_entity_t_key" UNIQUE ("entity_type", "entity_id", "related_entity_type", "related_entity_id", "relationship_type");



ALTER TABLE ONLY "public"."entity_relationships"
    ADD CONSTRAINT "entity_relationships_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."event_registrations"
    ADD CONSTRAINT "event_registrations_event_id_email_key" UNIQUE ("event_id", "email");



ALTER TABLE ONLY "public"."event_registrations"
    ADD CONSTRAINT "event_registrations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."events_old_backup"
    ADD CONSTRAINT "events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."events"
    ADD CONSTRAINT "events_pkey1" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."events"
    ADD CONSTRAINT "events_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."exa_api_usage"
    ADD CONSTRAINT "exa_api_usage_period_month_key" UNIQUE ("period_month");



ALTER TABLE ONLY "public"."exa_api_usage"
    ADD CONSTRAINT "exa_api_usage_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."exa_company_intelligence"
    ADD CONSTRAINT "exa_company_intelligence_company_name_key" UNIQUE ("company_name");



ALTER TABLE ONLY "public"."exa_company_intelligence"
    ADD CONSTRAINT "exa_company_intelligence_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."exa_enrichment_queue"
    ADD CONSTRAINT "exa_enrichment_queue_person_id_campaign_type_key" UNIQUE ("person_id", "campaign_type");



ALTER TABLE ONLY "public"."exa_enrichment_queue"
    ADD CONSTRAINT "exa_enrichment_queue_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."exa_linkedin_profiles"
    ADD CONSTRAINT "exa_linkedin_profiles_person_id_key" UNIQUE ("person_id");



ALTER TABLE ONLY "public"."exa_linkedin_profiles"
    ADD CONSTRAINT "exa_linkedin_profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."exa_media_mentions"
    ADD CONSTRAINT "exa_media_mentions_person_id_url_key" UNIQUE ("person_id", "url");



ALTER TABLE ONLY "public"."exa_media_mentions"
    ADD CONSTRAINT "exa_media_mentions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."facility_partnerships"
    ADD CONSTRAINT "facility_partnerships_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."facility_statistics"
    ADD CONSTRAINT "facility_statistics_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."fellows"
    ADD CONSTRAINT "fellows_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."financial_project_summaries"
    ADD CONSTRAINT "financial_project_summaries_pkey" PRIMARY KEY ("project_id");



ALTER TABLE ONLY "public"."financial_summary"
    ADD CONSTRAINT "financial_summary_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ghl_contacts"
    ADD CONSTRAINT "ghl_contacts_ghl_id_key" UNIQUE ("ghl_id");



ALTER TABLE ONLY "public"."ghl_contacts"
    ADD CONSTRAINT "ghl_contacts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ghl_engagement_metrics"
    ADD CONSTRAINT "ghl_engagement_metrics_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ghl_opportunities"
    ADD CONSTRAINT "ghl_opportunities_ghl_id_key" UNIQUE ("ghl_id");



ALTER TABLE ONLY "public"."ghl_opportunities"
    ADD CONSTRAINT "ghl_opportunities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ghl_pipelines"
    ADD CONSTRAINT "ghl_pipelines_ghl_id_key" UNIQUE ("ghl_id");



ALTER TABLE ONLY "public"."ghl_pipelines"
    ADD CONSTRAINT "ghl_pipelines_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ghl_sync_log"
    ADD CONSTRAINT "ghl_sync_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ghl_tags"
    ADD CONSTRAINT "ghl_tags_ghl_location_id_name_key" UNIQUE ("ghl_location_id", "name");



ALTER TABLE ONLY "public"."ghl_tags"
    ADD CONSTRAINT "ghl_tags_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gmail_auth_tokens"
    ADD CONSTRAINT "gmail_auth_tokens_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gmail_auth_tokens"
    ADD CONSTRAINT "gmail_auth_tokens_user_email_key" UNIQUE ("user_email");



ALTER TABLE ONLY "public"."gmail_contacts"
    ADD CONSTRAINT "gmail_contacts_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."gmail_contacts"
    ADD CONSTRAINT "gmail_contacts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gmail_messages"
    ADD CONSTRAINT "gmail_messages_gmail_id_key" UNIQUE ("gmail_id");



ALTER TABLE ONLY "public"."gmail_messages"
    ADD CONSTRAINT "gmail_messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gmail_sync_state"
    ADD CONSTRAINT "gmail_sync_state_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gmail_sync_status"
    ADD CONSTRAINT "gmail_sync_status_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gmail_sync_status"
    ADD CONSTRAINT "gmail_sync_status_user_email_key" UNIQUE ("user_email");



ALTER TABLE ONLY "public"."goal_metrics"
    ADD CONSTRAINT "goal_metrics_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."goal_updates"
    ADD CONSTRAINT "goal_updates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."goals_2026"
    ADD CONSTRAINT "goals_2026_notion_id_key" UNIQUE ("notion_id");



ALTER TABLE ONLY "public"."goals_2026"
    ADD CONSTRAINT "goals_2026_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."grant_financial_tracking"
    ADD CONSTRAINT "grant_financial_tracking_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."grant_opportunities"
    ADD CONSTRAINT "grant_opportunities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."harvest_businesses"
    ADD CONSTRAINT "harvest_businesses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."harvest_events"
    ADD CONSTRAINT "harvest_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."health_alerts"
    ADD CONSTRAINT "health_alerts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."historical_inquiries"
    ADD CONSTRAINT "historical_inquiries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ignored_email_patterns"
    ADD CONSTRAINT "ignored_email_patterns_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."impact_evidence"
    ADD CONSTRAINT "impact_evidence_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."impact_stories"
    ADD CONSTRAINT "impact_stories_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."intelligence_briefings"
    ADD CONSTRAINT "intelligence_briefings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."intelligence_geo_alerts"
    ADD CONSTRAINT "intelligence_geo_alerts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."intelligence_refusals"
    ADD CONSTRAINT "intelligence_refusals_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."interactions"
    ADD CONSTRAINT "interactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."international_invitations"
    ADD CONSTRAINT "international_invitations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."international_programs"
    ADD CONSTRAINT "international_programs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."international_programs"
    ADD CONSTRAINT "international_programs_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."justice_matrix_campaigns"
    ADD CONSTRAINT "justice_matrix_campaigns_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."justice_matrix_cases"
    ADD CONSTRAINT "justice_matrix_cases_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."justice_matrix_discovered"
    ADD CONSTRAINT "justice_matrix_discovered_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."justice_matrix_resources"
    ADD CONSTRAINT "justice_matrix_resources_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."justice_matrix_scrape_logs"
    ADD CONSTRAINT "justice_matrix_scrape_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."justice_matrix_sources"
    ADD CONSTRAINT "justice_matrix_sources_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."justicehub_nodes"
    ADD CONSTRAINT "justicehub_nodes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."knowledge_chunks"
    ADD CONSTRAINT "knowledge_chunks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."knowledge_extraction_queue"
    ADD CONSTRAINT "knowledge_extraction_queue_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."knowledge_source_sync"
    ADD CONSTRAINT "knowledge_source_sync_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."knowledge_source_sync"
    ADD CONSTRAINT "knowledge_source_sync_source_type_key" UNIQUE ("source_type");



ALTER TABLE ONLY "public"."knowledge_sources"
    ADD CONSTRAINT "knowledge_sources_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."knowledge_versions"
    ADD CONSTRAINT "knowledge_versions_knowledge_id_version_key" UNIQUE ("knowledge_id", "version");



ALTER TABLE ONLY "public"."knowledge_versions"
    ADD CONSTRAINT "knowledge_versions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."learned_thresholds"
    ADD CONSTRAINT "learned_thresholds_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."learned_thresholds"
    ADD CONSTRAINT "learned_thresholds_segment_key" UNIQUE ("segment");



ALTER TABLE ONLY "public"."learned_thresholds"
    ADD CONSTRAINT "learned_thresholds_threshold_type_segment_key" UNIQUE ("threshold_type", "segment");



ALTER TABLE ONLY "public"."linkedin_contacts"
    ADD CONSTRAINT "linkedin_contacts_linkedin_url_key" UNIQUE ("linkedin_url");



ALTER TABLE ONLY "public"."linkedin_contacts"
    ADD CONSTRAINT "linkedin_contacts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."linkedin_imports"
    ADD CONSTRAINT "linkedin_imports_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."linkedin_project_connections"
    ADD CONSTRAINT "linkedin_project_connections_contact_id_notion_project_id_key" UNIQUE ("contact_id", "notion_project_id");



ALTER TABLE ONLY "public"."linkedin_project_connections"
    ADD CONSTRAINT "linkedin_project_connections_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."locations"
    ADD CONSTRAINT "locations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."media_assets"
    ADD CONSTRAINT "media_assets_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."media_collections"
    ADD CONSTRAINT "media_collections_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."media_files"
    ADD CONSTRAINT "media_files_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."media_item"
    ADD CONSTRAINT "media_item_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."media_items"
    ADD CONSTRAINT "media_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."media_library"
    ADD CONSTRAINT "media_library_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."media_processing_jobs"
    ADD CONSTRAINT "media_processing_jobs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."media_usage"
    ADD CONSTRAINT "media_usage_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."metrics"
    ADD CONSTRAINT "metrics_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."migration_email_templates"
    ADD CONSTRAINT "migration_email_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."migration_email_templates"
    ADD CONSTRAINT "migration_email_templates_tenant_id_template_name_key" UNIQUE ("tenant_id", "template_name");



ALTER TABLE ONLY "public"."migration_rate_limits"
    ADD CONSTRAINT "migration_rate_limits_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."migration_rate_limits"
    ADD CONSTRAINT "migration_rate_limits_tenant_id_date_key" UNIQUE ("tenant_id", "date");



ALTER TABLE ONLY "public"."newsletter_subscribers"
    ADD CONSTRAINT "newsletter_subscribers_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."newsletter_subscribers"
    ADD CONSTRAINT "newsletter_subscribers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."newsletter_subscriptions"
    ADD CONSTRAINT "newsletter_subscriptions_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."newsletter_subscriptions"
    ADD CONSTRAINT "newsletter_subscriptions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."normalized_documents"
    ADD CONSTRAINT "normalized_documents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."normalized_stories"
    ADD CONSTRAINT "normalized_stories_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."normalized_storytellers"
    ADD CONSTRAINT "normalized_storytellers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."notion_opportunities"
    ADD CONSTRAINT "notion_opportunities_notion_id_key" UNIQUE ("notion_id");



ALTER TABLE ONLY "public"."notion_opportunities"
    ADD CONSTRAINT "notion_opportunities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."notion_organization_people"
    ADD CONSTRAINT "notion_organization_people_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."notion_organizations"
    ADD CONSTRAINT "notion_organizations_notion_id_key" UNIQUE ("notion_id");



ALTER TABLE ONLY "public"."notion_organizations"
    ADD CONSTRAINT "notion_organizations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."notion_people"
    ADD CONSTRAINT "notion_people_notion_id_key" UNIQUE ("notion_id");



ALTER TABLE ONLY "public"."notion_people"
    ADD CONSTRAINT "notion_people_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."notion_project_organizations"
    ADD CONSTRAINT "notion_project_organizations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."notion_project_people"
    ADD CONSTRAINT "notion_project_people_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."notion_projects_cache"
    ADD CONSTRAINT "notion_projects_cache_pkey" PRIMARY KEY ("notion_project_id");



ALTER TABLE ONLY "public"."notion_projects"
    ADD CONSTRAINT "notion_projects_notion_id_key" UNIQUE ("notion_id");



ALTER TABLE ONLY "public"."notion_projects"
    ADD CONSTRAINT "notion_projects_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."opportunities"
    ADD CONSTRAINT "opportunities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."organization_connections"
    ADD CONSTRAINT "organization_connections_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."organization_enrichment"
    ADD CONSTRAINT "organization_enrichment_organization_id_enrichment_type_cre_key" UNIQUE ("organization_id", "enrichment_type", "created_at");



ALTER TABLE ONLY "public"."organization_enrichment"
    ADD CONSTRAINT "organization_enrichment_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."organization_members"
    ADD CONSTRAINT "organization_members_organization_id_user_id_key" UNIQUE ("organization_id", "user_id");



ALTER TABLE ONLY "public"."organization_members"
    ADD CONSTRAINT "organization_members_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."organization_sync_log"
    ADD CONSTRAINT "organization_sync_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."organizations"
    ADD CONSTRAINT "organizations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."organizations_profiles"
    ADD CONSTRAINT "organizations_profiles_organization_id_public_profile_id_key" UNIQUE ("organization_id", "public_profile_id");



ALTER TABLE ONLY "public"."organizations_profiles"
    ADD CONSTRAINT "organizations_profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."outreach_strategies"
    ADD CONSTRAINT "outreach_strategies_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."outreach_tasks"
    ADD CONSTRAINT "outreach_tasks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pages"
    ADD CONSTRAINT "pages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pages"
    ADD CONSTRAINT "pages_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."partner_contacts"
    ADD CONSTRAINT "partner_contacts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."partner_external_links"
    ADD CONSTRAINT "partner_external_links_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."partner_goals"
    ADD CONSTRAINT "partner_goals_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."partner_impact_metrics"
    ADD CONSTRAINT "partner_impact_metrics_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."partner_photos"
    ADD CONSTRAINT "partner_photos_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."partner_site_locations"
    ADD CONSTRAINT "partner_site_locations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."partner_stories"
    ADD CONSTRAINT "partner_stories_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."partner_storytellers"
    ADD CONSTRAINT "partner_storytellers_organization_id_empathy_ledger_profile_key" UNIQUE ("organization_id", "empathy_ledger_profile_id");



ALTER TABLE ONLY "public"."partner_storytellers"
    ADD CONSTRAINT "partner_storytellers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."partner_videos"
    ADD CONSTRAINT "partner_videos_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."partners"
    ADD CONSTRAINT "partners_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pending_contacts"
    ADD CONSTRAINT "pending_contacts_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."pending_contacts"
    ADD CONSTRAINT "pending_contacts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."person_identity_map"
    ADD CONSTRAINT "person_identity_map_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."person_identity_map"
    ADD CONSTRAINT "person_identity_map_pkey" PRIMARY KEY ("person_id");



ALTER TABLE ONLY "public"."photo_album_photos"
    ADD CONSTRAINT "photo_album_photos_album_id_photo_id_key" UNIQUE ("album_id", "photo_id");



ALTER TABLE ONLY "public"."photo_album_photos"
    ADD CONSTRAINT "photo_album_photos_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."photo_album_shares"
    ADD CONSTRAINT "photo_album_shares_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."photo_albums"
    ADD CONSTRAINT "photo_albums_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."photo_albums"
    ADD CONSTRAINT "photo_albums_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."photo_storyteller_tags"
    ADD CONSTRAINT "photo_storyteller_tags_photo_id_storyteller_id_key" UNIQUE ("photo_id", "storyteller_id");



ALTER TABLE ONLY "public"."photo_storyteller_tags"
    ADD CONSTRAINT "photo_storyteller_tags_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."photos"
    ADD CONSTRAINT "photos_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."platform_collection_media"
    ADD CONSTRAINT "platform_collection_media_pkey" PRIMARY KEY ("collection_id", "media_id");



ALTER TABLE ONLY "public"."platform_media_collections"
    ADD CONSTRAINT "platform_media_collections_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."platform_media_items"
    ADD CONSTRAINT "platform_media_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."platform_media_processing_jobs"
    ADD CONSTRAINT "platform_media_processing_jobs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."platform_media_usage"
    ADD CONSTRAINT "platform_media_usage_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."platform_organizations"
    ADD CONSTRAINT "platform_organizations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."platform_organizations"
    ADD CONSTRAINT "platform_organizations_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."platform_organizations"
    ADD CONSTRAINT "platform_organizations_storage_prefix_key" UNIQUE ("storage_prefix");



ALTER TABLE ONLY "public"."pmpp_knowledge"
    ADD CONSTRAINT "pmpp_knowledge_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."portraits"
    ADD CONSTRAINT "portraits_access_code_key" UNIQUE ("access_code");



ALTER TABLE ONLY "public"."portraits"
    ADD CONSTRAINT "portraits_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."privacy_audit_log"
    ADD CONSTRAINT "privacy_audit_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."privacy_dsr_requests"
    ADD CONSTRAINT "privacy_dsr_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."privacy_settings"
    ADD CONSTRAINT "privacy_settings_pkey" PRIMARY KEY ("tenant_id");



ALTER TABLE ONLY "public"."profile_appearances"
    ADD CONSTRAINT "profile_appearances_empathy_ledger_profile_id_appears_on_ty_key" UNIQUE ("empathy_ledger_profile_id", "appears_on_type", "appears_on_id");



ALTER TABLE ONLY "public"."profile_appearances"
    ADD CONSTRAINT "profile_appearances_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profile_sync_log"
    ADD CONSTRAINT "profile_sync_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."program_outcomes"
    ADD CONSTRAINT "program_outcomes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."program_visits"
    ADD CONSTRAINT "program_visits_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_activity_summary"
    ADD CONSTRAINT "project_activity_summary_pkey" PRIMARY KEY ("project_id");



ALTER TABLE ONLY "public"."project_contact_alignment"
    ADD CONSTRAINT "project_contact_alignment_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_contact_alignment"
    ADD CONSTRAINT "project_contact_alignment_project_id_contact_id_key" UNIQUE ("project_id", "contact_id");



ALTER TABLE ONLY "public"."project_contact_matches"
    ADD CONSTRAINT "project_contact_matches_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_contributions"
    ADD CONSTRAINT "project_contributions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_health_analysis"
    ADD CONSTRAINT "project_health_analysis_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_health_history"
    ADD CONSTRAINT "project_health_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_health"
    ADD CONSTRAINT "project_health_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_health"
    ADD CONSTRAINT "project_health_project_code_key" UNIQUE ("project_code");



ALTER TABLE ONLY "public"."project_intelligence"
    ADD CONSTRAINT "project_intelligence_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_intelligence"
    ADD CONSTRAINT "project_intelligence_project_id_key" UNIQUE ("project_id");



ALTER TABLE ONLY "public"."project_knowledge"
    ADD CONSTRAINT "project_knowledge_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_media_links"
    ADD CONSTRAINT "project_media_links_media_id_link_type_link_id_key" UNIQUE ("media_id", "link_type", "link_id");



ALTER TABLE ONLY "public"."project_media_links"
    ADD CONSTRAINT "project_media_links_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_outcome_updates"
    ADD CONSTRAINT "project_outcome_updates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_outcomes"
    ADD CONSTRAINT "project_outcomes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_pairings"
    ADD CONSTRAINT "project_pairings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_research"
    ADD CONSTRAINT "project_research_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_support_graph"
    ADD CONSTRAINT "project_support_graph_pkey" PRIMARY KEY ("project_id");



ALTER TABLE ONLY "public"."project_updates"
    ADD CONSTRAINT "project_updates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."projects"
    ADD CONSTRAINT "projects_notion_id_unique" UNIQUE ("notion_id");



ALTER TABLE ONLY "public"."projects"
    ADD CONSTRAINT "projects_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."public_profiles"
    ADD CONSTRAINT "public_profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."public_profiles"
    ADD CONSTRAINT "public_profiles_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."pulse_events"
    ADD CONSTRAINT "pulse_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."push_subscriptions"
    ADD CONSTRAINT "push_subscriptions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."quotes"
    ADD CONSTRAINT "quotes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."rd_activity_log"
    ADD CONSTRAINT "rd_activity_log_notion_page_id_key" UNIQUE ("notion_page_id");



ALTER TABLE ONLY "public"."rd_activity_log"
    ADD CONSTRAINT "rd_activity_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."receipt_match_history"
    ADD CONSTRAINT "receipt_match_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."receipt_matches"
    ADD CONSTRAINT "receipt_matches_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."receipt_matches"
    ADD CONSTRAINT "receipt_matches_source_type_source_id_key" UNIQUE ("source_type", "source_id");



ALTER TABLE ONLY "public"."receipt_reconciliation_weeks"
    ADD CONSTRAINT "receipt_reconciliation_weeks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."receipt_reconciliation_weeks"
    ADD CONSTRAINT "receipt_reconciliation_weeks_week_start_key" UNIQUE ("week_start");



ALTER TABLE ONLY "public"."receipt_status"
    ADD CONSTRAINT "receipt_status_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."receipt_status"
    ADD CONSTRAINT "receipt_status_source_type_source_id_key" UNIQUE ("source_type", "source_id");



ALTER TABLE ONLY "public"."recommendation_outcomes"
    ADD CONSTRAINT "recommendation_outcomes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."relationship_health"
    ADD CONSTRAINT "relationship_health_ghl_contact_id_key" UNIQUE ("ghl_contact_id");



ALTER TABLE ONLY "public"."relationship_health"
    ADD CONSTRAINT "relationship_health_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."research_items"
    ADD CONSTRAINT "research_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."research_items"
    ADD CONSTRAINT "research_items_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."review_curated_entries"
    ADD CONSTRAINT "review_curated_entries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."review_media_links"
    ADD CONSTRAINT "review_media_links_media_id_link_type_link_id_key" UNIQUE ("media_id", "link_type", "link_id");



ALTER TABLE ONLY "public"."review_media_links"
    ADD CONSTRAINT "review_media_links_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."review_projects"
    ADD CONSTRAINT "review_projects_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."review_projects"
    ADD CONSTRAINT "review_projects_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."review_videos"
    ADD CONSTRAINT "review_videos_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."review_year_settings"
    ADD CONSTRAINT "review_year_settings_pkey" PRIMARY KEY ("year");



ALTER TABLE ONLY "public"."role_taxonomy"
    ADD CONSTRAINT "role_taxonomy_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."scraped_services"
    ADD CONSTRAINT "scraped_services_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."scraping_metadata"
    ADD CONSTRAINT "scraping_metadata_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."search_history"
    ADD CONSTRAINT "search_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."service_contacts"
    ADD CONSTRAINT "service_contacts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."service_locations"
    ADD CONSTRAINT "service_locations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."services"
    ADD CONSTRAINT "services_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."services_profiles"
    ADD CONSTRAINT "services_profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."services_profiles"
    ADD CONSTRAINT "services_profiles_service_id_public_profile_id_key" UNIQUE ("service_id", "public_profile_id");



ALTER TABLE ONLY "public"."site_deployments"
    ADD CONSTRAINT "site_deployments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."site_deployments"
    ADD CONSTRAINT "site_deployments_vercel_deployment_id_key" UNIQUE ("vercel_deployment_id");



ALTER TABLE ONLY "public"."site_health_checks"
    ADD CONSTRAINT "site_health_checks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."skills_evidence"
    ADD CONSTRAINT "skills_evidence_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."sprint_snapshots"
    ADD CONSTRAINT "sprint_snapshots_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."sprint_snapshots"
    ADD CONSTRAINT "sprint_snapshots_sprint_name_snapshot_date_key" UNIQUE ("sprint_name", "snapshot_date");



ALTER TABLE ONLY "public"."stories"
    ADD CONSTRAINT "stories_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stories"
    ADD CONSTRAINT "stories_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."transcript_analysis"
    ADD CONSTRAINT "story_analysis_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."story_analysis"
    ADD CONSTRAINT "story_analysis_pkey1" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."story_attribution_events"
    ADD CONSTRAINT "story_attribution_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."story_comments"
    ADD CONSTRAINT "story_comments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."story_reactions"
    ADD CONSTRAINT "story_reactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."story_reactions"
    ADD CONSTRAINT "story_reactions_story_id_user_id_reaction_type_key" UNIQUE ("story_id", "user_id", "reaction_type");



ALTER TABLE ONLY "public"."story_related_art"
    ADD CONSTRAINT "story_related_art_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."story_related_art"
    ADD CONSTRAINT "story_related_art_story_id_art_innovation_id_key" UNIQUE ("story_id", "art_innovation_id");



ALTER TABLE ONLY "public"."story_related_interventions"
    ADD CONSTRAINT "story_related_interventions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."story_related_interventions"
    ADD CONSTRAINT "story_related_interventions_story_id_intervention_id_key" UNIQUE ("story_id", "intervention_id");



ALTER TABLE ONLY "public"."story_related_programs"
    ADD CONSTRAINT "story_related_programs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."story_related_programs"
    ADD CONSTRAINT "story_related_programs_story_id_program_id_key" UNIQUE ("story_id", "program_id");



ALTER TABLE ONLY "public"."story_related_services"
    ADD CONSTRAINT "story_related_services_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."story_related_services"
    ADD CONSTRAINT "story_related_services_story_id_service_id_key" UNIQUE ("story_id", "service_id");



ALTER TABLE ONLY "public"."storyteller_ai_intelligence"
    ADD CONSTRAINT "storyteller_ai_intelligence_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."storyteller_connections"
    ADD CONSTRAINT "storyteller_connections_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."storyteller_media"
    ADD CONSTRAINT "storyteller_media_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."storyteller_videos"
    ADD CONSTRAINT "storyteller_videos_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."storytellers"
    ADD CONSTRAINT "storytellers_airtable_record_id_key" UNIQUE ("airtable_record_id");



ALTER TABLE ONLY "public"."storytellers"
    ADD CONSTRAINT "storytellers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."studio_projects"
    ADD CONSTRAINT "studio_projects_code_key" UNIQUE ("code");



ALTER TABLE ONLY "public"."studio_projects"
    ADD CONSTRAINT "studio_projects_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."studio_projects"
    ADD CONSTRAINT "studio_projects_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."subscription_analytics"
    ADD CONSTRAINT "subscription_analytics_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscription_history"
    ADD CONSTRAINT "subscription_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscription_receipts"
    ADD CONSTRAINT "subscription_receipts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."suggestion_feedback"
    ADD CONSTRAINT "suggestion_feedback_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."support_matches"
    ADD CONSTRAINT "support_matches_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."sync_events"
    ADD CONSTRAINT "sync_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."sync_queue"
    ADD CONSTRAINT "sync_queue_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."sync_state"
    ADD CONSTRAINT "sync_state_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tag_inference_rules"
    ADD CONSTRAINT "tag_inference_rules_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."themes"
    ADD CONSTRAINT "themes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."touchpoints"
    ADD CONSTRAINT "touchpoints_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."training_dataset"
    ADD CONSTRAINT "training_dataset_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."transcripts"
    ADD CONSTRAINT "transcripts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."storyteller_connections"
    ADD CONSTRAINT "unique_connection" UNIQUE ("storyteller_a", "storyteller_b");



ALTER TABLE ONLY "public"."user_behavior_insights"
    ADD CONSTRAINT "user_behavior_insights_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_behavior_insights"
    ADD CONSTRAINT "user_behavior_insights_user_id_analysis_period_start_analys_key" UNIQUE ("user_id", "analysis_period_start", "analysis_period_end");



ALTER TABLE ONLY "public"."user_community_engagement"
    ADD CONSTRAINT "user_community_engagement_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_gamification_stats"
    ADD CONSTRAINT "user_gamification_stats_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_gamification_stats"
    ADD CONSTRAINT "user_gamification_stats_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."user_identities"
    ADD CONSTRAINT "user_identities_canonical_name_key" UNIQUE ("canonical_name");



ALTER TABLE ONLY "public"."user_identities"
    ADD CONSTRAINT "user_identities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."user_project_preferences"
    ADD CONSTRAINT "user_project_preferences_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_project_preferences"
    ADD CONSTRAINT "user_project_preferences_user_profile_id_project_id_prefere_key" UNIQUE ("user_profile_id", "project_id", "preference_type");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_username_key" UNIQUE ("username");



ALTER TABLE ONLY "public"."vendor_contact_log"
    ADD CONSTRAINT "vendor_contact_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."video_embeds"
    ADD CONSTRAINT "video_embeds_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."voice_note_shares"
    ADD CONSTRAINT "voice_note_shares_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."voice_note_shares"
    ADD CONSTRAINT "voice_note_shares_voice_note_id_shared_with_key" UNIQUE ("voice_note_id", "shared_with");



ALTER TABLE ONLY "public"."voice_notes"
    ADD CONSTRAINT "voice_notes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."volunteer_hours"
    ADD CONSTRAINT "volunteer_hours_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."volunteer_interest"
    ADD CONSTRAINT "volunteer_interest_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."wiki_articles"
    ADD CONSTRAINT "wiki_articles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."wiki_articles"
    ADD CONSTRAINT "wiki_articles_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."wiki_notifications"
    ADD CONSTRAINT "wiki_notifications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."wiki_page_links"
    ADD CONSTRAINT "wiki_page_links_from_page_id_to_page_id_link_type_key" UNIQUE ("from_page_id", "to_page_id", "link_type");



ALTER TABLE ONLY "public"."wiki_page_links"
    ADD CONSTRAINT "wiki_page_links_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."wiki_page_versions"
    ADD CONSTRAINT "wiki_page_versions_page_id_version_key" UNIQUE ("page_id", "version");



ALTER TABLE ONLY "public"."wiki_page_versions"
    ADD CONSTRAINT "wiki_page_versions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."wiki_pages"
    ADD CONSTRAINT "wiki_pages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."wiki_pages"
    ADD CONSTRAINT "wiki_pages_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."wisdom_extracts"
    ADD CONSTRAINT "wisdom_extracts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."wisdom_insights"
    ADD CONSTRAINT "wisdom_insights_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."xero_bank_transactions"
    ADD CONSTRAINT "xero_bank_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."xero_bank_transactions"
    ADD CONSTRAINT "xero_bank_transactions_xero_id_key" UNIQUE ("xero_id");



ALTER TABLE ONLY "public"."xero_bas_tracking"
    ADD CONSTRAINT "xero_bas_tracking_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."xero_bas_tracking"
    ADD CONSTRAINT "xero_bas_tracking_tenant_id_period_start_period_end_key" UNIQUE ("tenant_id", "period_start", "period_end");



ALTER TABLE ONLY "public"."xero_contacts"
    ADD CONSTRAINT "xero_contacts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."xero_contacts"
    ADD CONSTRAINT "xero_contacts_xero_id_key" UNIQUE ("xero_id");



ALTER TABLE ONLY "public"."xero_financial_alerts"
    ADD CONSTRAINT "xero_financial_alerts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."xero_financial_snapshots"
    ADD CONSTRAINT "xero_financial_snapshots_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."xero_financial_snapshots"
    ADD CONSTRAINT "xero_financial_snapshots_snapshot_date_snapshot_type_key" UNIQUE ("snapshot_date", "snapshot_type");



ALTER TABLE ONLY "public"."xero_invoices"
    ADD CONSTRAINT "xero_invoices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."xero_invoices"
    ADD CONSTRAINT "xero_invoices_xero_id_key" UNIQUE ("xero_id");



ALTER TABLE ONLY "public"."xero_sync_log"
    ADD CONSTRAINT "xero_sync_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."xero_sync_status"
    ADD CONSTRAINT "xero_sync_status_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."xero_sync_status"
    ADD CONSTRAINT "xero_sync_status_tenant_id_key" UNIQUE ("tenant_id");



ALTER TABLE ONLY "public"."xero_tokens"
    ADD CONSTRAINT "xero_tokens_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."xero_transactions"
    ADD CONSTRAINT "xero_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."xero_transactions"
    ADD CONSTRAINT "xero_transactions_xero_transaction_id_key" UNIQUE ("xero_transaction_id");



ALTER TABLE ONLY "public"."youth_detention_facilities"
    ADD CONSTRAINT "youth_detention_facilities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."youth_detention_facilities"
    ADD CONSTRAINT "youth_detention_facilities_slug_key" UNIQUE ("slug");



CREATE INDEX "financial_summary_reported_at_idx" ON "public"."financial_summary" USING "btree" ("reported_at" DESC);



CREATE INDEX "idx_agent_capabilities" ON "public"."agent_registry" USING "gin" ("capabilities");



CREATE INDEX "idx_agent_enabled" ON "public"."agent_registry" USING "btree" ("enabled");



CREATE INDEX "idx_agent_health" ON "public"."agent_registry" USING "btree" ("health_status");



CREATE INDEX "idx_agent_performance_agent" ON "public"."agent_performance" USING "btree" ("agent_id", "period_start");



CREATE INDEX "idx_agent_tags" ON "public"."agent_registry" USING "gin" ("tags");



CREATE INDEX "idx_agent_type" ON "public"."agent_registry" USING "btree" ("type");



CREATE INDEX "idx_ai_discoveries_confidence" ON "public"."ai_discoveries" USING "btree" ("confidence_score" DESC);



CREATE INDEX "idx_ai_discoveries_storyteller" ON "public"."ai_discoveries" USING "btree" ("storyteller_id");



CREATE INDEX "idx_ai_discoveries_type" ON "public"."ai_discoveries" USING "btree" ("discovery_type");



CREATE INDEX "idx_ai_discoveries_verified" ON "public"."ai_discoveries" USING "btree" ("human_verified");



CREATE INDEX "idx_album_photos_album_id" ON "public"."photo_album_photos" USING "btree" ("album_id");



CREATE INDEX "idx_album_photos_sort_order" ON "public"."photo_album_photos" USING "btree" ("album_id", "sort_order");



CREATE INDEX "idx_album_shares_album_id" ON "public"."photo_album_shares" USING "btree" ("album_id");



CREATE INDEX "idx_album_shares_method" ON "public"."photo_album_shares" USING "btree" ("share_method");



CREATE INDEX "idx_alma_consent_ledger_entity" ON "public"."alma_consent_ledger" USING "btree" ("entity_type", "entity_id");



CREATE INDEX "idx_alma_consent_ledger_level" ON "public"."alma_consent_ledger" USING "btree" ("consent_level");



CREATE INDEX "idx_alma_content_entities_content" ON "public"."alma_content_entities" USING "btree" ("raw_content_id");



CREATE INDEX "idx_alma_content_entities_entity" ON "public"."alma_content_entities" USING "btree" ("entity_type", "entity_id");



CREATE INDEX "idx_alma_contexts_consent_level" ON "public"."alma_community_contexts" USING "btree" ("consent_level");



CREATE INDEX "idx_alma_contexts_search" ON "public"."alma_community_contexts" USING "gin" ("search_vector");



CREATE INDEX "idx_alma_contexts_state" ON "public"."alma_community_contexts" USING "btree" ("state");



CREATE INDEX "idx_alma_contexts_type" ON "public"."alma_community_contexts" USING "btree" ("context_type");



CREATE UNIQUE INDEX "idx_alma_daily_sentiment_unique" ON "public"."alma_daily_sentiment" USING "btree" ("date", "source_name");



CREATE UNIQUE INDEX "idx_alma_dashboard_funding" ON "public"."alma_dashboard_funding" USING "btree" ("jurisdiction", "report_year");



CREATE UNIQUE INDEX "idx_alma_dashboard_interventions" ON "public"."alma_dashboard_interventions" USING "btree" ("jurisdiction", "intervention_type", "evidence_level");



CREATE UNIQUE INDEX "idx_alma_dashboard_sources" ON "public"."alma_dashboard_sources" USING "btree" ("source_type", "jurisdiction");



CREATE UNIQUE INDEX "idx_alma_dashboard_tags" ON "public"."alma_dashboard_tags" USING "btree" ("category", "slug");



CREATE INDEX "idx_alma_embeddings_entity" ON "public"."alma_embeddings" USING "btree" ("entity_type", "entity_id");



CREATE INDEX "idx_alma_embeddings_model" ON "public"."alma_embeddings" USING "btree" ("embedding_model");



CREATE INDEX "idx_alma_entity_sources_document" ON "public"."alma_entity_sources" USING "btree" ("source_document_id");



CREATE INDEX "idx_alma_entity_sources_entity" ON "public"."alma_entity_sources" USING "btree" ("entity_type", "entity_id");



CREATE INDEX "idx_alma_entity_tags_entity" ON "public"."alma_entity_tags" USING "btree" ("entity_type", "entity_id");



CREATE INDEX "idx_alma_entity_tags_tag" ON "public"."alma_entity_tags" USING "btree" ("tag_id");



CREATE INDEX "idx_alma_evidence_author_profile" ON "public"."alma_evidence" USING "btree" ("author_profile_id");



CREATE INDEX "idx_alma_evidence_consent_level" ON "public"."alma_evidence" USING "btree" ("consent_level");



CREATE INDEX "idx_alma_evidence_outcomes_evidence" ON "public"."alma_evidence_outcomes" USING "btree" ("evidence_id");



CREATE INDEX "idx_alma_evidence_outcomes_outcome" ON "public"."alma_evidence_outcomes" USING "btree" ("outcome_id");



CREATE INDEX "idx_alma_evidence_publication_date" ON "public"."alma_evidence" USING "btree" ("publication_date");



CREATE INDEX "idx_alma_evidence_search" ON "public"."alma_evidence" USING "gin" ("search_vector");



CREATE INDEX "idx_alma_evidence_type" ON "public"."alma_evidence" USING "btree" ("evidence_type");



CREATE INDEX "idx_alma_government_programs_announced_date" ON "public"."alma_government_programs" USING "btree" ("announced_date");



CREATE INDEX "idx_alma_government_programs_community_led" ON "public"."alma_government_programs" USING "btree" ("community_led", "cultural_authority");



CREATE INDEX "idx_alma_ingestion_jobs_category" ON "public"."alma_ingestion_jobs" USING "btree" ("category");



CREATE INDEX "idx_alma_ingestion_jobs_consent_level" ON "public"."alma_ingestion_jobs" USING "btree" ("consent_level");



CREATE INDEX "idx_alma_ingestion_jobs_created_at" ON "public"."alma_ingestion_jobs" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_alma_ingestion_jobs_source_url" ON "public"."alma_ingestion_jobs" USING "btree" ("source_url");



CREATE INDEX "idx_alma_ingestion_jobs_status" ON "public"."alma_ingestion_jobs" USING "btree" ("status");



CREATE INDEX "idx_alma_intervention_contexts_context" ON "public"."alma_intervention_contexts" USING "btree" ("context_id");



CREATE INDEX "idx_alma_intervention_contexts_intervention" ON "public"."alma_intervention_contexts" USING "btree" ("intervention_id");



CREATE INDEX "idx_alma_intervention_evidence_evidence" ON "public"."alma_intervention_evidence" USING "btree" ("evidence_id");



CREATE INDEX "idx_alma_intervention_evidence_intervention" ON "public"."alma_intervention_evidence" USING "btree" ("intervention_id");



CREATE INDEX "idx_alma_intervention_funding_intervention" ON "public"."alma_intervention_funding" USING "btree" ("intervention_id");



CREATE INDEX "idx_alma_intervention_funding_source" ON "public"."alma_intervention_funding" USING "btree" ("funding_source");



CREATE INDEX "idx_alma_intervention_outcomes_intervention" ON "public"."alma_intervention_outcomes" USING "btree" ("intervention_id");



CREATE INDEX "idx_alma_intervention_outcomes_outcome" ON "public"."alma_intervention_outcomes" USING "btree" ("outcome_id");



CREATE INDEX "idx_alma_intervention_profiles_intervention" ON "public"."alma_intervention_profiles" USING "btree" ("intervention_id");



CREATE INDEX "idx_alma_intervention_profiles_profile" ON "public"."alma_intervention_profiles" USING "btree" ("public_profile_id");



CREATE INDEX "idx_alma_intervention_profiles_role" ON "public"."alma_intervention_profiles" USING "btree" ("role");



CREATE INDEX "idx_alma_interventions_consent_level" ON "public"."alma_interventions" USING "btree" ("consent_level");



CREATE INDEX "idx_alma_interventions_evidence_level" ON "public"."alma_interventions" USING "btree" ("evidence_level");



CREATE INDEX "idx_alma_interventions_geography" ON "public"."alma_interventions" USING "gin" ("geography");



CREATE INDEX "idx_alma_interventions_org" ON "public"."alma_interventions" USING "btree" ("operating_organization_id");



CREATE INDEX "idx_alma_interventions_review_status" ON "public"."alma_interventions" USING "btree" ("review_status");



CREATE INDEX "idx_alma_interventions_search" ON "public"."alma_interventions" USING "gin" ("search_vector");



CREATE INDEX "idx_alma_interventions_target_cohort" ON "public"."alma_interventions" USING "gin" ("target_cohort");



CREATE INDEX "idx_alma_interventions_type" ON "public"."alma_interventions" USING "btree" ("type");



CREATE INDEX "idx_alma_media_articles_published_date" ON "public"."alma_media_articles" USING "btree" ("published_date" DESC);



CREATE INDEX "idx_alma_media_articles_sentiment" ON "public"."alma_media_articles" USING "btree" ("sentiment", "sentiment_score");



CREATE INDEX "idx_alma_media_articles_source" ON "public"."alma_media_articles" USING "btree" ("source_name");



CREATE INDEX "idx_alma_media_articles_topics" ON "public"."alma_media_articles" USING "gin" ("topics");



CREATE INDEX "idx_alma_metrics_history_metric" ON "public"."alma_metrics_history" USING "btree" ("metric_name", "metric_category");



CREATE INDEX "idx_alma_metrics_history_time" ON "public"."alma_metrics_history" USING "btree" ("recorded_at");



CREATE INDEX "idx_alma_outcomes_search" ON "public"."alma_outcomes" USING "gin" ("search_vector");



CREATE INDEX "idx_alma_outcomes_type" ON "public"."alma_outcomes" USING "btree" ("outcome_type");



CREATE INDEX "idx_alma_raw_content_extracted_at" ON "public"."alma_raw_content" USING "btree" ("extracted_at");



CREATE INDEX "idx_alma_raw_content_file_path" ON "public"."alma_raw_content" USING "btree" ("file_path") WHERE ("file_path" IS NOT NULL);



CREATE INDEX "idx_alma_raw_content_search" ON "public"."alma_raw_content" USING "gin" ("search_vector");



CREATE INDEX "idx_alma_raw_content_source_url" ON "public"."alma_raw_content" USING "btree" ("source_url");



CREATE INDEX "idx_alma_raw_content_status" ON "public"."alma_raw_content" USING "btree" ("processing_status");



CREATE UNIQUE INDEX "idx_alma_sentiment_program_correlation_unique" ON "public"."alma_sentiment_program_correlation" USING "btree" ("program_id");



CREATE INDEX "idx_alma_source_documents_jurisdiction" ON "public"."alma_source_documents" USING "btree" ("jurisdiction");



CREATE INDEX "idx_alma_source_documents_org" ON "public"."alma_source_documents" USING "btree" ("source_organization");



CREATE INDEX "idx_alma_source_documents_search" ON "public"."alma_source_documents" USING "gin" ("search_vector");



CREATE INDEX "idx_alma_source_documents_topics" ON "public"."alma_source_documents" USING "gin" ("topics");



CREATE INDEX "idx_alma_source_documents_type" ON "public"."alma_source_documents" USING "btree" ("document_type");



CREATE INDEX "idx_alma_tags_category" ON "public"."alma_tags" USING "btree" ("category");



CREATE INDEX "idx_alma_tags_parent" ON "public"."alma_tags" USING "btree" ("parent_id");



CREATE INDEX "idx_alma_usage_log_action" ON "public"."alma_usage_log" USING "btree" ("action");



CREATE INDEX "idx_alma_usage_log_entity" ON "public"."alma_usage_log" USING "btree" ("entity_type", "entity_id");



CREATE INDEX "idx_alma_usage_log_user" ON "public"."alma_usage_log" USING "btree" ("user_id");



CREATE INDEX "idx_analysis_jobs_status_scheduled" ON "public"."analysis_jobs" USING "btree" ("status", "scheduled_at");



CREATE INDEX "idx_analysis_jobs_storyteller" ON "public"."analysis_jobs" USING "btree" ("storyteller_id");



CREATE INDEX "idx_analysis_jobs_transcript" ON "public"."analysis_jobs" USING "btree" ("transcript_id");



CREATE INDEX "idx_analytics_recommendation" ON "public"."subscription_analytics" USING "btree" ("recommendation");



CREATE INDEX "idx_analytics_subscription" ON "public"."subscription_analytics" USING "btree" ("subscription_id");



CREATE INDEX "idx_api_usage_agent" ON "public"."api_usage" USING "btree" ("agent_id");



CREATE INDEX "idx_api_usage_batch" ON "public"."api_usage" USING "btree" ("batch_id") WHERE ("batch_id" IS NOT NULL);



CREATE INDEX "idx_api_usage_cache" ON "public"."api_usage" USING "btree" ("cache_key") WHERE ("cache_hit" = false);



CREATE INDEX "idx_api_usage_model" ON "public"."api_usage" USING "btree" ("model");



CREATE INDEX "idx_api_usage_provider" ON "public"."api_usage" USING "btree" ("provider", "timestamp");



CREATE INDEX "idx_api_usage_script" ON "public"."api_usage" USING "btree" ("script_name");



CREATE INDEX "idx_api_usage_timestamp" ON "public"."api_usage" USING "btree" ("timestamp" DESC);



CREATE INDEX "idx_art_innovation_featured" ON "public"."art_innovation" USING "btree" ("is_featured") WHERE ("is_featured" = true);



CREATE INDEX "idx_art_innovation_organization" ON "public"."art_innovation" USING "btree" ("organization_id");



CREATE INDEX "idx_art_innovation_profiles_art" ON "public"."art_innovation_profiles" USING "btree" ("art_innovation_id");



CREATE INDEX "idx_art_innovation_profiles_order" ON "public"."art_innovation_profiles" USING "btree" ("art_innovation_id", "display_order");



CREATE INDEX "idx_art_innovation_profiles_profile" ON "public"."art_innovation_profiles" USING "btree" ("public_profile_id");



CREATE INDEX "idx_art_innovation_program" ON "public"."art_innovation" USING "btree" ("program_id");



CREATE INDEX "idx_art_innovation_search" ON "public"."art_innovation" USING "gin" ("search_vector");



CREATE INDEX "idx_art_innovation_slug" ON "public"."art_innovation" USING "btree" ("slug");



CREATE INDEX "idx_art_innovation_status" ON "public"."art_innovation" USING "btree" ("status");



CREATE INDEX "idx_art_innovation_tags" ON "public"."art_innovation" USING "gin" ("tags");



CREATE INDEX "idx_art_innovation_type" ON "public"."art_innovation" USING "btree" ("type");



CREATE INDEX "idx_article_locations_article" ON "public"."article_locations" USING "btree" ("article_id");



CREATE INDEX "idx_article_locations_coords" ON "public"."article_locations" USING "btree" ("latitude", "longitude") WHERE (("latitude" IS NOT NULL) AND ("longitude" IS NOT NULL));



CREATE INDEX "idx_article_related_art_art" ON "public"."article_related_art" USING "btree" ("art_innovation_id");



CREATE INDEX "idx_article_related_art_article" ON "public"."article_related_art" USING "btree" ("article_id");



CREATE INDEX "idx_article_related_articles_article" ON "public"."article_related_articles" USING "btree" ("article_id");



CREATE INDEX "idx_article_related_articles_related" ON "public"."article_related_articles" USING "btree" ("related_article_id");



CREATE INDEX "idx_article_related_evidence_article" ON "public"."article_related_evidence" USING "btree" ("article_id");



CREATE INDEX "idx_article_related_evidence_evidence" ON "public"."article_related_evidence" USING "btree" ("evidence_id");



CREATE INDEX "idx_article_related_interventions_article" ON "public"."article_related_interventions" USING "btree" ("article_id");



CREATE INDEX "idx_article_related_interventions_intervention" ON "public"."article_related_interventions" USING "btree" ("intervention_id");



CREATE INDEX "idx_article_related_programs_article" ON "public"."article_related_programs" USING "btree" ("article_id");



CREATE INDEX "idx_article_related_programs_program" ON "public"."article_related_programs" USING "btree" ("program_id");



CREATE INDEX "idx_article_related_services_article" ON "public"."article_related_services" USING "btree" ("article_id");



CREATE INDEX "idx_article_related_services_service" ON "public"."article_related_services" USING "btree" ("service_id");



CREATE INDEX "idx_article_tags_article" ON "public"."article_tags" USING "btree" ("article_id");



CREATE INDEX "idx_article_tags_tag" ON "public"."article_tags" USING "btree" ("tag");



CREATE INDEX "idx_articles_author" ON "public"."articles" USING "btree" ("author_id");



CREATE INDEX "idx_articles_category" ON "public"."articles" USING "btree" ("category");



CREATE INDEX "idx_articles_published" ON "public"."articles" USING "btree" ("published_at" DESC) WHERE ("status" = 'published'::"text");



CREATE INDEX "idx_articles_search" ON "public"."articles" USING "gin" ("to_tsvector"('"english"'::"regconfig", (((("title" || ' '::"text") || COALESCE("excerpt", ''::"text")) || ' '::"text") || "content")));



CREATE INDEX "idx_articles_slug" ON "public"."articles" USING "btree" ("slug");



CREATE INDEX "idx_articles_status" ON "public"."articles" USING "btree" ("status");



CREATE INDEX "idx_articles_trending" ON "public"."articles" USING "btree" ("is_trending") WHERE ("is_trending" = true);



CREATE INDEX "idx_attribution_event_type" ON "public"."story_attribution_events" USING "btree" ("event_type");



CREATE INDEX "idx_attribution_storyteller" ON "public"."story_attribution_events" USING "btree" ("storyteller_id");



CREATE INDEX "idx_attribution_timestamp" ON "public"."story_attribution_events" USING "btree" ("timestamp");



CREATE INDEX "idx_audit_action" ON "public"."audit_logs" USING "btree" ("action_category");



CREATE INDEX "idx_audit_agent" ON "public"."agent_audit_log" USING "btree" ("agent_id");



CREATE INDEX "idx_audit_agent_time" ON "public"."agent_audit_log" USING "btree" ("agent_id", "timestamp" DESC);



CREATE INDEX "idx_audit_created" ON "public"."audit_logs" USING "btree" ("created_at");



CREATE INDEX "idx_audit_cultural" ON "public"."agent_audit_log" USING "btree" ("cultural_data_accessed") WHERE ("cultural_data_accessed" = true);



CREATE INDEX "idx_audit_resource" ON "public"."audit_logs" USING "btree" ("resource_type", "resource_id");



CREATE INDEX "idx_audit_success" ON "public"."agent_audit_log" USING "btree" ("success") WHERE ("success" = false);



CREATE INDEX "idx_audit_target" ON "public"."agent_audit_log" USING "btree" ("target_table");



CREATE INDEX "idx_audit_timestamp" ON "public"."agent_audit_log" USING "btree" ("timestamp" DESC);



CREATE INDEX "idx_audit_user" ON "public"."audit_logs" USING "btree" ("user_id");



CREATE INDEX "idx_australian_frameworks_active" ON "public"."australian_frameworks" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_australian_frameworks_display_order" ON "public"."australian_frameworks" USING "btree" ("display_order");



CREATE INDEX "idx_australian_frameworks_slug" ON "public"."australian_frameworks" USING "btree" ("slug");



CREATE INDEX "idx_australian_frameworks_state" ON "public"."australian_frameworks" USING "btree" ("state");



CREATE INDEX "idx_authors_public_profile" ON "public"."authors" USING "btree" ("public_profile_id");



CREATE INDEX "idx_authors_slug" ON "public"."authors" USING "btree" ("slug");



CREATE INDEX "idx_automated_insights_category" ON "public"."automated_insights" USING "btree" ("insight_category", "insight_type");



CREATE INDEX "idx_automated_insights_priority" ON "public"."automated_insights" USING "btree" ("priority_level", "status", "created_at" DESC);



CREATE INDEX "idx_bcust_tenant_email" ON "public"."billing_customers" USING "btree" ("tenant_id", "email");



CREATE INDEX "idx_bilines_invoice" ON "public"."billing_invoice_lines" USING "btree" ("invoice_id");



CREATE INDEX "idx_binv_customer" ON "public"."billing_invoices" USING "btree" ("customer_id");



CREATE INDEX "idx_binv_tenant_status" ON "public"."billing_invoices" USING "btree" ("tenant_id", "status");



CREATE INDEX "idx_blog_comments_post" ON "public"."blog_comments" USING "btree" ("blog_post_id");



CREATE INDEX "idx_blog_content_links_post" ON "public"."blog_content_links" USING "btree" ("blog_post_id");



CREATE INDEX "idx_blog_media_post" ON "public"."blog_media" USING "btree" ("blog_post_id");



CREATE INDEX "idx_blog_posts_author" ON "public"."blog_posts" USING "btree" ("author_id");



CREATE INDEX "idx_blog_posts_empathy_story" ON "public"."blog_posts" USING "btree" ("empathy_ledger_story_id") WHERE ("empathy_ledger_story_id" IS NOT NULL);



CREATE INDEX "idx_blog_posts_empathy_transcript" ON "public"."blog_posts" USING "btree" ("empathy_ledger_transcript_id") WHERE ("empathy_ledger_transcript_id" IS NOT NULL);



CREATE INDEX "idx_blog_posts_profiles_post_id" ON "public"."blog_posts_profiles" USING "btree" ("blog_post_id");



CREATE INDEX "idx_blog_posts_profiles_profile_id" ON "public"."blog_posts_profiles" USING "btree" ("public_profile_id");



CREATE INDEX "idx_blog_posts_published_at" ON "public"."blog_posts" USING "btree" ("published_at" DESC);



CREATE INDEX "idx_blog_posts_slug" ON "public"."blog_posts" USING "btree" ("slug");



CREATE INDEX "idx_blog_posts_status" ON "public"."blog_posts" USING "btree" ("status");



CREATE INDEX "idx_blog_posts_synced_empathy" ON "public"."blog_posts" USING "btree" ("synced_from_empathy_ledger") WHERE ("synced_from_empathy_ledger" = true);



CREATE INDEX "idx_book_proj_link_project" ON "public"."bookkeeping_project_links" USING "btree" ("tenant_id", "project_id");



CREATE UNIQUE INDEX "idx_book_proj_link_unique" ON "public"."bookkeeping_project_links" USING "btree" ("tenant_id", "transaction_id", "project_id");



CREATE INDEX "idx_book_receipts_tenant" ON "public"."bookkeeping_receipts" USING "btree" ("tenant_id", "receipt_date" DESC);



CREATE INDEX "idx_book_rules_tenant_priority" ON "public"."bookkeeping_rules" USING "btree" ("tenant_id", "priority");



CREATE INDEX "idx_book_txn_category" ON "public"."bookkeeping_transactions" USING "btree" ("tenant_id", "category");



CREATE INDEX "idx_book_txn_tenant_date" ON "public"."bookkeeping_transactions" USING "btree" ("tenant_id", "txn_date" DESC);



CREATE INDEX "idx_bpay_invoice" ON "public"."billing_payments" USING "btree" ("invoice_id", "status");



CREATE INDEX "idx_bprice_product" ON "public"."billing_prices" USING "btree" ("product_id", "active");



CREATE INDEX "idx_bprod_tenant" ON "public"."billing_products" USING "btree" ("tenant_id", "active");



CREATE INDEX "idx_bsub_customer" ON "public"."billing_subscriptions" USING "btree" ("customer_id");



CREATE INDEX "idx_bsub_tenant_status" ON "public"."billing_subscriptions" USING "btree" ("tenant_id", "status");



CREATE INDEX "idx_bsubitem_sub" ON "public"."billing_subscription_items" USING "btree" ("subscription_id");



CREATE INDEX "idx_btax_tenant_active" ON "public"."billing_tax_rates" USING "btree" ("tenant_id", "active");



CREATE INDEX "idx_business_agent_queries_confidence" ON "public"."business_agent_queries" USING "btree" ("confidence" DESC);



CREATE INDEX "idx_business_agent_queries_created_at" ON "public"."business_agent_queries" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_business_alerts_alert_type" ON "public"."business_alerts" USING "btree" ("alert_type");



CREATE INDEX "idx_business_alerts_due_date" ON "public"."business_alerts" USING "btree" ("due_date");



CREATE INDEX "idx_business_alerts_priority" ON "public"."business_alerts" USING "btree" ("priority" DESC);



CREATE INDEX "idx_business_alerts_status" ON "public"."business_alerts" USING "btree" ("status");



CREATE INDEX "idx_bwebhook_provider_status" ON "public"."billing_webhook_events" USING "btree" ("provider", "status");



CREATE INDEX "idx_calendar_events_attendees" ON "public"."calendar_events" USING "gin" ("attendees");



CREATE INDEX "idx_calendar_events_calendar" ON "public"."calendar_events" USING "btree" ("google_calendar_id");



CREATE INDEX "idx_calendar_events_google_id" ON "public"."calendar_events" USING "btree" ("google_event_id");



CREATE INDEX "idx_calendar_events_organizer" ON "public"."calendar_events" USING "btree" ("organizer_email");



CREATE INDEX "idx_calendar_events_project" ON "public"."calendar_events" USING "btree" ("project_code");



CREATE INDEX "idx_calendar_events_status" ON "public"."calendar_events" USING "btree" ("status");



CREATE INDEX "idx_calendar_events_synced" ON "public"."calendar_events" USING "btree" ("synced_at");



CREATE INDEX "idx_calendar_events_time_range" ON "public"."calendar_events" USING "btree" ("start_time", "end_time");



CREATE INDEX "idx_calendar_events_title_search" ON "public"."calendar_events" USING "gin" ("to_tsvector"('"english"'::"regconfig", "title"));



CREATE INDEX "idx_calendar_events_type" ON "public"."calendar_events" USING "btree" ("event_type");



CREATE INDEX "idx_campaigns_categories" ON "public"."justice_matrix_campaigns" USING "gin" ("categories");



CREATE INDEX "idx_campaigns_country" ON "public"."justice_matrix_campaigns" USING "btree" ("country_region");



CREATE INDEX "idx_campaigns_featured" ON "public"."justice_matrix_campaigns" USING "btree" ("featured") WHERE ("featured" = true);



CREATE INDEX "idx_campaigns_fts" ON "public"."justice_matrix_campaigns" USING "gin" ("to_tsvector"('"english"'::"regconfig", ((((COALESCE("campaign_name", ''::"text") || ' '::"text") || COALESCE("goals", ''::"text")) || ' '::"text") || COALESCE("notable_tactics", ''::"text"))));



CREATE INDEX "idx_campaigns_lat_lng" ON "public"."justice_matrix_campaigns" USING "btree" ("lat", "lng");



CREATE INDEX "idx_campaigns_ongoing" ON "public"."justice_matrix_campaigns" USING "btree" ("is_ongoing");



CREATE INDEX "idx_canonical_company" ON "public"."canonical_entities" USING "btree" ("canonical_company");



CREATE INDEX "idx_canonical_confidence" ON "public"."canonical_entities" USING "btree" ("confidence");



CREATE INDEX "idx_canonical_email" ON "public"."canonical_entities" USING "btree" ("canonical_email");



CREATE INDEX "idx_canonical_entity_type" ON "public"."canonical_entities" USING "btree" ("entity_type");



CREATE INDEX "idx_canonical_name" ON "public"."canonical_entities" USING "btree" ("canonical_name");



CREATE INDEX "idx_canonical_phone" ON "public"."canonical_entities" USING "btree" ("canonical_phone");



CREATE INDEX "idx_cases_categories" ON "public"."justice_matrix_cases" USING "gin" ("categories");



CREATE INDEX "idx_cases_country" ON "public"."justice_matrix_cases" USING "btree" ("country_code");



CREATE INDEX "idx_cases_featured" ON "public"."justice_matrix_cases" USING "btree" ("featured") WHERE ("featured" = true);



CREATE INDEX "idx_cases_fts" ON "public"."justice_matrix_cases" USING "gin" ("to_tsvector"('"english"'::"regconfig", ((((COALESCE("case_citation", ''::"text") || ' '::"text") || COALESCE("strategic_issue", ''::"text")) || ' '::"text") || COALESCE("key_holding", ''::"text"))));



CREATE INDEX "idx_cases_jurisdiction" ON "public"."justice_matrix_cases" USING "btree" ("jurisdiction");



CREATE INDEX "idx_cases_lat_lng" ON "public"."justice_matrix_cases" USING "btree" ("lat", "lng");



CREATE INDEX "idx_cases_outcome" ON "public"."justice_matrix_cases" USING "btree" ("outcome");



CREATE INDEX "idx_cases_region" ON "public"."justice_matrix_cases" USING "btree" ("region");



CREATE INDEX "idx_cases_year" ON "public"."justice_matrix_cases" USING "btree" ("year");



CREATE INDEX "idx_ce_activities_user_id" ON "public"."ce_activities" USING "btree" ("user_id");



CREATE INDEX "idx_ce_brand_tests_active" ON "public"."ce_brand_tests" USING "btree" ("is_active");



CREATE INDEX "idx_ce_metrics_user_id" ON "public"."ce_metrics" USING "btree" ("user_id");



CREATE INDEX "idx_ce_stories_published" ON "public"."ce_stories" USING "btree" ("is_published");



CREATE INDEX "idx_channel_messages_channel" ON "public"."channel_messages" USING "btree" ("channel", "channel_id");



CREATE INDEX "idx_channel_messages_task" ON "public"."channel_messages" USING "btree" ("task_id");



CREATE INDEX "idx_chat_project" ON "public"."agentic_chat" USING "btree" ("project_id", "created_at");



CREATE INDEX "idx_cl_active" ON "public"."cultural_liaisons" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_cl_communities" ON "public"."cultural_liaisons" USING "gin" ("communities");



CREATE INDEX "idx_clearinghouse_documents_source_system" ON "public"."clearinghouse_documents" USING "btree" ("source_system");



CREATE INDEX "idx_clearinghouse_documents_status" ON "public"."clearinghouse_documents" USING "btree" ("status");



CREATE INDEX "idx_clearinghouse_documents_tags" ON "public"."clearinghouse_documents" USING "gin" ("tags");



CREATE INDEX "idx_cms_content_blocks_type" ON "public"."cms_content_blocks" USING "btree" ("block_type");



CREATE INDEX "idx_cms_media_category" ON "public"."cms_media" USING "btree" ("category");



CREATE INDEX "idx_cms_pages_project_id" ON "public"."cms_pages" USING "btree" ("project_id");



CREATE INDEX "idx_cms_pages_slug" ON "public"."cms_pages" USING "btree" ("slug");



CREATE INDEX "idx_cms_pages_status" ON "public"."cms_pages" USING "btree" ("status");



CREATE INDEX "idx_coe_key_people_display_order" ON "public"."coe_key_people" USING "btree" ("display_order");



CREATE INDEX "idx_collection_media_sort" ON "public"."collection_media" USING "btree" ("collection_id", "sort_order");



CREATE INDEX "idx_comms_channel" ON "public"."communications_history" USING "btree" ("channel");



CREATE INDEX "idx_comms_contact" ON "public"."communications_history" USING "btree" ("ghl_contact_id");



CREATE INDEX "idx_comms_contact_email" ON "public"."communications_history" USING "btree" ("contact_email");



CREATE INDEX "idx_comms_needs_response" ON "public"."communications_history" USING "btree" ("requires_response", "response_received_at") WHERE ("requires_response" = true);



CREATE INDEX "idx_comms_occurred" ON "public"."communications_history" USING "btree" ("occurred_at" DESC);



CREATE INDEX "idx_comms_source" ON "public"."communications_history" USING "btree" ("source_system", "source_id");



CREATE INDEX "idx_comms_thread" ON "public"."communications_history" USING "btree" ("source_thread_id");



CREATE INDEX "idx_comms_topics" ON "public"."communications_history" USING "gin" ("topics");



CREATE INDEX "idx_comms_waiting" ON "public"."communications_history" USING "btree" ("waiting_for_response") WHERE ("waiting_for_response" = true);



CREATE INDEX "idx_communications_history_project_code" ON "public"."communications_history" USING "btree" ("project_code");



CREATE INDEX "idx_community_connections_storyteller" ON "public"."community_connections" USING "btree" ("storyteller_id");



CREATE INDEX "idx_community_events_project" ON "public"."community_events" USING "btree" ("project_id", "event_timestamp" DESC);



CREATE INDEX "idx_community_events_properties" ON "public"."community_events" USING "gin" ("event_properties");



CREATE INDEX "idx_community_events_session" ON "public"."community_events" USING "btree" ("session_id", "event_timestamp");



CREATE INDEX "idx_community_events_type_category" ON "public"."community_events" USING "btree" ("event_type", "event_category");



CREATE INDEX "idx_community_events_user_time" ON "public"."community_events" USING "btree" ("user_id", "created_at" DESC);



CREATE INDEX "idx_community_feedback_content" ON "public"."community_feedback" USING "btree" ("content_id", "content_type");



CREATE INDEX "idx_community_feedback_severity" ON "public"."community_feedback" USING "btree" ("severity");



CREATE INDEX "idx_community_feedback_status" ON "public"."community_feedback" USING "btree" ("status");



CREATE INDEX "idx_community_feedback_type" ON "public"."community_feedback" USING "btree" ("feedback_type");



CREATE INDEX "idx_community_health_metrics_date" ON "public"."community_health_metrics" USING "btree" ("community_id", "metric_date" DESC);



CREATE INDEX "idx_community_programs_alma_intervention" ON "public"."registered_services" USING "btree" ("alma_intervention_id");



CREATE INDEX "idx_community_programs_approach" ON "public"."registered_services" USING "btree" ("approach");



CREATE INDEX "idx_community_programs_featured" ON "public"."registered_services" USING "btree" ("is_featured");



CREATE INDEX "idx_community_programs_indigenous" ON "public"."registered_services" USING "btree" ("indigenous_knowledge");



CREATE INDEX "idx_community_programs_location" ON "public"."registered_services" USING "btree" ("latitude", "longitude") WHERE ("latitude" IS NOT NULL);



CREATE INDEX "idx_community_programs_organization_id" ON "public"."registered_services" USING "btree" ("organization_id");



CREATE INDEX "idx_community_programs_profiles_order" ON "public"."registered_services_profiles" USING "btree" ("program_id", "display_order");



CREATE INDEX "idx_community_programs_profiles_profile" ON "public"."registered_services_profiles" USING "btree" ("public_profile_id");



CREATE INDEX "idx_community_programs_profiles_program" ON "public"."registered_services_profiles" USING "btree" ("program_id");



CREATE INDEX "idx_community_programs_search" ON "public"."registered_services" USING "gin" ("search_vector");



CREATE INDEX "idx_community_programs_service_id" ON "public"."registered_services" USING "btree" ("service_id");



CREATE INDEX "idx_community_programs_state" ON "public"."registered_services" USING "btree" ("state");



CREATE INDEX "idx_compliance_tracking_compliance_type" ON "public"."compliance_tracking" USING "btree" ("compliance_type");



CREATE INDEX "idx_compliance_tracking_due_date" ON "public"."compliance_tracking" USING "btree" ("due_date");



CREATE INDEX "idx_compliance_tracking_status" ON "public"."compliance_tracking" USING "btree" ("status");



CREATE INDEX "idx_connections_status" ON "public"."storyteller_connections" USING "btree" ("status");



CREATE INDEX "idx_connections_storyteller_a" ON "public"."storyteller_connections" USING "btree" ("storyteller_a");



CREATE INDEX "idx_connections_storyteller_b" ON "public"."storyteller_connections" USING "btree" ("storyteller_b");



CREATE INDEX "idx_connections_type" ON "public"."storyteller_connections" USING "btree" ("connection_type");



CREATE INDEX "idx_consent_management_storyteller" ON "public"."consent_management" USING "btree" ("storyteller_id");



CREATE INDEX "idx_consent_status" ON "public"."consent_records" USING "btree" ("status");



CREATE INDEX "idx_consent_storyteller" ON "public"."consent_records" USING "btree" ("storyteller_id");



CREATE INDEX "idx_consent_type" ON "public"."consent_records" USING "btree" ("consent_type");



CREATE INDEX "idx_contact_communications_contact" ON "public"."contact_communications" USING "btree" ("ghl_contact_id", "occurred_at" DESC);



CREATE INDEX "idx_contact_communications_date" ON "public"."contact_communications" USING "btree" ("occurred_at" DESC);



CREATE INDEX "idx_contact_communications_type" ON "public"."contact_communications" USING "btree" ("comm_type", "direction");



CREATE INDEX "idx_contact_enrichments_collaboration_potential" ON "public"."contact_enrichments" USING "btree" ("collaboration_potential" DESC);



CREATE INDEX "idx_contact_enrichments_contact_id" ON "public"."contact_enrichments" USING "btree" ("contact_id");



CREATE INDEX "idx_contact_enrichments_created_at" ON "public"."contact_enrichments" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_contact_intelligence_collaboration_score" ON "public"."contact_intelligence" USING "btree" ("collaboration_score" DESC);



CREATE INDEX "idx_contact_intelligence_contact_id" ON "public"."contact_intelligence" USING "btree" ("contact_id");



CREATE INDEX "idx_contact_intelligence_insights_contact" ON "public"."contact_intelligence_insights" USING "btree" ("contact_id");



CREATE INDEX "idx_contact_intelligence_insights_enriched" ON "public"."contact_intelligence_insights" USING "btree" ("enriched_at" DESC);



CREATE INDEX "idx_contact_intelligence_updated_at" ON "public"."contact_intelligence" USING "btree" ("updated_at" DESC);



CREATE INDEX "idx_contact_interactions_contact_id" ON "public"."contact_interactions" USING "btree" ("contact_id");



CREATE INDEX "idx_contact_interactions_interaction_date" ON "public"."contact_interactions" USING "btree" ("interaction_date" DESC);



CREATE INDEX "idx_contact_interactions_interaction_type" ON "public"."contact_interactions" USING "btree" ("interaction_type");



CREATE INDEX "idx_contact_project_links_entity" ON "public"."contact_project_links" USING "btree" ("entity_id");



CREATE INDEX "idx_contact_project_links_project" ON "public"."contact_project_links" USING "btree" ("project_code");



CREATE INDEX "idx_contact_review_decision" ON "public"."contact_review_decisions" USING "btree" ("decision");



CREATE INDEX "idx_contact_review_domain" ON "public"."contact_review_decisions" USING "btree" ("domain");



CREATE INDEX "idx_contact_review_email" ON "public"."contact_review_decisions" USING "btree" ("normalized_email");



CREATE INDEX "idx_conversation_context_expiry" ON "public"."conversation_context" USING "btree" ("expires_at");



CREATE INDEX "idx_conversation_context_session" ON "public"."conversation_context" USING "btree" ("session_id", "created_at" DESC);



CREATE INDEX "idx_crq_item" ON "public"."cultural_review_queue" USING "btree" ("item_type", "item_id");



CREATE INDEX "idx_crq_pending" ON "public"."cultural_review_queue" USING "btree" ("status", "priority") WHERE ("status" = 'pending'::"text");



CREATE INDEX "idx_crq_status" ON "public"."cultural_review_queue" USING "btree" ("status");



CREATE INDEX "idx_cultural_entity" ON "public"."cultural_protocols" USING "btree" ("entity_type", "entity_id");



CREATE INDEX "idx_cultural_protocols_elder" ON "public"."cultural_protocols" USING "btree" ("elder_status");



CREATE INDEX "idx_cultural_protocols_ghl" ON "public"."cultural_protocols" USING "btree" ("ghl_contact_id");



CREATE INDEX "idx_cultural_sensitivity" ON "public"."cultural_protocols" USING "btree" ("sensitivity_level");



CREATE INDEX "idx_data_quality_metrics_date" ON "public"."data_quality_metrics" USING "btree" ("table_name", "analysis_date" DESC);



CREATE INDEX "idx_data_sources_active" ON "public"."data_sources" USING "btree" ("active");



CREATE INDEX "idx_data_sources_last_scrape" ON "public"."data_sources" USING "btree" ("last_successful_scrape");



CREATE INDEX "idx_data_sources_type" ON "public"."data_sources" USING "btree" ("type");



CREATE INDEX "idx_decision_outcomes_decision_id" ON "public"."decision_outcomes" USING "btree" ("decision_id");



CREATE INDEX "idx_decision_outcomes_recorded_at" ON "public"."decision_outcomes" USING "btree" ("recorded_at");



CREATE INDEX "idx_decision_traces_agent" ON "public"."decision_traces" USING "btree" ("agent_id");



CREATE INDEX "idx_decision_traces_confidence" ON "public"."decision_traces" USING "btree" ("confidence");



CREATE INDEX "idx_decision_traces_decision_gin" ON "public"."decision_traces" USING "gin" ("decision");



CREATE INDEX "idx_decision_traces_feedback" ON "public"."decision_traces" USING "btree" ("human_feedback") WHERE ("human_feedback" IS NOT NULL);



CREATE INDEX "idx_decision_traces_input_gin" ON "public"."decision_traces" USING "gin" ("input_context");



CREATE INDEX "idx_decision_traces_input_hash" ON "public"."decision_traces" USING "btree" ("input_hash") WHERE ("input_hash" IS NOT NULL);



CREATE INDEX "idx_decision_traces_outcome" ON "public"."decision_traces" USING "btree" ("outcome_status");



CREATE INDEX "idx_decision_traces_timestamp" ON "public"."decision_traces" USING "btree" ("timestamp" DESC);



CREATE INDEX "idx_decision_traces_type" ON "public"."decision_traces" USING "btree" ("decision_type");



CREATE INDEX "idx_decisions_category" ON "public"."decisions" USING "btree" ("category");



CREATE INDEX "idx_decisions_created_at" ON "public"."decisions" USING "btree" ("created_at");



CREATE INDEX "idx_decisions_due_date" ON "public"."decisions" USING "btree" ("due_date");



CREATE INDEX "idx_decisions_priority" ON "public"."decisions" USING "btree" ("priority");



CREATE INDEX "idx_decisions_status" ON "public"."decisions" USING "btree" ("status");



CREATE INDEX "idx_detention_facilities_location" ON "public"."youth_detention_facilities" USING "btree" ("latitude", "longitude");



CREATE INDEX "idx_detention_facilities_state" ON "public"."youth_detention_facilities" USING "btree" ("state");



CREATE INDEX "idx_detention_facilities_status" ON "public"."youth_detention_facilities" USING "btree" ("operational_status");



CREATE INDEX "idx_detention_facilities_type" ON "public"."youth_detention_facilities" USING "btree" ("facility_type");



CREATE INDEX "idx_discovered_links_priority" ON "public"."alma_discovered_links" USING "btree" ("priority" DESC);



CREATE INDEX "idx_discovered_links_status" ON "public"."alma_discovered_links" USING "btree" ("status");



CREATE INDEX "idx_discovered_pending" ON "public"."justice_matrix_discovered" USING "btree" ("status", "discovered_at") WHERE (("status")::"text" = 'pending'::"text");



CREATE INDEX "idx_discovered_source" ON "public"."justice_matrix_discovered" USING "btree" ("source_id");



CREATE INDEX "idx_discovered_status" ON "public"."justice_matrix_discovered" USING "btree" ("status");



CREATE INDEX "idx_discovered_type" ON "public"."justice_matrix_discovered" USING "btree" ("item_type");



CREATE INDEX "idx_donations_contact" ON "public"."donations" USING "btree" ("ghl_contact_id");



CREATE INDEX "idx_donations_date" ON "public"."donations" USING "btree" ("donation_date" DESC);



CREATE INDEX "idx_donations_project" ON "public"."donations" USING "btree" ("project");



CREATE INDEX "idx_ecosystem_health" ON "public"."ecosystem_projects" USING "btree" ("health_status");



CREATE INDEX "idx_ecosystem_slug" ON "public"."ecosystem_projects" USING "btree" ("slug");



CREATE INDEX "idx_ecosystem_tier" ON "public"."ecosystem_projects" USING "btree" ("tier");



CREATE INDEX "idx_edges_contact_a" ON "public"."contact_edges" USING "btree" ("contact_a_id", "relationship_type");



CREATE INDEX "idx_edges_contact_b" ON "public"."contact_edges" USING "btree" ("contact_b_id", "relationship_type");



CREATE INDEX "idx_efd_account_email" ON "public"."email_financial_documents" USING "btree" ("tenant_id", "account_email") WHERE ("is_subscription" = true);



CREATE INDEX "idx_efd_category" ON "public"."email_financial_documents" USING "btree" ("category");



CREATE INDEX "idx_efd_consolidation_status" ON "public"."email_financial_documents" USING "btree" ("tenant_id", "consolidation_status") WHERE ("is_subscription" = true);



CREATE INDEX "idx_efd_next_payment_date" ON "public"."email_financial_documents" USING "btree" ("tenant_id", "next_payment_date") WHERE (("is_subscription" = true) AND ("next_payment_date" IS NOT NULL));



CREATE INDEX "idx_efd_subscription_status" ON "public"."email_financial_documents" USING "btree" ("subscription_status") WHERE ("is_subscription" = true);



CREATE INDEX "idx_efd_tags" ON "public"."email_financial_documents" USING "gin" ("tags");



CREATE INDEX "idx_efd_usage_status" ON "public"."email_financial_documents" USING "btree" ("usage_status") WHERE (("is_subscription" = true) AND ("subscription_status" = 'active'::"text"));



CREATE INDEX "idx_elder_queue_assigned" ON "public"."elder_review_queue" USING "btree" ("assigned_to", "status");



CREATE INDEX "idx_elder_queue_priority" ON "public"."elder_review_queue" USING "btree" ("priority", "created_at");



CREATE INDEX "idx_elder_queue_sensitivity" ON "public"."elder_review_queue" USING "btree" ("sensitivity_level");



CREATE INDEX "idx_elder_queue_status" ON "public"."elder_review_queue" USING "btree" ("status");



CREATE INDEX "idx_email_fin_account" ON "public"."email_financial_documents" USING "btree" ("account_email");



CREATE INDEX "idx_email_fin_gmail_message" ON "public"."email_financial_documents" USING "btree" ("gmail_message_id");



CREATE INDEX "idx_email_fin_raw_extraction" ON "public"."email_financial_documents" USING "gin" ("raw_extraction");



CREATE INDEX "idx_email_fin_reconciliation" ON "public"."email_financial_documents" USING "btree" ("reconciliation_status");



CREATE INDEX "idx_email_fin_tenant_date" ON "public"."email_financial_documents" USING "btree" ("tenant_id", "transaction_date" DESC);



CREATE INDEX "idx_email_fin_vendor" ON "public"."email_financial_documents" USING "btree" ("vendor");



CREATE INDEX "idx_email_fin_xero" ON "public"."email_financial_documents" USING "btree" ("xero_transaction_id") WHERE ("xero_transaction_id" IS NOT NULL);



CREATE INDEX "idx_enrichment_reviews_created" ON "public"."enrichment_reviews" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_enrichment_reviews_project" ON "public"."enrichment_reviews" USING "btree" ("project_slug");



CREATE INDEX "idx_enrichment_reviews_status" ON "public"."enrichment_reviews" USING "btree" ("status");



CREATE INDEX "idx_enrichment_reviews_type" ON "public"."enrichment_reviews" USING "btree" ("enrichment_type");



CREATE INDEX "idx_entities_company" ON "public"."entities" USING "btree" ("company");



CREATE INDEX "idx_entities_email" ON "public"."entities" USING "btree" ("primary_email");



CREATE INDEX "idx_entities_name" ON "public"."entities" USING "btree" ("first_name", "last_name");



CREATE INDEX "idx_entity_mappings_entity" ON "public"."entity_mappings" USING "btree" ("entity_id");



CREATE INDEX "idx_entity_mappings_source" ON "public"."entity_mappings" USING "btree" ("source_system", "source_id");



CREATE INDEX "idx_entity_relationships_entity" ON "public"."entity_relationships" USING "btree" ("entity_type", "entity_id");



CREATE INDEX "idx_entity_relationships_strength" ON "public"."entity_relationships" USING "btree" ("strength_score" DESC);



CREATE INDEX "idx_event_registrations_email" ON "public"."event_registrations" USING "btree" ("email");



CREATE INDEX "idx_event_registrations_event_id" ON "public"."event_registrations" USING "btree" ("event_id");



CREATE INDEX "idx_events_is_public" ON "public"."events" USING "btree" ("is_public") WHERE ("is_public" = true);



CREATE INDEX "idx_events_node_id" ON "public"."events" USING "btree" ("node_id");



CREATE INDEX "idx_events_start_date" ON "public"."events" USING "btree" ("start_date");



CREATE INDEX "idx_exa_company_name" ON "public"."exa_company_intelligence" USING "btree" ("company_name");



CREATE INDEX "idx_exa_linkedin_person" ON "public"."exa_linkedin_profiles" USING "btree" ("person_id");



CREATE INDEX "idx_exa_media_fulltext" ON "public"."exa_media_mentions" USING "gin" ("to_tsvector"('"english"'::"regconfig", (("title" || ' '::"text") || COALESCE("excerpt", ''::"text"))));



CREATE INDEX "idx_exa_media_person_date" ON "public"."exa_media_mentions" USING "btree" ("person_id", "published_date" DESC);



CREATE INDEX "idx_exa_media_relevance" ON "public"."exa_media_mentions" USING "btree" ("relevance_score" DESC, "published_date" DESC);



CREATE INDEX "idx_exa_queue_campaign" ON "public"."exa_enrichment_queue" USING "btree" ("campaign_type", "status", "priority" DESC);



CREATE INDEX "idx_exa_queue_pending" ON "public"."exa_enrichment_queue" USING "btree" ("priority" DESC, "queued_at") WHERE ("status" = 'pending'::"text");



CREATE INDEX "idx_executions_agent" ON "public"."autonomous_executions" USING "btree" ("agent_id", "created_at");



CREATE INDEX "idx_executions_flagged" ON "public"."autonomous_executions" USING "btree" ("flagged_for_review") WHERE ("flagged_for_review" = true);



CREATE INDEX "idx_external_cache_expires" ON "public"."alma_external_source_cache" USING "btree" ("expires_at");



CREATE INDEX "idx_external_cache_url" ON "public"."alma_external_source_cache" USING "btree" ("url");



CREATE INDEX "idx_extraction_queue_confidence" ON "public"."knowledge_extraction_queue" USING "btree" ("confidence_score" DESC);



CREATE UNIQUE INDEX "idx_extraction_queue_gmail_unique" ON "public"."knowledge_extraction_queue" USING "btree" ("source_type", "source_id") WHERE ("source_type" = 'gmail'::"text");



CREATE INDEX "idx_extraction_queue_priority" ON "public"."knowledge_extraction_queue" USING "btree" ("priority" DESC, "created_at" DESC);



CREATE INDEX "idx_extraction_queue_source" ON "public"."knowledge_extraction_queue" USING "btree" ("source_type", "source_id");



CREATE INDEX "idx_extraction_queue_status" ON "public"."knowledge_extraction_queue" USING "btree" ("status");



CREATE INDEX "idx_extraction_queue_thread" ON "public"."knowledge_extraction_queue" USING "btree" ("thread_id");



CREATE UNIQUE INDEX "idx_extraction_queue_unique_source" ON "public"."knowledge_extraction_queue" USING "btree" ("source_type", "source_id") WHERE ("status" <> 'rejected'::"text");



CREATE INDEX "idx_facility_partnerships_facility" ON "public"."facility_partnerships" USING "btree" ("facility_id");



CREATE INDEX "idx_facility_partnerships_org" ON "public"."facility_partnerships" USING "btree" ("organization_id") WHERE ("organization_id" IS NOT NULL);



CREATE INDEX "idx_facility_partnerships_program" ON "public"."facility_partnerships" USING "btree" ("program_id") WHERE ("program_id" IS NOT NULL);



CREATE INDEX "idx_facility_partnerships_service" ON "public"."facility_partnerships" USING "btree" ("service_id") WHERE ("service_id" IS NOT NULL);



CREATE INDEX "idx_facility_partnerships_type" ON "public"."facility_partnerships" USING "btree" ("partnership_type");



CREATE INDEX "idx_facility_stats_facility" ON "public"."facility_statistics" USING "btree" ("facility_id", "period_start" DESC);



CREATE INDEX "idx_feedback_action" ON "public"."suggestion_feedback" USING "btree" ("action");



CREATE INDEX "idx_feedback_suggestion" ON "public"."suggestion_feedback" USING "btree" ("suggestion_id");



CREATE INDEX "idx_funding_applications_opportunity" ON "public"."alma_funding_applications" USING "btree" ("opportunity_id");



CREATE INDEX "idx_funding_applications_organization" ON "public"."alma_funding_applications" USING "btree" ("organization_id");



CREATE INDEX "idx_funding_applications_status" ON "public"."alma_funding_applications" USING "btree" ("status");



CREATE INDEX "idx_funding_jurisdiction" ON "public"."alma_funding_data" USING "btree" ("jurisdiction");



CREATE INDEX "idx_funding_opportunities_deadline" ON "public"."alma_funding_opportunities" USING "btree" ("deadline");



CREATE INDEX "idx_funding_opportunities_focus_areas" ON "public"."alma_funding_opportunities" USING "gin" ("focus_areas");



CREATE INDEX "idx_funding_opportunities_fts" ON "public"."alma_funding_opportunities" USING "gin" ("to_tsvector"('"english"'::"regconfig", ((((COALESCE("name", ''::"text") || ' '::"text") || COALESCE("description", ''::"text")) || ' '::"text") || COALESCE("funder_name", ''::"text"))));



CREATE INDEX "idx_funding_opportunities_funder" ON "public"."alma_funding_opportunities" USING "btree" ("funder_name");



CREATE INDEX "idx_funding_opportunities_jurisdictions" ON "public"."alma_funding_opportunities" USING "gin" ("jurisdictions");



CREATE INDEX "idx_funding_opportunities_source_id" ON "public"."alma_funding_opportunities" USING "btree" ("scrape_source", "source_id");



CREATE INDEX "idx_funding_opportunities_source_type" ON "public"."alma_funding_opportunities" USING "btree" ("source_type");



CREATE INDEX "idx_funding_opportunities_status" ON "public"."alma_funding_opportunities" USING "btree" ("status");



CREATE INDEX "idx_funding_type" ON "public"."alma_funding_data" USING "btree" ("source_type");



CREATE INDEX "idx_funding_year" ON "public"."alma_funding_data" USING "btree" ("report_year");



CREATE INDEX "idx_ghl_contact" ON "public"."ghl_engagement_metrics" USING "btree" ("contact_id");



CREATE INDEX "idx_ghl_contacts_el_id" ON "public"."ghl_contacts" USING "btree" ("empathy_ledger_id") WHERE ("empathy_ledger_id" IS NOT NULL);



CREATE INDEX "idx_ghl_contacts_elder" ON "public"."ghl_contacts" USING "btree" ("is_elder") WHERE ("is_elder" = true);



CREATE INDEX "idx_ghl_contacts_email" ON "public"."ghl_contacts" USING "btree" ("email");



CREATE INDEX "idx_ghl_contacts_engagement" ON "public"."ghl_contacts" USING "btree" ("engagement_status");



CREATE INDEX "idx_ghl_contacts_ghl_id" ON "public"."ghl_contacts" USING "btree" ("ghl_id");



CREATE INDEX "idx_ghl_contacts_projects" ON "public"."ghl_contacts" USING "gin" ("projects");



CREATE INDEX "idx_ghl_contacts_storyteller" ON "public"."ghl_contacts" USING "btree" ("is_storyteller") WHERE ("is_storyteller" = true);



CREATE INDEX "idx_ghl_contacts_sync_status" ON "public"."ghl_contacts" USING "btree" ("sync_status");



CREATE INDEX "idx_ghl_contacts_tags" ON "public"."ghl_contacts" USING "gin" ("tags");



CREATE INDEX "idx_ghl_ghl_id" ON "public"."ghl_engagement_metrics" USING "btree" ("ghl_contact_id");



CREATE INDEX "idx_ghl_obsolescence" ON "public"."ghl_engagement_metrics" USING "btree" ("obsolescence_achieved");



CREATE INDEX "idx_ghl_opportunities_contact" ON "public"."ghl_opportunities" USING "btree" ("ghl_contact_id");



CREATE INDEX "idx_ghl_opportunities_pipeline" ON "public"."ghl_opportunities" USING "btree" ("ghl_pipeline_id");



CREATE INDEX "idx_ghl_opportunities_project_code" ON "public"."ghl_opportunities" USING "btree" ("project_code");



CREATE INDEX "idx_ghl_opportunities_status" ON "public"."ghl_opportunities" USING "btree" ("status");



CREATE INDEX "idx_ghl_person" ON "public"."ghl_engagement_metrics" USING "btree" ("person_id");



CREATE INDEX "idx_ghl_pipeline" ON "public"."ghl_engagement_metrics" USING "btree" ("pipeline_type");



CREATE INDEX "idx_ghl_project_match" ON "public"."ghl_engagement_metrics" USING "btree" ("project_match_id") WHERE ("project_match_id" IS NOT NULL);



CREATE INDEX "idx_ghl_stage" ON "public"."ghl_engagement_metrics" USING "btree" ("current_stage");



CREATE INDEX "idx_ghl_sync_log_created" ON "public"."ghl_sync_log" USING "btree" ("started_at" DESC);



CREATE INDEX "idx_gmail_contacts_domain" ON "public"."gmail_contacts" USING "btree" ("domain");



CREATE INDEX "idx_gmail_contacts_email" ON "public"."gmail_contacts" USING "btree" ("email");



CREATE INDEX "idx_gmail_contacts_last_interaction" ON "public"."gmail_contacts" USING "btree" ("last_interaction" DESC);



CREATE INDEX "idx_gmail_messages_date" ON "public"."gmail_messages" USING "btree" ("sent_date" DESC);



CREATE INDEX "idx_gmail_messages_from" ON "public"."gmail_messages" USING "btree" ("from_email");



CREATE INDEX "idx_gmail_messages_keywords" ON "public"."gmail_messages" USING "gin" ("keywords");



CREATE INDEX "idx_gmail_messages_labels" ON "public"."gmail_messages" USING "gin" ("labels");



CREATE INDEX "idx_gmail_messages_thread" ON "public"."gmail_messages" USING "btree" ("thread_id");



CREATE INDEX "idx_gmail_messages_user" ON "public"."gmail_messages" USING "btree" ("user_email");



CREATE INDEX "idx_gmail_sync_account" ON "public"."gmail_sync_state" USING "btree" ("account_id");



CREATE INDEX "idx_gmail_sync_status" ON "public"."gmail_sync_state" USING "btree" ("status", "next_sync_at");



CREATE INDEX "idx_gmail_tokens_email" ON "public"."gmail_auth_tokens" USING "btree" ("user_email");



CREATE INDEX "idx_goal_metrics_goal_id" ON "public"."goal_metrics" USING "btree" ("goal_id");



CREATE INDEX "idx_goal_updates_created_at" ON "public"."goal_updates" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_goal_updates_goal_id" ON "public"."goal_updates" USING "btree" ("goal_id");



CREATE INDEX "idx_goal_updates_source" ON "public"."goal_updates" USING "btree" ("source");



CREATE INDEX "idx_goals_2026_lane" ON "public"."goals_2026" USING "btree" ("lane");



CREATE INDEX "idx_goals_2026_status" ON "public"."goals_2026" USING "btree" ("status");



CREATE INDEX "idx_goals_2026_type" ON "public"."goals_2026" USING "btree" ("type");



CREATE INDEX "idx_grant_opportunities_application_status" ON "public"."grant_opportunities" USING "btree" ("application_status");



CREATE INDEX "idx_grant_opportunities_deadline" ON "public"."grant_opportunities" USING "btree" ("deadline");



CREATE INDEX "idx_grant_opportunities_relevance_score" ON "public"."grant_opportunities" USING "btree" ("relevance_score" DESC);



CREATE INDEX "idx_grant_tracking_project_code" ON "public"."grant_financial_tracking" USING "btree" ("project_code");



CREATE INDEX "idx_grant_tracking_status" ON "public"."grant_financial_tracking" USING "btree" ("status");



CREATE INDEX "idx_harvest_businesses_category" ON "public"."harvest_businesses" USING "btree" ("category");



CREATE INDEX "idx_harvest_businesses_status" ON "public"."harvest_businesses" USING "btree" ("status");



CREATE INDEX "idx_harvest_events_date" ON "public"."harvest_events" USING "btree" ("date");



CREATE INDEX "idx_harvest_events_status" ON "public"."harvest_events" USING "btree" ("status");



CREATE INDEX "idx_health_alerts_created_at" ON "public"."health_alerts" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_health_alerts_resolved" ON "public"."health_alerts" USING "btree" ("resolved");



CREATE INDEX "idx_health_alerts_site_id" ON "public"."health_alerts" USING "btree" ("site_id");



CREATE INDEX "idx_historical_inquiries_jurisdiction" ON "public"."historical_inquiries" USING "btree" ("jurisdiction");



CREATE INDEX "idx_historical_inquiries_year" ON "public"."historical_inquiries" USING "btree" ("year_published");



CREATE INDEX "idx_identifier_entity" ON "public"."entity_identifiers" USING "btree" ("entity_id");



CREATE INDEX "idx_identifier_source" ON "public"."entity_identifiers" USING "btree" ("source", "source_record_id");



CREATE INDEX "idx_identifier_type_value" ON "public"."entity_identifiers" USING "btree" ("identifier_type", "normalized_value");



CREATE UNIQUE INDEX "idx_ignored_patterns_unique" ON "public"."ignored_email_patterns" USING "btree" ("pattern_type", "pattern");



CREATE INDEX "idx_impact_evidence_storyteller" ON "public"."impact_evidence" USING "btree" ("storyteller_id");



CREATE INDEX "idx_impact_stories_storyteller" ON "public"."impact_stories" USING "btree" ("storyteller_id");



CREATE INDEX "idx_impact_stories_visibility" ON "public"."impact_stories" USING "btree" ("visibility_level");



CREATE INDEX "idx_intelligence_scores_composite" ON "public"."contact_intelligence_scores" USING "btree" ("composite_score" DESC);



CREATE INDEX "idx_interactions_contact_date" ON "public"."interactions" USING "btree" ("contact_id", "interaction_date" DESC);



CREATE INDEX "idx_interactions_type_date" ON "public"."interactions" USING "btree" ("interaction_type", "interaction_date" DESC);



CREATE INDEX "idx_international_programs_country" ON "public"."international_programs" USING "btree" ("country");



CREATE INDEX "idx_international_programs_region" ON "public"."international_programs" USING "btree" ("region");



CREATE INDEX "idx_international_programs_slug" ON "public"."international_programs" USING "btree" ("slug");



CREATE INDEX "idx_international_programs_status" ON "public"."international_programs" USING "btree" ("status");



CREATE INDEX "idx_international_programs_type" ON "public"."international_programs" USING "gin" ("program_type");



CREATE INDEX "idx_invitations_program" ON "public"."international_invitations" USING "btree" ("program_id");



CREATE INDEX "idx_invites_contact_date" ON "public"."contact_invites" USING "btree" ("contact_id", "invited_at" DESC);



CREATE INDEX "idx_invites_opportunity_status" ON "public"."contact_invites" USING "btree" ("opportunity_id", "status");



CREATE INDEX "idx_knowledge_chunks_created" ON "public"."knowledge_chunks" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_knowledge_chunks_embedding" ON "public"."knowledge_chunks" USING "ivfflat" ("embedding" "public"."vector_cosine_ops") WITH ("lists"='100');



CREATE INDEX "idx_knowledge_chunks_hash" ON "public"."knowledge_chunks" USING "btree" ("content_hash");



CREATE INDEX "idx_knowledge_chunks_project" ON "public"."knowledge_chunks" USING "btree" ("project_id");



CREATE INDEX "idx_knowledge_chunks_source" ON "public"."knowledge_chunks" USING "btree" ("source_type", "project_id");



CREATE INDEX "idx_knowledge_chunks_topics" ON "public"."knowledge_chunks" USING "gin" ("topics");



CREATE INDEX "idx_knowledge_sources_authority" ON "public"."knowledge_sources" USING "btree" ("authority_level");



CREATE INDEX "idx_knowledge_sources_knowledge_id" ON "public"."knowledge_sources" USING "btree" ("knowledge_id");



CREATE INDEX "idx_knowledge_sources_projects" ON "public"."knowledge_sources" USING "gin" ("projects");



CREATE INDEX "idx_knowledge_sources_type" ON "public"."knowledge_sources" USING "btree" ("source_type");



CREATE INDEX "idx_knowledge_versions_active" ON "public"."knowledge_versions" USING "btree" ("active_from", "active_until");



CREATE INDEX "idx_knowledge_versions_id" ON "public"."knowledge_versions" USING "btree" ("knowledge_id");



CREATE INDEX "idx_knowledge_versions_projects" ON "public"."knowledge_versions" USING "gin" ("projects");



CREATE INDEX "idx_knowledge_versions_status" ON "public"."knowledge_versions" USING "btree" ("status");



CREATE INDEX "idx_learned_thresholds_segment" ON "public"."learned_thresholds" USING "btree" ("segment");



CREATE INDEX "idx_learned_thresholds_type" ON "public"."learned_thresholds" USING "btree" ("threshold_type");



CREATE INDEX "idx_linkedin_contacts_company" ON "public"."linkedin_contacts" USING "btree" ("current_company");



CREATE INDEX "idx_linkedin_contacts_confidence" ON "public"."linkedin_contacts" USING "btree" ("exa_confidence_score");



CREATE INDEX "idx_linkedin_contacts_email" ON "public"."linkedin_contacts" USING "btree" ("email_address");



CREATE INDEX "idx_linkedin_contacts_exa_enriched" ON "public"."linkedin_contacts" USING "btree" ("exa_enriched");



CREATE INDEX "idx_linkedin_contacts_person" ON "public"."linkedin_contacts" USING "btree" ("person_id");



CREATE INDEX "idx_linkedin_contacts_score" ON "public"."linkedin_contacts" USING "btree" ("relationship_score" DESC);



CREATE INDEX "idx_linkedin_imports_owner_type" ON "public"."linkedin_imports" USING "btree" ("owner", "type");



CREATE INDEX "idx_locations_country" ON "public"."locations" USING "btree" ("country");



CREATE INDEX "idx_locations_name" ON "public"."locations" USING "btree" ("name");



CREATE INDEX "idx_media_collections_featured" ON "public"."media_collections" USING "btree" ("featured", "public_visible");



CREATE INDEX "idx_media_collections_project" ON "public"."media_collections" USING "btree" ("project_id");



CREATE INDEX "idx_media_collections_type" ON "public"."media_collections" USING "btree" ("type");



CREATE INDEX "idx_media_items_ai_tags" ON "public"."media_items" USING "gin" ("ai_tags");



CREATE INDEX "idx_media_items_consent" ON "public"."media_items" USING "btree" ("consent_verified", "community_approved");



CREATE INDEX "idx_media_items_created" ON "public"."media_items" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_media_items_created_at" ON "public"."media_items" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_media_items_file_type" ON "public"."media_items" USING "btree" ("file_type");



CREATE INDEX "idx_media_items_impact_themes" ON "public"."media_items" USING "gin" ("impact_themes");



CREATE INDEX "idx_media_items_is_hero" ON "public"."media_items" USING "btree" ("is_hero_image") WHERE ("is_hero_image" = true);



CREATE INDEX "idx_media_items_manual_tags" ON "public"."media_items" USING "gin" ("manual_tags");



CREATE INDEX "idx_media_items_project_ids" ON "public"."media_items" USING "gin" ("project_ids");



CREATE INDEX "idx_media_items_project_slugs" ON "public"."media_items" USING "gin" ("project_slugs");



CREATE INDEX "idx_media_items_search" ON "public"."media_items" USING "gin" ("to_tsvector"('"english"'::"regconfig", ((((COALESCE("title", ''::"text") || ' '::"text") || COALESCE("description", ''::"text")) || ' '::"text") || COALESCE("caption", ''::"text"))));



CREATE INDEX "idx_media_items_source" ON "public"."media_items" USING "btree" ("source");



CREATE INDEX "idx_media_items_story_ids" ON "public"."media_items" USING "gin" ("story_ids");



CREATE INDEX "idx_media_library_created_at" ON "public"."media_library" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_media_library_file_name" ON "public"."media_library" USING "btree" ("file_name");



CREATE INDEX "idx_media_library_folder" ON "public"."media_library" USING "btree" ("folder");



CREATE INDEX "idx_media_library_search" ON "public"."media_library" USING "gin" ("to_tsvector"('"english"'::"regconfig", ((((COALESCE("file_name", ''::"text") || ' '::"text") || COALESCE("alt_text", ''::"text")) || ' '::"text") || COALESCE("caption", ''::"text"))));



CREATE INDEX "idx_media_library_tags" ON "public"."media_library" USING "gin" ("tags");



CREATE INDEX "idx_media_library_uploaded_by" ON "public"."media_library" USING "btree" ("uploaded_by");



CREATE INDEX "idx_media_story" ON "public"."media_files" USING "btree" ("story_id");



CREATE INDEX "idx_media_storyteller" ON "public"."media_files" USING "btree" ("storyteller_id");



CREATE INDEX "idx_media_type" ON "public"."media_files" USING "btree" ("media_type");



CREATE INDEX "idx_media_usage_media" ON "public"."media_usage" USING "btree" ("media_id");



CREATE INDEX "idx_media_usage_type" ON "public"."media_usage" USING "btree" ("used_in_type", "used_in_id");



CREATE INDEX "idx_merge_log_merged" ON "public"."entity_merge_log" USING "btree" ("merged_entity_id");



CREATE INDEX "idx_merge_log_surviving" ON "public"."entity_merge_log" USING "btree" ("surviving_entity_id");



CREATE INDEX "idx_migration_rate_limits_tenant_date" ON "public"."migration_rate_limits" USING "btree" ("tenant_id", "date");



CREATE INDEX "idx_newsletter_email" ON "public"."newsletter_subscribers" USING "btree" ("email");



CREATE INDEX "idx_newsletter_status" ON "public"."newsletter_subscribers" USING "btree" ("status");



CREATE INDEX "idx_notifications_priority" ON "public"."wiki_notifications" USING "btree" ("priority", "created_at" DESC);



CREATE INDEX "idx_notifications_type" ON "public"."wiki_notifications" USING "btree" ("type");



CREATE INDEX "idx_notifications_unread" ON "public"."wiki_notifications" USING "btree" ("is_read", "created_at" DESC);



CREATE INDEX "idx_notifications_wiki_page" ON "public"."wiki_notifications" USING "btree" ("wiki_page_id");



CREATE INDEX "idx_notion_opportunities_data_gin" ON "public"."notion_opportunities" USING "gin" ("data");



CREATE INDEX "idx_notion_opportunities_last_synced" ON "public"."notion_opportunities" USING "btree" ("last_synced" DESC);



CREATE INDEX "idx_notion_opportunities_notion_id" ON "public"."notion_opportunities" USING "btree" ("notion_id");



CREATE INDEX "idx_notion_org_people_org" ON "public"."notion_organization_people" USING "btree" ("notion_organizations_id");



CREATE INDEX "idx_notion_org_people_person" ON "public"."notion_organization_people" USING "btree" ("notion_people_id");



CREATE INDEX "idx_notion_organizations_data_gin" ON "public"."notion_organizations" USING "gin" ("data");



CREATE INDEX "idx_notion_organizations_last_synced" ON "public"."notion_organizations" USING "btree" ("last_synced" DESC);



CREATE INDEX "idx_notion_organizations_notion_id" ON "public"."notion_organizations" USING "btree" ("notion_id");



CREATE INDEX "idx_notion_people_notion_id" ON "public"."notion_people" USING "btree" ("notion_id");



CREATE INDEX "idx_notion_project_orgs_org" ON "public"."notion_project_organizations" USING "btree" ("notion_organizations_id");



CREATE INDEX "idx_notion_project_orgs_project" ON "public"."notion_project_organizations" USING "btree" ("notion_project_id");



CREATE INDEX "idx_notion_project_people_person" ON "public"."notion_project_people" USING "btree" ("notion_people_id");



CREATE INDEX "idx_notion_project_people_project" ON "public"."notion_project_people" USING "btree" ("notion_project_id");



CREATE INDEX "idx_notion_projects_data_gin" ON "public"."notion_projects" USING "gin" ("data");



CREATE INDEX "idx_notion_projects_last_synced" ON "public"."notion_projects" USING "btree" ("last_synced" DESC);



CREATE INDEX "idx_notion_projects_notion_id" ON "public"."notion_projects" USING "btree" ("notion_id");



CREATE INDEX "idx_notion_projects_source" ON "public"."notion_projects_cache" USING "btree" ("project_source");



CREATE INDEX "idx_notion_projects_status" ON "public"."notion_projects_cache" USING "btree" ("status");



CREATE INDEX "idx_notion_projects_tags" ON "public"."notion_projects_cache" USING "gin" ("tags");



CREATE INDEX "idx_opportunities_status_deadline" ON "public"."opportunities" USING "btree" ("status", "deadline") WHERE ("status" = 'active'::"text");



CREATE INDEX "idx_org_connections_organization" ON "public"."organization_connections" USING "btree" ("organization_id");



CREATE INDEX "idx_org_connections_storyteller" ON "public"."organization_connections" USING "btree" ("storyteller_id");



CREATE INDEX "idx_org_connections_type" ON "public"."organization_connections" USING "btree" ("relationship_type");



CREATE INDEX "idx_org_members_organization" ON "public"."organization_members" USING "btree" ("organization_id");



CREATE INDEX "idx_org_members_role" ON "public"."organization_members" USING "btree" ("role");



CREATE INDEX "idx_org_members_user" ON "public"."organization_members" USING "btree" ("user_id");



CREATE INDEX "idx_organization_enrichment_confidence" ON "public"."organization_enrichment" USING "btree" ("confidence_score");



CREATE INDEX "idx_organization_enrichment_org_id" ON "public"."organization_enrichment" USING "btree" ("organization_id");



CREATE INDEX "idx_organization_enrichment_type" ON "public"."organization_enrichment" USING "btree" ("enrichment_type");



CREATE INDEX "idx_organization_enrichment_validation" ON "public"."organization_enrichment" USING "btree" ("validation_status");



CREATE INDEX "idx_organizations_name" ON "public"."organizations" USING "btree" ("name");



CREATE INDEX "idx_organizations_profiles_current" ON "public"."organizations_profiles" USING "btree" ("is_current") WHERE ("is_current" = true);



CREATE INDEX "idx_organizations_profiles_featured" ON "public"."organizations_profiles" USING "btree" ("is_featured") WHERE ("is_featured" = true);



CREATE INDEX "idx_organizations_profiles_org_id" ON "public"."organizations_profiles" USING "btree" ("organization_id");



CREATE INDEX "idx_organizations_profiles_profile_id" ON "public"."organizations_profiles" USING "btree" ("public_profile_id");



CREATE INDEX "idx_organizations_type" ON "public"."organizations" USING "btree" ("type");



CREATE INDEX "idx_outreach_strategies_contact_id" ON "public"."outreach_strategies" USING "btree" ("contact_id");



CREATE INDEX "idx_outreach_strategies_success_probability" ON "public"."outreach_strategies" USING "btree" ("success_probability" DESC);



CREATE INDEX "idx_outreach_tasks_contact" ON "public"."outreach_tasks" USING "btree" ("contact_id");



CREATE INDEX "idx_outreach_tasks_project" ON "public"."outreach_tasks" USING "btree" ("project_id");



CREATE INDEX "idx_outreach_tasks_status" ON "public"."outreach_tasks" USING "btree" ("status");



CREATE INDEX "idx_pages_slug" ON "public"."pages" USING "btree" ("slug");



CREATE INDEX "idx_partner_contacts_org" ON "public"."partner_contacts" USING "btree" ("organization_id");



CREATE INDEX "idx_partner_goals_org" ON "public"."partner_goals" USING "btree" ("organization_id");



CREATE INDEX "idx_partner_impact_org" ON "public"."partner_impact_metrics" USING "btree" ("organization_id");



CREATE INDEX "idx_partner_photos_featured" ON "public"."partner_photos" USING "btree" ("is_featured") WHERE ("is_featured" = true);



CREATE INDEX "idx_partner_photos_org" ON "public"."partner_photos" USING "btree" ("organization_id");



CREATE INDEX "idx_partner_sites_org" ON "public"."partner_site_locations" USING "btree" ("organization_id");



CREATE INDEX "idx_partner_stories_org" ON "public"."partner_stories" USING "btree" ("organization_id");



CREATE INDEX "idx_partner_storytellers_org" ON "public"."partner_storytellers" USING "btree" ("organization_id");



CREATE INDEX "idx_partner_videos_featured" ON "public"."partner_videos" USING "btree" ("is_featured") WHERE ("is_featured" = true);



CREATE INDEX "idx_partner_videos_org" ON "public"."partner_videos" USING "btree" ("organization_id");



CREATE INDEX "idx_partner_videos_placement" ON "public"."partner_videos" USING "btree" ("video_placement");



CREATE INDEX "idx_pending_contacts_email" ON "public"."pending_contacts" USING "btree" ("email");



CREATE INDEX "idx_pending_contacts_importance" ON "public"."pending_contacts" USING "btree" ("importance_score" DESC);



CREATE INDEX "idx_pending_contacts_status" ON "public"."pending_contacts" USING "btree" ("status");



CREATE INDEX "idx_person_exa_refresh_needed" ON "public"."person_identity_map" USING "btree" ("exa_refresh_needed", "exa_last_refresh_at") WHERE ("exa_refresh_needed" = true);



CREATE INDEX "idx_person_exa_unenriched" ON "public"."person_identity_map" USING "btree" ("exa_enriched", "engagement_priority") WHERE ("exa_enriched" = false);



CREATE INDEX "idx_person_identity_email" ON "public"."person_identity_map" USING "btree" ("email");



CREATE INDEX "idx_person_identity_engagement_priority" ON "public"."person_identity_map" USING "btree" ("engagement_priority");



CREATE INDEX "idx_person_identity_ghl" ON "public"."person_identity_map" USING "btree" ("ghl_contact_id");



CREATE INDEX "idx_person_identity_linkedin" ON "public"."person_identity_map" USING "btree" ("linkedin_contact_id");



CREATE INDEX "idx_person_identity_map_email_lookup" ON "public"."person_identity_map" USING "btree" ("email") WHERE ("email" IS NOT NULL);



CREATE INDEX "idx_photo_albums_public" ON "public"."photo_albums" USING "btree" ("is_public") WHERE ("is_public" = true);



CREATE INDEX "idx_photo_albums_slug" ON "public"."photo_albums" USING "btree" ("slug");



CREATE INDEX "idx_photo_albums_storyteller" ON "public"."photo_albums" USING "btree" ("storyteller_id");



CREATE INDEX "idx_photo_tags_photo_id" ON "public"."photo_storyteller_tags" USING "btree" ("photo_id");



CREATE INDEX "idx_photo_tags_storyteller_id" ON "public"."photo_storyteller_tags" USING "btree" ("storyteller_id");



CREATE INDEX "idx_photos_filename" ON "public"."photos" USING "btree" ("filename");



CREATE INDEX "idx_photos_upload_date" ON "public"."photos" USING "btree" ("upload_date" DESC);



CREATE INDEX "idx_pim_data_quality" ON "public"."person_identity_map" USING "btree" ("data_quality_score") WHERE ("data_quality_score" < 50);



CREATE INDEX "idx_pim_needs_cleanup" ON "public"."person_identity_map" USING "btree" ("needs_cleanup") WHERE ("needs_cleanup" = true);



CREATE INDEX "idx_pk_action_required" ON "public"."project_knowledge" USING "btree" ("action_required") WHERE ("action_required" = true);



CREATE INDEX "idx_pk_follow_up" ON "public"."project_knowledge" USING "btree" ("follow_up_date") WHERE ("follow_up_date" IS NOT NULL);



CREATE INDEX "idx_pk_importance" ON "public"."project_knowledge" USING "btree" ("importance");



CREATE INDEX "idx_pk_participants" ON "public"."project_knowledge" USING "gin" ("participants");



CREATE INDEX "idx_pk_project" ON "public"."project_knowledge" USING "btree" ("project_code");



CREATE INDEX "idx_pk_recorded_at" ON "public"."project_knowledge" USING "btree" ("recorded_at" DESC);



CREATE INDEX "idx_pk_source" ON "public"."project_knowledge" USING "btree" ("source_type", "source_ref");



CREATE INDEX "idx_pk_topics" ON "public"."project_knowledge" USING "gin" ("topics");



CREATE INDEX "idx_pk_type" ON "public"."project_knowledge" USING "btree" ("knowledge_type");



CREATE INDEX "idx_pk_voice_note" ON "public"."project_knowledge" USING "btree" ("voice_note_id") WHERE ("voice_note_id" IS NOT NULL);



CREATE INDEX "idx_platform_collection_media_auto" ON "public"."platform_collection_media" USING "btree" ("auto_added", "auto_score" DESC);



CREATE INDEX "idx_platform_collection_media_sort" ON "public"."platform_collection_media" USING "btree" ("collection_id", "sort_order");



CREATE INDEX "idx_platform_collections_org_featured" ON "public"."platform_media_collections" USING "btree" ("platform_organization_id", "featured", "public_visible");



CREATE INDEX "idx_platform_collections_org_type" ON "public"."platform_media_collections" USING "btree" ("platform_organization_id", "type");



CREATE INDEX "idx_platform_media_items_ai_tags" ON "public"."platform_media_items" USING "gin" ("ai_tags");



CREATE INDEX "idx_platform_media_items_org_category" ON "public"."platform_media_items" USING "btree" ("platform_organization_id", "content_category");



CREATE INDEX "idx_platform_media_items_org_created" ON "public"."platform_media_items" USING "btree" ("platform_organization_id", "created_at" DESC);



CREATE INDEX "idx_platform_media_items_org_type" ON "public"."platform_media_items" USING "btree" ("platform_organization_id", "file_type");



CREATE INDEX "idx_platform_media_items_projects" ON "public"."platform_media_items" USING "gin" ("project_ids");



CREATE INDEX "idx_platform_media_items_storage_path" ON "public"."platform_media_items" USING "btree" ("storage_path");



CREATE INDEX "idx_platform_media_items_tags" ON "public"."platform_media_items" USING "gin" ("manual_tags");



CREATE INDEX "idx_platform_media_items_themes" ON "public"."platform_media_items" USING "gin" ("impact_themes");



CREATE INDEX "idx_platform_organizations_last_activity" ON "public"."platform_organizations" USING "btree" ("last_activity_at" DESC);



CREATE INDEX "idx_platform_organizations_slug" ON "public"."platform_organizations" USING "btree" ("slug");



CREATE INDEX "idx_platform_organizations_storage_prefix" ON "public"."platform_organizations" USING "btree" ("storage_prefix");



CREATE INDEX "idx_platform_usage_media_count" ON "public"."platform_media_usage" USING "btree" ("media_id", "view_count" DESC);



CREATE INDEX "idx_platform_usage_org_type" ON "public"."platform_media_usage" USING "btree" ("platform_organization_id", "used_in_type");



CREATE INDEX "idx_pmpp_method" ON "public"."pmpp_knowledge" USING "btree" ("parent_method_id");



CREATE INDEX "idx_pmpp_practice" ON "public"."pmpp_knowledge" USING "btree" ("parent_practice_id");



CREATE INDEX "idx_pmpp_principle" ON "public"."pmpp_knowledge" USING "btree" ("parent_principle_id");



CREATE INDEX "idx_pmpp_projects" ON "public"."pmpp_knowledge" USING "gin" ("projects");



CREATE INDEX "idx_pmpp_review" ON "public"."pmpp_knowledge" USING "btree" ("last_reviewed_at");



CREATE INDEX "idx_pmpp_status" ON "public"."pmpp_knowledge" USING "btree" ("status");



CREATE INDEX "idx_pmpp_type" ON "public"."pmpp_knowledge" USING "btree" ("type");



CREATE INDEX "idx_potential_matches_score" ON "public"."entity_potential_matches" USING "btree" ("match_score" DESC);



CREATE INDEX "idx_potential_matches_status" ON "public"."entity_potential_matches" USING "btree" ("status");



CREATE INDEX "idx_priv_audit_tenant_time" ON "public"."privacy_audit_log" USING "btree" ("tenant_id", "occurred_at" DESC);



CREATE INDEX "idx_priv_dsr_tenant_status" ON "public"."privacy_dsr_requests" USING "btree" ("tenant_id", "status");



CREATE INDEX "idx_profile_appearances_el_profile" ON "public"."profile_appearances" USING "btree" ("empathy_ledger_profile_id");



CREATE INDEX "idx_profile_appearances_featured" ON "public"."profile_appearances" USING "btree" ("featured") WHERE ("featured" = true);



CREATE INDEX "idx_profile_appearances_public_profile" ON "public"."profile_appearances" USING "btree" ("public_profile_id");



CREATE INDEX "idx_profile_appearances_target" ON "public"."profile_appearances" USING "btree" ("appears_on_type", "appears_on_id");



CREATE INDEX "idx_profiles_current_organization" ON "public"."public_profiles" USING "btree" ("current_organization") WHERE ("current_organization" IS NOT NULL);



CREATE INDEX "idx_profiles_email" ON "public"."profiles" USING "btree" ("email");



CREATE INDEX "idx_profiles_location" ON "public"."public_profiles" USING "btree" ("location") WHERE ("location" IS NOT NULL);



CREATE INDEX "idx_profiles_organization" ON "public"."profiles" USING "btree" ("primary_organization_id");



CREATE INDEX "idx_profiles_role" ON "public"."profiles" USING "btree" ("role");



CREATE INDEX "idx_program_outcomes_program" ON "public"."program_outcomes" USING "btree" ("program_id");



CREATE INDEX "idx_program_visits_program" ON "public"."program_visits" USING "btree" ("program_id");



CREATE INDEX "idx_project_activity_last_synced" ON "public"."project_activity_summary" USING "btree" ("last_synced");



CREATE INDEX "idx_project_contact_alignment_contact" ON "public"."project_contact_alignment" USING "btree" ("contact_id");



CREATE INDEX "idx_project_contact_alignment_project" ON "public"."project_contact_alignment" USING "btree" ("project_id");



CREATE INDEX "idx_project_contact_alignment_score" ON "public"."project_contact_alignment" USING "btree" ("alignment_score" DESC);



CREATE INDEX "idx_project_health_analysis_analysis_date" ON "public"."project_health_analysis" USING "btree" ("analysis_date" DESC);



CREATE INDEX "idx_project_health_analysis_health_score" ON "public"."project_health_analysis" USING "btree" ("health_score");



CREATE INDEX "idx_project_health_analysis_project_id" ON "public"."project_health_analysis" USING "btree" ("project_id");



CREATE INDEX "idx_project_health_history_project" ON "public"."project_health_history" USING "btree" ("project_id", "recorded_at" DESC);



CREATE INDEX "idx_project_intelligence_focus" ON "public"."project_intelligence" USING "gin" ("focus_areas");



CREATE INDEX "idx_project_intelligence_project" ON "public"."project_intelligence" USING "btree" ("project_id");



CREATE INDEX "idx_project_matches_alma" ON "public"."project_contact_matches" USING "btree" ("alma_intervention_id") WHERE ("alma_intervention_id" IS NOT NULL);



CREATE INDEX "idx_project_matches_contact" ON "public"."project_contact_matches" USING "btree" ("contact_id");



CREATE INDEX "idx_project_matches_person" ON "public"."project_contact_matches" USING "btree" ("person_id");



CREATE INDEX "idx_project_matches_project" ON "public"."project_contact_matches" USING "btree" ("project_notion_id");



CREATE INDEX "idx_project_matches_score" ON "public"."project_contact_matches" USING "btree" ("alignment_score" DESC);



CREATE INDEX "idx_project_matches_source" ON "public"."project_contact_matches" USING "btree" ("project_source");



CREATE INDEX "idx_project_matches_status" ON "public"."project_contact_matches" USING "btree" ("engagement_status");



CREATE INDEX "idx_project_media_links_hero" ON "public"."project_media_links" USING "btree" ("is_hero") WHERE ("is_hero" = true);



CREATE INDEX "idx_project_media_links_link" ON "public"."project_media_links" USING "btree" ("link_type", "link_id");



CREATE INDEX "idx_project_media_links_media_id" ON "public"."project_media_links" USING "btree" ("media_id");



CREATE INDEX "idx_project_outcomes_project" ON "public"."project_outcomes" USING "btree" ("project_id", "status");



CREATE INDEX "idx_project_outcomes_timeline" ON "public"."project_outcomes" USING "btree" ("outcome_period_start", "outcome_period_end");



CREATE INDEX "idx_project_outcomes_type" ON "public"."project_outcomes" USING "btree" ("outcome_type", "verification_status");



CREATE INDEX "idx_project_outcomes_verification" ON "public"."project_outcomes" USING "btree" ("verification_status", "verification_date");



CREATE INDEX "idx_project_updates_created" ON "public"."project_updates" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_project_updates_project" ON "public"."project_updates" USING "btree" ("project_id");



CREATE INDEX "idx_projects_name" ON "public"."projects" USING "btree" ("name");



CREATE INDEX "idx_projects_notion_id" ON "public"."projects" USING "btree" ("notion_id");



CREATE INDEX "idx_projects_notion_project_id" ON "public"."projects" USING "btree" ("notion_project_id");



CREATE INDEX "idx_projects_organization" ON "public"."projects" USING "btree" ("organization_id");



CREATE INDEX "idx_projects_status" ON "public"."projects" USING "btree" ("status");



CREATE INDEX "idx_proposals_agent" ON "public"."agent_proposals" USING "btree" ("agent_id");



CREATE INDEX "idx_proposals_coordination_status" ON "public"."agent_proposals" USING "btree" ("coordination_status") WHERE ("coordination_status" <> 'independent'::"text");



CREATE INDEX "idx_proposals_parent" ON "public"."agent_proposals" USING "btree" ("parent_proposal_id") WHERE ("parent_proposal_id" IS NOT NULL);



CREATE INDEX "idx_proposals_pending" ON "public"."agent_proposals" USING "btree" ("status", "created_at") WHERE ("status" = 'pending'::"text");



CREATE INDEX "idx_proposals_priority" ON "public"."agent_proposals" USING "btree" ("priority", "created_at");



CREATE INDEX "idx_proposals_status" ON "public"."agent_proposals" USING "btree" ("status");



CREATE INDEX "idx_proposals_target_agent" ON "public"."agent_proposals" USING "btree" ("target_agent_id") WHERE ("target_agent_id" IS NOT NULL);



CREATE INDEX "idx_public_profiles_empathy_ledger" ON "public"."public_profiles" USING "btree" ("empathy_ledger_profile_id") WHERE ("empathy_ledger_profile_id" IS NOT NULL);



CREATE UNIQUE INDEX "idx_public_profiles_empathy_ledger_id" ON "public"."public_profiles" USING "btree" ("empathy_ledger_profile_id") WHERE ("empathy_ledger_profile_id" IS NOT NULL);



CREATE INDEX "idx_public_profiles_featured" ON "public"."public_profiles" USING "btree" ("is_featured") WHERE ("is_featured" = true);



CREATE INDEX "idx_public_profiles_public" ON "public"."public_profiles" USING "btree" ("is_public") WHERE ("is_public" = true);



CREATE INDEX "idx_public_profiles_search" ON "public"."public_profiles" USING "gin" ("to_tsvector"('"english"'::"regconfig", (("full_name" || ' '::"text") || COALESCE("bio", ''::"text"))));



CREATE INDEX "idx_public_profiles_slug" ON "public"."public_profiles" USING "btree" ("slug");



CREATE INDEX "idx_public_profiles_user_id" ON "public"."public_profiles" USING "btree" ("user_id") WHERE ("user_id" IS NOT NULL);



CREATE INDEX "idx_queue_embedding" ON "public"."knowledge_extraction_queue" USING "ivfflat" ("content_embedding" "public"."vector_cosine_ops") WITH ("lists"='100');



CREATE INDEX "idx_quotes_approved" ON "public"."quotes" USING "btree" ("storyteller_approved");



CREATE INDEX "idx_quotes_story" ON "public"."quotes" USING "btree" ("story_id");



CREATE INDEX "idx_quotes_storyteller" ON "public"."quotes" USING "btree" ("storyteller_id");



CREATE INDEX "idx_quotes_transcript" ON "public"."quotes" USING "btree" ("transcript_id");



CREATE INDEX "idx_rd_log_developer" ON "public"."rd_activity_log" USING "btree" ("developer");



CREATE INDEX "idx_rd_log_started" ON "public"."rd_activity_log" USING "btree" ("started_at" DESC);



CREATE INDEX "idx_rd_log_status" ON "public"."rd_activity_log" USING "btree" ("status");



CREATE INDEX "idx_rec_outcomes_date" ON "public"."recommendation_outcomes" USING "btree" ("recommended_at");



CREATE INDEX "idx_rec_outcomes_entity" ON "public"."recommendation_outcomes" USING "btree" ("entity_id", "entity_type");



CREATE INDEX "idx_rec_outcomes_outcome" ON "public"."recommendation_outcomes" USING "btree" ("outcome") WHERE ("outcome" IS NOT NULL);



CREATE INDEX "idx_rec_outcomes_type" ON "public"."recommendation_outcomes" USING "btree" ("recommendation_type");



CREATE INDEX "idx_receipt_history_match" ON "public"."receipt_match_history" USING "btree" ("receipt_match_id");



CREATE INDEX "idx_receipt_matches_category" ON "public"."receipt_matches" USING "btree" ("category");



CREATE INDEX "idx_receipt_matches_date" ON "public"."receipt_matches" USING "btree" ("transaction_date" DESC);



CREATE INDEX "idx_receipt_matches_status" ON "public"."receipt_matches" USING "btree" ("status");



CREATE INDEX "idx_receipt_matches_vendor" ON "public"."receipt_matches" USING "btree" ("vendor_name");



CREATE INDEX "idx_receipt_matches_week" ON "public"."receipt_matches" USING "btree" ("week_start");



CREATE INDEX "idx_receipt_status_date" ON "public"."receipt_status" USING "btree" ("transaction_date" DESC);



CREATE INDEX "idx_receipt_status_project" ON "public"."receipt_status" USING "btree" ("project_code");



CREATE INDEX "idx_receipt_status_status" ON "public"."receipt_status" USING "btree" ("receipt_status");



CREATE INDEX "idx_receipt_status_vendor" ON "public"."receipt_status" USING "btree" ("vendor_name");



CREATE INDEX "idx_receipts_date" ON "public"."subscription_receipts" USING "btree" ("receipt_date" DESC);



CREATE INDEX "idx_receipts_reconciliation_confidence" ON "public"."subscription_receipts" USING "btree" ("reconciliation_confidence" DESC);



CREATE INDEX "idx_receipts_reconciliation_status" ON "public"."subscription_receipts" USING "btree" ("reconciliation_status");



CREATE INDEX "idx_receipts_subscription" ON "public"."subscription_receipts" USING "btree" ("subscription_id");



CREATE INDEX "idx_receipts_xero_txn" ON "public"."subscription_receipts" USING "btree" ("xero_transaction_id");



CREATE INDEX "idx_recommendation_date" ON "public"."recommendation_outcomes" USING "btree" ("recommended_at" DESC);



CREATE INDEX "idx_recommendation_entity" ON "public"."recommendation_outcomes" USING "btree" ("entity_type", "entity_id");



CREATE INDEX "idx_recommendation_outcome" ON "public"."recommendation_outcomes" USING "btree" ("outcome");



CREATE INDEX "idx_recommendation_type" ON "public"."recommendation_outcomes" USING "btree" ("recommendation_type");



CREATE INDEX "idx_reconciliation_weeks_start" ON "public"."receipt_reconciliation_weeks" USING "btree" ("week_start" DESC);



CREATE INDEX "idx_registered_services_profiles_profile" ON "public"."registered_services_profiles" USING "btree" ("public_profile_id");



CREATE INDEX "idx_registered_services_profiles_program" ON "public"."registered_services_profiles" USING "btree" ("program_id");



CREATE INDEX "idx_registered_services_profiles_role" ON "public"."registered_services_profiles" USING "btree" ("role");



CREATE INDEX "idx_relationship_health_days" ON "public"."relationship_health" USING "btree" ("days_since_contact");



CREATE INDEX "idx_relationship_health_days_since" ON "public"."relationship_health" USING "btree" ("days_since_contact" DESC);



CREATE INDEX "idx_relationship_health_lcaa_stage" ON "public"."relationship_health" USING "btree" ("lcaa_stage");



CREATE INDEX "idx_relationship_health_metadata_gin" ON "public"."relationship_health" USING "gin" ("sentiment_history");



CREATE INDEX "idx_relationship_health_stage" ON "public"."relationship_health" USING "btree" ("lcaa_stage");



CREATE INDEX "idx_relationship_health_temperature" ON "public"."relationship_health" USING "btree" ("temperature");



CREATE INDEX "idx_report_deliveries_report" ON "public"."alma_report_deliveries" USING "btree" ("report_id");



CREATE INDEX "idx_report_deliveries_subscription" ON "public"."alma_report_deliveries" USING "btree" ("subscription_id");



CREATE INDEX "idx_report_subscriptions_active" ON "public"."alma_report_subscriptions" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_report_subscriptions_org" ON "public"."alma_report_subscriptions" USING "btree" ("organization_id");



CREATE INDEX "idx_report_subscriptions_user" ON "public"."alma_report_subscriptions" USING "btree" ("user_id");



CREATE INDEX "idx_requests_created" ON "public"."agent_requests" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_requests_source" ON "public"."agent_requests" USING "btree" ("source_agent");



CREATE INDEX "idx_requests_status" ON "public"."agent_requests" USING "btree" ("status");



CREATE INDEX "idx_requests_target" ON "public"."agent_requests" USING "btree" ("target_agent");



CREATE INDEX "idx_research_findings_entity" ON "public"."alma_research_findings" USING "btree" ("entity_type", "entity_id");



CREATE INDEX "idx_research_findings_session" ON "public"."alma_research_findings" USING "btree" ("session_id");



CREATE INDEX "idx_research_findings_type" ON "public"."alma_research_findings" USING "btree" ("finding_type");



CREATE INDEX "idx_research_items_active" ON "public"."research_items" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_research_items_category" ON "public"."research_items" USING "btree" ("category");



CREATE INDEX "idx_research_items_featured" ON "public"."research_items" USING "btree" ("is_featured") WHERE ("is_featured" = true);



CREATE INDEX "idx_research_items_jurisdiction" ON "public"."research_items" USING "btree" ("jurisdiction");



CREATE INDEX "idx_research_items_search" ON "public"."research_items" USING "gin" ("to_tsvector"('"english"'::"regconfig", (((("title" || ' '::"text") || COALESCE("summary", ''::"text")) || ' '::"text") || "organization")));



CREATE INDEX "idx_research_items_slug" ON "public"."research_items" USING "btree" ("slug");



CREATE INDEX "idx_research_items_tags" ON "public"."research_items" USING "gin" ("tags");



CREATE INDEX "idx_research_items_type" ON "public"."research_items" USING "btree" ("type");



CREATE INDEX "idx_research_items_year" ON "public"."research_items" USING "btree" ("year" DESC);



CREATE INDEX "idx_research_sessions_created" ON "public"."alma_research_sessions" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_research_sessions_status" ON "public"."alma_research_sessions" USING "btree" ("status");



CREATE INDEX "idx_research_sessions_user" ON "public"."alma_research_sessions" USING "btree" ("user_id");



CREATE INDEX "idx_review_curated_date" ON "public"."review_curated_entries" USING "btree" ("date");



CREATE INDEX "idx_review_curated_included" ON "public"."review_curated_entries" USING "btree" ("included");



CREATE INDEX "idx_review_curated_year" ON "public"."review_curated_entries" USING "btree" ("year");



CREATE INDEX "idx_review_media_links_entity" ON "public"."review_media_links" USING "btree" ("link_type", "link_id");



CREATE INDEX "idx_review_media_links_media" ON "public"."review_media_links" USING "btree" ("media_id");



CREATE INDEX "idx_review_projects_slug" ON "public"."review_projects" USING "btree" ("slug");



CREATE INDEX "idx_review_projects_timeline_entry" ON "public"."review_projects" USING "btree" ("timeline_entry_id");



CREATE INDEX "idx_review_projects_year" ON "public"."review_projects" USING "btree" ("year");



CREATE INDEX "idx_review_videos_link" ON "public"."review_videos" USING "btree" ("link_type", "link_id");



CREATE INDEX "idx_review_videos_year" ON "public"."review_videos" USING "btree" ("year");



CREATE INDEX "idx_role_taxonomy_active" ON "public"."role_taxonomy" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_role_taxonomy_category" ON "public"."role_taxonomy" USING "btree" ("category");



CREATE INDEX "idx_scrape_history_date" ON "public"."alma_scrape_history" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_scrape_history_source" ON "public"."alma_scrape_history" USING "btree" ("source_id");



CREATE INDEX "idx_scrape_logs_recent" ON "public"."justice_matrix_scrape_logs" USING "btree" ("started_at" DESC);



CREATE INDEX "idx_scrape_logs_source" ON "public"."justice_matrix_scrape_logs" USING "btree" ("source_id");



CREATE INDEX "idx_scrape_logs_status" ON "public"."justice_matrix_scrape_logs" USING "btree" ("status");



CREATE INDEX "idx_scraped_services_category" ON "public"."scraped_services" USING "btree" ("category");



CREATE INDEX "idx_scraped_services_confidence" ON "public"."scraped_services" USING "btree" ("confidence_score");



CREATE INDEX "idx_scraped_services_org_id" ON "public"."scraped_services" USING "btree" ("organization_id");



CREATE INDEX "idx_scraped_services_validation" ON "public"."scraped_services" USING "btree" ("validation_status");



CREATE INDEX "idx_scraping_metadata_org_id" ON "public"."scraping_metadata" USING "btree" ("organization_id");



CREATE INDEX "idx_scraping_metadata_source_type" ON "public"."scraping_metadata" USING "btree" ("source_type");



CREATE INDEX "idx_scraping_metadata_timestamp" ON "public"."scraping_metadata" USING "btree" ("scraping_timestamp");



CREATE INDEX "idx_scraping_metadata_validation_status" ON "public"."scraping_metadata" USING "btree" ("validation_status");



CREATE INDEX "idx_service_contacts_service_id" ON "public"."service_contacts" USING "btree" ("service_id");



CREATE INDEX "idx_service_contacts_type" ON "public"."service_contacts" USING "btree" ("contact_type");



CREATE INDEX "idx_service_locations_coords" ON "public"."service_locations" USING "btree" ("latitude", "longitude") WHERE (("latitude" IS NOT NULL) AND ("longitude" IS NOT NULL));



CREATE INDEX "idx_service_locations_region" ON "public"."service_locations" USING "btree" ("region");



CREATE INDEX "idx_service_locations_service_id" ON "public"."service_locations" USING "btree" ("service_id");



CREATE INDEX "idx_service_locations_state" ON "public"."service_locations" USING "btree" ("state");



CREATE INDEX "idx_services_active" ON "public"."services" USING "btree" ("active");



CREATE INDEX "idx_services_alma_intervention" ON "public"."services" USING "btree" ("alma_intervention_id");



CREATE INDEX "idx_services_categories" ON "public"."services" USING "gin" ("categories");



CREATE INDEX "idx_services_category" ON "public"."services" USING "btree" ("category");



CREATE INDEX "idx_services_data_source" ON "public"."services" USING "btree" ("data_source");



CREATE INDEX "idx_services_geographical" ON "public"."services" USING "gin" ("geographical_coverage");



CREATE INDEX "idx_services_indigenous_specific" ON "public"."services" USING "btree" ("indigenous_specific");



CREATE INDEX "idx_services_keywords" ON "public"."services" USING "gin" ("keywords");



CREATE INDEX "idx_services_location" ON "public"."services" USING "btree" ("location_latitude", "location_longitude");



CREATE INDEX "idx_services_location_coords" ON "public"."services" USING "btree" ("latitude", "longitude") WHERE (("latitude" IS NOT NULL) AND ("longitude" IS NOT NULL));



CREATE INDEX "idx_services_organization" ON "public"."services" USING "btree" ("organization_id");



CREATE INDEX "idx_services_profiles_order" ON "public"."services_profiles" USING "btree" ("service_id", "display_order");



CREATE INDEX "idx_services_profiles_profile" ON "public"."services_profiles" USING "btree" ("public_profile_id");



CREATE INDEX "idx_services_profiles_service" ON "public"."services_profiles" USING "btree" ("service_id");



CREATE INDEX "idx_services_project" ON "public"."services" USING "btree" ("project");



CREATE INDEX "idx_services_verification_status" ON "public"."services" USING "btree" ("verification_status");



CREATE INDEX "idx_services_youth_specific" ON "public"."services" USING "btree" ("youth_specific");



CREATE INDEX "idx_site_deployments_deployed_at" ON "public"."site_deployments" USING "btree" ("deployed_at" DESC);



CREATE INDEX "idx_site_deployments_site_id" ON "public"."site_deployments" USING "btree" ("site_id");



CREATE INDEX "idx_site_deployments_vercel_id" ON "public"."site_deployments" USING "btree" ("vercel_deployment_id");



CREATE INDEX "idx_site_health_checks_checked_at" ON "public"."site_health_checks" USING "btree" ("checked_at" DESC);



CREATE INDEX "idx_site_health_checks_health_status" ON "public"."site_health_checks" USING "btree" ("health_status");



CREATE INDEX "idx_site_health_checks_site_id" ON "public"."site_health_checks" USING "btree" ("site_id");



CREATE INDEX "idx_skills_evidence_storyteller" ON "public"."skills_evidence" USING "btree" ("storyteller_id");



CREATE INDEX "idx_source_registry_jurisdiction" ON "public"."alma_source_registry" USING "btree" ("jurisdiction");



CREATE INDEX "idx_source_registry_next_scrape" ON "public"."alma_source_registry" USING "btree" ("next_scrape_at");



CREATE INDEX "idx_source_registry_priority" ON "public"."alma_source_registry" USING "btree" ("priority_score" DESC);



CREATE INDEX "idx_source_registry_type" ON "public"."alma_source_registry" USING "btree" ("source_type");



CREATE INDEX "idx_sources_active" ON "public"."justice_matrix_sources" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_sources_priority" ON "public"."justice_matrix_sources" USING "btree" ("scrape_priority");



CREATE INDEX "idx_sources_region" ON "public"."justice_matrix_sources" USING "btree" ("region");



CREATE INDEX "idx_sources_type" ON "public"."justice_matrix_sources" USING "btree" ("source_type");



CREATE INDEX "idx_sprint_snapshots_complete" ON "public"."sprint_snapshots" USING "btree" ("is_sprint_complete");



CREATE INDEX "idx_sprint_snapshots_snapshot_date" ON "public"."sprint_snapshots" USING "btree" ("snapshot_date" DESC);



CREATE INDEX "idx_sprint_snapshots_sprint_name" ON "public"."sprint_snapshots" USING "btree" ("sprint_name");



CREATE INDEX "idx_sprint_snapshots_sprint_number" ON "public"."sprint_snapshots" USING "btree" ("sprint_number" DESC);



CREATE INDEX "idx_stories_public_profile_id" ON "public"."stories" USING "btree" ("public_profile_id");



CREATE INDEX "idx_story_analysis_created_at" ON "public"."story_analysis" USING "btree" ("created_at");



CREATE INDEX "idx_story_analysis_publication_ready" ON "public"."story_analysis" USING "btree" ("publication_ready");



CREATE INDEX "idx_story_analysis_status" ON "public"."transcript_analysis" USING "btree" ("processing_status");



CREATE INDEX "idx_story_analysis_story_id" ON "public"."story_analysis" USING "btree" ("story_id");



CREATE INDEX "idx_story_analysis_storyteller" ON "public"."story_analysis" USING "btree" ("storyteller_id");



CREATE INDEX "idx_story_analysis_storyteller_id" ON "public"."story_analysis" USING "btree" ("storyteller_id");



CREATE INDEX "idx_story_analysis_transcript" ON "public"."transcript_analysis" USING "btree" ("transcript_id");



CREATE INDEX "idx_story_analysis_type" ON "public"."transcript_analysis" USING "btree" ("analysis_type");



CREATE INDEX "idx_story_comments_story_id" ON "public"."story_comments" USING "btree" ("story_id");



CREATE INDEX "idx_story_reactions_story_id" ON "public"."story_reactions" USING "btree" ("story_id");



CREATE INDEX "idx_story_related_art_art" ON "public"."story_related_art" USING "btree" ("art_innovation_id");



CREATE INDEX "idx_story_related_art_story" ON "public"."story_related_art" USING "btree" ("story_id");



CREATE INDEX "idx_story_related_interventions_intervention" ON "public"."story_related_interventions" USING "btree" ("intervention_id");



CREATE INDEX "idx_story_related_interventions_story" ON "public"."story_related_interventions" USING "btree" ("story_id");



CREATE INDEX "idx_story_related_programs_program" ON "public"."story_related_programs" USING "btree" ("program_id");



CREATE INDEX "idx_story_related_programs_story" ON "public"."story_related_programs" USING "btree" ("story_id");



CREATE INDEX "idx_story_related_services_service" ON "public"."story_related_services" USING "btree" ("service_id");



CREATE INDEX "idx_story_related_services_story" ON "public"."story_related_services" USING "btree" ("story_id");



CREATE INDEX "idx_storyteller_ai_intelligence_competency" ON "public"."storyteller_ai_intelligence" USING "btree" ("cultural_competency_level");



CREATE INDEX "idx_storyteller_ai_intelligence_impact" ON "public"."storyteller_ai_intelligence" USING "btree" ("community_impact_potential");



CREATE INDEX "idx_storyteller_ai_intelligence_storyteller_id" ON "public"."storyteller_ai_intelligence" USING "btree" ("storyteller_id");



CREATE INDEX "idx_storyteller_media_created_at" ON "public"."storyteller_media" USING "btree" ("created_at");



CREATE INDEX "idx_storyteller_media_storyteller_id" ON "public"."storyteller_media" USING "btree" ("storyteller_id");



CREATE INDEX "idx_storyteller_media_type" ON "public"."storyteller_media" USING "btree" ("type");



CREATE INDEX "idx_storyteller_videos_created_at" ON "public"."storyteller_videos" USING "btree" ("created_at");



CREATE INDEX "idx_storyteller_videos_platform" ON "public"."storyteller_videos" USING "btree" ("platform");



CREATE INDEX "idx_storyteller_videos_storyteller_id" ON "public"."storyteller_videos" USING "btree" ("storyteller_id");



CREATE INDEX "idx_storytellers_airtable" ON "public"."storytellers" USING "btree" ("airtable_record_id");



CREATE INDEX "idx_storytellers_consent" ON "public"."storytellers" USING "btree" ("consent_given");



CREATE INDEX "idx_storytellers_email" ON "public"."storytellers" USING "btree" ("email");



CREATE INDEX "idx_storytellers_location" ON "public"."storytellers" USING "btree" ("location_id");



CREATE INDEX "idx_storytellers_name" ON "public"."storytellers" USING "btree" ("full_name");



CREATE INDEX "idx_storytellers_organization" ON "public"."storytellers" USING "btree" ("organization_id");



CREATE INDEX "idx_storytellers_project" ON "public"."storytellers" USING "btree" ("project_id");



CREATE INDEX "idx_storytellers_project_id" ON "public"."storytellers" USING "btree" ("project_id");



CREATE INDEX "idx_studio_projects_category" ON "public"."studio_projects" USING "btree" ("category");



CREATE INDEX "idx_studio_projects_code" ON "public"."studio_projects" USING "btree" ("code");



CREATE INDEX "idx_studio_projects_status" ON "public"."studio_projects" USING "btree" ("status");



CREATE INDEX "idx_subscriptions_account_email" ON "public"."discovered_subscriptions" USING "btree" ("account_email");



CREATE INDEX "idx_subscriptions_category" ON "public"."subscriptions" USING "btree" ("category");



CREATE INDEX "idx_subscriptions_confidence" ON "public"."discovered_subscriptions" USING "btree" ("confidence" DESC);



CREATE INDEX "idx_subscriptions_last_scanned" ON "public"."discovered_subscriptions" USING "btree" ("last_scanned" DESC);



CREATE INDEX "idx_subscriptions_metadata" ON "public"."discovered_subscriptions" USING "gin" ("metadata");



CREATE INDEX "idx_subscriptions_migration_priority" ON "public"."discovered_subscriptions" USING "btree" ("migration_priority" DESC);



CREATE INDEX "idx_subscriptions_migration_status" ON "public"."discovered_subscriptions" USING "btree" ("migration_status");



CREATE INDEX "idx_subscriptions_review_status" ON "public"."subscriptions" USING "btree" ("review_status");



CREATE INDEX "idx_subscriptions_tenant_status" ON "public"."discovered_subscriptions" USING "btree" ("tenant_id", "status");



CREATE INDEX "idx_suggestions_created" ON "public"."content_link_suggestions" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_suggestions_pending" ON "public"."content_link_suggestions" USING "btree" ("status", "confidence" DESC) WHERE ("status" = 'pending'::"text");



CREATE INDEX "idx_suggestions_source" ON "public"."content_link_suggestions" USING "btree" ("source_type", "source_id");



CREATE INDEX "idx_suggestions_target" ON "public"."content_link_suggestions" USING "btree" ("target_type", "target_id");



CREATE INDEX "idx_support_matches_seeker" ON "public"."support_matches" USING "btree" ("seeker_id");



CREATE INDEX "idx_support_matches_supporter" ON "public"."support_matches" USING "btree" ("supporter_id");



CREATE INDEX "idx_sync_events_batch" ON "public"."sync_events" USING "btree" ("batch_id") WHERE ("batch_id" IS NOT NULL);



CREATE INDEX "idx_sync_events_created_at" ON "public"."sync_events" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_sync_events_processing" ON "public"."sync_events" USING "btree" ("sync_status", "priority") WHERE ("sync_status" = 'processing'::"text");



CREATE INDEX "idx_sync_events_retry" ON "public"."sync_events" USING "btree" ("retry_count", "max_retries") WHERE ("sync_status" = 'failed'::"text");



CREATE INDEX "idx_sync_events_status" ON "public"."sync_events" USING "btree" ("sync_status", "priority", "created_at");



CREATE INDEX "idx_sync_events_table" ON "public"."sync_events" USING "btree" ("table_name", "event_type");



CREATE INDEX "idx_sync_queue_cultural" ON "public"."sync_queue" USING "btree" ("cultural_check_passed") WHERE ("cultural_check_passed" = false);



CREATE INDEX "idx_sync_queue_status" ON "public"."sync_queue" USING "btree" ("status");



CREATE INDEX "idx_sync_state_type" ON "public"."sync_state" USING "btree" ("sync_type");



CREATE UNIQUE INDEX "idx_tag_rules_unique" ON "public"."tag_inference_rules" USING "btree" ("rule_type", "match_value");



CREATE INDEX "idx_task_queue_agent" ON "public"."agent_task_queue" USING "btree" ("assigned_agent");



CREATE INDEX "idx_task_queue_priority" ON "public"."agent_task_queue" USING "btree" ("priority", "created_at");



CREATE INDEX "idx_task_queue_review" ON "public"."agent_task_queue" USING "btree" ("needs_review") WHERE ("needs_review" = true);



CREATE INDEX "idx_task_queue_status" ON "public"."agent_task_queue" USING "btree" ("status");



CREATE INDEX "idx_tasks_agent" ON "public"."agentic_tasks" USING "btree" ("assigned_agent") WHERE ("assigned_agent" IS NOT NULL);



CREATE INDEX "idx_tasks_project" ON "public"."agentic_tasks" USING "btree" ("project_id");



CREATE INDEX "idx_tasks_status" ON "public"."agentic_tasks" USING "btree" ("status");



CREATE INDEX "idx_themes_category" ON "public"."themes" USING "btree" ("category");



CREATE INDEX "idx_themes_parent" ON "public"."themes" USING "btree" ("parent_theme_id");



CREATE INDEX "idx_themes_status" ON "public"."themes" USING "btree" ("status");



CREATE INDEX "idx_tool_logs_session" ON "public"."alma_research_tool_logs" USING "btree" ("session_id");



CREATE INDEX "idx_touchpoints_contact" ON "public"."touchpoints" USING "btree" ("contact_id");



CREATE INDEX "idx_touchpoints_occurred_at" ON "public"."touchpoints" USING "btree" ("occurred_at" DESC);



CREATE INDEX "idx_touchpoints_project" ON "public"."touchpoints" USING "btree" ("project_id");



CREATE INDEX "idx_touchpoints_source" ON "public"."touchpoints" USING "btree" ("source");



CREATE INDEX "idx_training_content_type" ON "public"."training_dataset" USING "btree" ("content_type");



CREATE INDEX "idx_training_project" ON "public"."training_dataset" USING "btree" ("project_slug");



CREATE INDEX "idx_training_quality" ON "public"."training_dataset" USING "btree" ("overall_quality_score");



CREATE INDEX "idx_training_tags" ON "public"."training_dataset" USING "gin" ("tags");



CREATE INDEX "idx_transcript_analysis_storyteller_id" ON "public"."transcript_analysis" USING "btree" ("storyteller_id");



CREATE INDEX "idx_transcripts_consent" ON "public"."transcripts" USING "btree" ("consent_for_ai_analysis");



CREATE INDEX "idx_transcripts_created_date" ON "public"."transcripts" USING "btree" ("created_at");



CREATE INDEX "idx_transcripts_privacy" ON "public"."transcripts" USING "btree" ("privacy_level");



CREATE INDEX "idx_transcripts_processing_status" ON "public"."transcripts" USING "btree" ("processing_status");



CREATE INDEX "idx_transcripts_ready_analysis" ON "public"."transcripts" USING "btree" ("ready_for_analysis");



CREATE INDEX "idx_transcripts_safety_status" ON "public"."transcripts" USING "btree" ("safety_review_status");



CREATE INDEX "idx_transcripts_storyteller" ON "public"."transcripts" USING "btree" ("storyteller_id");



CREATE INDEX "idx_transcripts_storyteller_created" ON "public"."transcripts" USING "btree" ("storyteller_id", "created_at" DESC);



CREATE INDEX "idx_user_behavior_insights_user" ON "public"."user_behavior_insights" USING "btree" ("user_id", "analysis_period_end" DESC);



CREATE INDEX "idx_user_identities_discord" ON "public"."user_identities" USING "btree" ("discord_id");



CREATE INDEX "idx_user_identities_email" ON "public"."user_identities" USING "btree" ("email");



CREATE INDEX "idx_user_identities_signal" ON "public"."user_identities" USING "btree" ("signal_number");



CREATE INDEX "idx_user_identities_telegram" ON "public"."user_identities" USING "btree" ("telegram_id");



CREATE INDEX "idx_user_identities_whatsapp" ON "public"."user_identities" USING "btree" ("whatsapp_number");



CREATE INDEX "idx_user_profiles_email" ON "public"."user_profiles" USING "btree" ("email");



CREATE INDEX "idx_user_profiles_interests" ON "public"."user_profiles" USING "gin" ("interests");



CREATE INDEX "idx_user_profiles_location" ON "public"."user_profiles" USING "gin" ("location");



CREATE INDEX "idx_user_profiles_status" ON "public"."user_profiles" USING "btree" ("account_status", "last_active_at" DESC);



CREATE INDEX "idx_user_profiles_user_id" ON "public"."user_profiles" USING "btree" ("user_id");



CREATE INDEX "idx_user_project_preferences_project" ON "public"."user_project_preferences" USING "btree" ("project_id", "engagement_level");



CREATE INDEX "idx_user_project_preferences_user" ON "public"."user_project_preferences" USING "btree" ("user_profile_id", "preference_type");



CREATE INDEX "idx_vendor_contact_log_sent_at" ON "public"."vendor_contact_log" USING "btree" ("sent_at" DESC);



CREATE INDEX "idx_vendor_contact_log_status" ON "public"."vendor_contact_log" USING "btree" ("status");



CREATE INDEX "idx_vendor_contact_log_subscription" ON "public"."vendor_contact_log" USING "btree" ("subscription_id");



CREATE INDEX "idx_verifications_content_type" ON "public"."ai_content_verifications" USING "btree" ("content_type");



CREATE INDEX "idx_verifications_elder_review" ON "public"."ai_content_verifications" USING "btree" ("requires_elder_review", "elder_reviewed_at");



CREATE INDEX "idx_verifications_project" ON "public"."ai_content_verifications" USING "btree" ("project_slug");



CREATE INDEX "idx_verifications_status" ON "public"."ai_content_verifications" USING "btree" ("status");



CREATE INDEX "idx_verifications_training" ON "public"."ai_content_verifications" USING "btree" ("used_for_training");



CREATE INDEX "idx_video_embeds_link" ON "public"."video_embeds" USING "btree" ("link_type", "link_id");



CREATE INDEX "idx_video_embeds_platform" ON "public"."video_embeds" USING "btree" ("platform");



CREATE INDEX "idx_voice_note_shares_note" ON "public"."voice_note_shares" USING "btree" ("voice_note_id");



CREATE INDEX "idx_voice_note_shares_user" ON "public"."voice_note_shares" USING "btree" ("shared_with");



CREATE INDEX "idx_voice_notes_channel" ON "public"."voice_notes" USING "btree" ("source_channel");



CREATE INDEX "idx_voice_notes_contact" ON "public"."voice_notes" USING "btree" ("related_contact_id");



CREATE INDEX "idx_voice_notes_cultural" ON "public"."voice_notes" USING "btree" ("requires_cultural_review") WHERE ("requires_cultural_review" = true);



CREATE INDEX "idx_voice_notes_embedding" ON "public"."voice_notes" USING "ivfflat" ("embedding" "public"."vector_cosine_ops") WITH ("lists"='100');



CREATE INDEX "idx_voice_notes_project" ON "public"."voice_notes" USING "btree" ("project_context");



CREATE INDEX "idx_voice_notes_recorded_at" ON "public"."voice_notes" USING "btree" ("recorded_at" DESC);



CREATE INDEX "idx_voice_notes_recorded_by" ON "public"."voice_notes" USING "btree" ("recorded_by");



CREATE INDEX "idx_voice_notes_topics" ON "public"."voice_notes" USING "gin" ("topics");



CREATE INDEX "idx_voice_notes_visibility" ON "public"."voice_notes" USING "btree" ("visibility");



CREATE INDEX "idx_volunteer_hours_contact" ON "public"."volunteer_hours" USING "btree" ("ghl_contact_id");



CREATE INDEX "idx_weekly_reports_org" ON "public"."alma_weekly_reports" USING "btree" ("organization_id");



CREATE INDEX "idx_weekly_reports_status" ON "public"."alma_weekly_reports" USING "btree" ("status");



CREATE INDEX "idx_weekly_reports_type" ON "public"."alma_weekly_reports" USING "btree" ("report_type");



CREATE INDEX "idx_weekly_reports_week" ON "public"."alma_weekly_reports" USING "btree" ("week_start");



CREATE INDEX "idx_wiki_articles_category" ON "public"."wiki_articles" USING "btree" ("category");



CREATE INDEX "idx_wiki_articles_slug" ON "public"."wiki_articles" USING "btree" ("slug");



CREATE INDEX "idx_wiki_embedding" ON "public"."wiki_pages" USING "ivfflat" ("content_embedding" "public"."vector_cosine_ops") WITH ("lists"='100');



CREATE INDEX "idx_wiki_links_from" ON "public"."wiki_page_links" USING "btree" ("from_page_id");



CREATE INDEX "idx_wiki_links_to" ON "public"."wiki_page_links" USING "btree" ("to_page_id");



CREATE INDEX "idx_wiki_pages_auto_approved" ON "public"."wiki_pages" USING "btree" ("auto_approved") WHERE ("auto_approved" = true);



CREATE INDEX "idx_wiki_pages_domains" ON "public"."wiki_pages" USING "gin" ("domains");



CREATE INDEX "idx_wiki_pages_notion_id" ON "public"."wiki_pages" USING "btree" ("notion_page_id");



CREATE INDEX "idx_wiki_pages_projects" ON "public"."wiki_pages" USING "gin" ("projects");



CREATE INDEX "idx_wiki_pages_review" ON "public"."wiki_pages" USING "btree" ("next_review_due") WHERE ("status" = 'active'::"text");



CREATE INDEX "idx_wiki_pages_search" ON "public"."wiki_pages" USING "gin" ("search_vector");



CREATE INDEX "idx_wiki_pages_slug" ON "public"."wiki_pages" USING "btree" ("slug");



CREATE INDEX "idx_wiki_pages_status" ON "public"."wiki_pages" USING "btree" ("status");



CREATE INDEX "idx_wiki_pages_tags" ON "public"."wiki_pages" USING "gin" ("tags");



CREATE INDEX "idx_wiki_pages_type" ON "public"."wiki_pages" USING "btree" ("page_type");



CREATE INDEX "idx_wiki_versions_page" ON "public"."wiki_page_versions" USING "btree" ("page_id", "version" DESC);



CREATE INDEX "idx_wisdom_extracts_storyteller" ON "public"."wisdom_extracts" USING "btree" ("storyteller_id");



CREATE INDEX "idx_wisdom_insights_sharing" ON "public"."wisdom_insights" USING "btree" ("sharing_level");



CREATE INDEX "idx_wisdom_insights_storyteller" ON "public"."wisdom_insights" USING "btree" ("storyteller_id");



CREATE INDEX "idx_wisdom_insights_universality" ON "public"."wisdom_insights" USING "btree" ("universality_score" DESC);



CREATE INDEX "idx_work_log_project" ON "public"."agentic_work_log" USING "btree" ("project_id", "created_at");



CREATE INDEX "idx_xero_alerts_active" ON "public"."xero_financial_alerts" USING "btree" ("detected_at" DESC) WHERE ("resolved_at" IS NULL);



CREATE INDEX "idx_xero_alerts_priority" ON "public"."xero_financial_alerts" USING "btree" ("priority");



CREATE INDEX "idx_xero_alerts_type" ON "public"."xero_financial_alerts" USING "btree" ("alert_type");



CREATE INDEX "idx_xero_bank_transactions_date" ON "public"."xero_bank_transactions" USING "btree" ("date" DESC);



CREATE INDEX "idx_xero_bank_transactions_tenant" ON "public"."xero_bank_transactions" USING "btree" ("tenant_id");



CREATE INDEX "idx_xero_bas_tenant_period" ON "public"."xero_bas_tracking" USING "btree" ("tenant_id", "period_start", "period_end");



CREATE INDEX "idx_xero_contacts_email" ON "public"."xero_contacts" USING "btree" ("email");



CREATE INDEX "idx_xero_contacts_tenant" ON "public"."xero_contacts" USING "btree" ("tenant_id");



CREATE INDEX "idx_xero_invoices_contact" ON "public"."xero_invoices" USING "btree" ("contact_id");



CREATE INDEX "idx_xero_invoices_date" ON "public"."xero_invoices" USING "btree" ("date" DESC);



CREATE INDEX "idx_xero_invoices_due_date" ON "public"."xero_invoices" USING "btree" ("due_date");



CREATE INDEX "idx_xero_invoices_has_attachments" ON "public"."xero_invoices" USING "btree" ("has_attachments");



CREATE INDEX "idx_xero_invoices_status" ON "public"."xero_invoices" USING "btree" ("status");



CREATE INDEX "idx_xero_invoices_tenant" ON "public"."xero_invoices" USING "btree" ("tenant_id");



CREATE INDEX "idx_xero_invoices_type" ON "public"."xero_invoices" USING "btree" ("invoice_type");



CREATE INDEX "idx_xero_snapshots_date" ON "public"."xero_financial_snapshots" USING "btree" ("snapshot_date" DESC);



CREATE INDEX "idx_xero_snapshots_type_date" ON "public"."xero_financial_snapshots" USING "btree" ("snapshot_type", "snapshot_date" DESC);



CREATE INDEX "idx_xero_sync_log_status" ON "public"."xero_sync_log" USING "btree" ("status");



CREATE INDEX "idx_xero_sync_log_type" ON "public"."xero_sync_log" USING "btree" ("sync_type");



CREATE INDEX "idx_xero_transactions_date" ON "public"."xero_transactions" USING "btree" ("date");



CREATE INDEX "idx_xero_transactions_has_attachments" ON "public"."xero_transactions" USING "btree" ("has_attachments");



CREATE INDEX "idx_xero_transactions_project" ON "public"."xero_transactions" USING "btree" ("project_code");



CREATE INDEX "idx_xero_transactions_type" ON "public"."xero_transactions" USING "btree" ("type");



CREATE INDEX "intelligence_briefings_generated_at_idx" ON "public"."intelligence_briefings" USING "btree" ("generated_at" DESC);



CREATE INDEX "intelligence_geo_alerts_region_idx" ON "public"."intelligence_geo_alerts" USING "btree" ("region");



CREATE INDEX "intelligence_refusals_agent_idx" ON "public"."intelligence_refusals" USING "btree" ("agent");



CREATE INDEX "messages_portrait_id_idx" ON "public"."messages" USING "btree" ("portrait_id");



CREATE INDEX "opportunities_archived_idx" ON "public"."opportunities" USING "btree" ("archived");



CREATE INDEX "portraits_access_code_idx" ON "public"."portraits" USING "btree" ("access_code");



CREATE INDEX "portraits_storyteller_id_idx" ON "public"."portraits" USING "btree" ("storyteller_id");



CREATE INDEX "portraits_visible_idx" ON "public"."portraits" USING "btree" ("visible");



CREATE INDEX "project_pairings_partner_idx" ON "public"."project_pairings" USING "btree" ("partner_project_id");



CREATE INDEX "project_pairings_project_idx" ON "public"."project_pairings" USING "btree" ("project_id");



CREATE INDEX "project_research_project_idx" ON "public"."project_research" USING "btree" ("project_id", "created_at" DESC);



CREATE INDEX "projects_end_date_idx" ON "public"."projects" USING "btree" ("end_date");



CREATE INDEX "pulse_events_created_at_idx" ON "public"."pulse_events" USING "btree" ("created_at");



CREATE INDEX "pulse_events_portrait_id_idx" ON "public"."pulse_events" USING "btree" ("portrait_id");



CREATE INDEX "push_subscriptions_storyteller_id_idx" ON "public"."push_subscriptions" USING "btree" ("storyteller_id");



CREATE UNIQUE INDEX "uq_analysis_jobs_active" ON "public"."analysis_jobs" USING "btree" ("transcript_id") WHERE ("status" = ANY (ARRAY['queued'::"public"."analysis_job_status_enum", 'processing'::"public"."analysis_job_status_enum"]));



CREATE UNIQUE INDEX "uq_bcoupon_tenant_code" ON "public"."billing_coupons" USING "btree" ("tenant_id", "code");



CREATE UNIQUE INDEX "uq_linkedin_imports_owner_type_hash" ON "public"."linkedin_imports" USING "btree" ("owner", "type", "hash");



CREATE OR REPLACE VIEW "public"."platform_public_media_with_collections" AS
 SELECT "m"."id",
    "m"."platform_organization_id",
    "m"."file_url",
    "m"."thumbnail_url",
    "m"."file_type",
    "m"."title",
    "m"."description",
    "m"."content_category",
    "m"."content_subcategory",
    "m"."manual_tags",
    "m"."impact_themes",
    "m"."photographer",
    "m"."capture_date",
    "m"."created_at",
    "o"."slug" AS "organization_slug",
    "o"."name" AS "organization_name",
    COALESCE("json_agg"("json_build_object"('collection_id', "c"."id", 'collection_name', "c"."name", 'collection_type', "c"."type", 'sort_order', "cm"."sort_order") ORDER BY "cm"."sort_order") FILTER (WHERE ("c"."id" IS NOT NULL)), '[]'::json) AS "collections"
   FROM ((("public"."platform_media_items" "m"
     JOIN "public"."platform_organizations" "o" ON (("m"."platform_organization_id" = "o"."id")))
     LEFT JOIN "public"."platform_collection_media" "cm" ON (("m"."id" = "cm"."media_id")))
     LEFT JOIN "public"."platform_media_collections" "c" ON ((("cm"."collection_id" = "c"."id") AND ("c"."public_visible" = true))))
  WHERE (("m"."community_approved" = true) AND ("m"."consent_verified" = true))
  GROUP BY "m"."id", "o"."slug", "o"."name";



CREATE OR REPLACE VIEW "public"."v_unified_contacts" AS
 SELECT "ce"."id",
    "ce"."canonical_name" AS "name",
    "ce"."canonical_email" AS "email",
    "ce"."canonical_phone" AS "phone",
    "ce"."canonical_company" AS "company",
    "ce"."confidence",
    "ce"."relationship_strength",
    "ce"."primary_project_codes",
    "array_agg"(DISTINCT "ei"."source") AS "sources",
    "max"(
        CASE
            WHEN ("ei"."source" = 'ghl'::"text") THEN "ei"."source_record_id"
            ELSE NULL::"text"
        END) AS "ghl_id",
    "max"(
        CASE
            WHEN ("ei"."source" = 'notion'::"text") THEN "ei"."source_record_id"
            ELSE NULL::"text"
        END) AS "notion_id",
    "count"(DISTINCT "ei"."id") AS "identifier_count",
    "ce"."created_at",
    "ce"."updated_at"
   FROM ("public"."canonical_entities" "ce"
     LEFT JOIN "public"."entity_identifiers" "ei" ON (("ei"."entity_id" = "ce"."id")))
  WHERE ("ce"."entity_type" = 'person'::"text")
  GROUP BY "ce"."id";



CREATE OR REPLACE VIEW "public"."agentic_project_dashboard" AS
 SELECT "p"."id",
    "p"."name",
    "p"."goal",
    "p"."status",
    "p"."owner",
    "p"."created_at",
    "count"("t"."id") AS "total_tasks",
    "count"("t"."id") FILTER (WHERE ("t"."status" = 'completed'::"text")) AS "completed_tasks",
    "count"("t"."id") FILTER (WHERE ("t"."status" = 'agent_working'::"text")) AS "agent_working",
    "count"("t"."id") FILTER (WHERE ("t"."status" = 'needs_review'::"text")) AS "needs_review",
    "count"("t"."id") FILTER (WHERE ("t"."assigned_agent" IS NOT NULL)) AS "agent_tasks",
    "count"("t"."id") FILTER (WHERE ("t"."assigned_human" IS NOT NULL)) AS "human_tasks"
   FROM ("public"."agentic_projects" "p"
     LEFT JOIN "public"."agentic_tasks" "t" ON (("t"."project_id" = "p"."id")))
  GROUP BY "p"."id";



CREATE OR REPLACE TRIGGER "auto_flag_executions" BEFORE INSERT ON "public"."autonomous_executions" FOR EACH ROW EXECUTE FUNCTION "public"."flag_low_confidence_executions"();



CREATE OR REPLACE TRIGGER "auto_generate_storage_prefix" BEFORE INSERT ON "public"."platform_organizations" FOR EACH ROW EXECUTE FUNCTION "public"."generate_storage_prefix"();



CREATE OR REPLACE TRIGGER "calculate_article_reading_time" BEFORE INSERT OR UPDATE OF "content" ON "public"."articles" FOR EACH ROW EXECUTE FUNCTION "public"."update_article_reading_time"();



CREATE OR REPLACE TRIGGER "calendar_events_updated_at" BEFORE UPDATE ON "public"."calendar_events" FOR EACH ROW EXECUTE FUNCTION "public"."update_calendar_events_updated_at"();



CREATE OR REPLACE TRIGGER "cleanup_pulse_events" AFTER INSERT ON "public"."pulse_events" FOR EACH STATEMENT EXECUTE FUNCTION "public"."delete_old_pulse_events"();



CREATE OR REPLACE TRIGGER "community_programs_profiles_v_insert" INSTEAD OF INSERT ON "public"."community_programs_profiles_v" FOR EACH ROW EXECUTE FUNCTION "public"."insert_community_programs_profile"();



CREATE OR REPLACE TRIGGER "contact_review_updated" BEFORE UPDATE ON "public"."contact_review_decisions" FOR EACH ROW EXECUTE FUNCTION "public"."update_contact_review_timestamp"();



CREATE OR REPLACE TRIGGER "goal_metrics_updated_at" BEFORE UPDATE ON "public"."goal_metrics" FOR EACH ROW EXECUTE FUNCTION "public"."update_goals_2026_updated_at"();



CREATE OR REPLACE TRIGGER "goal_update_logger" AFTER UPDATE ON "public"."goals_2026" FOR EACH ROW EXECUTE FUNCTION "public"."log_goal_update"();



CREATE OR REPLACE TRIGGER "health_alert_trigger" AFTER INSERT ON "public"."site_health_checks" FOR EACH ROW EXECUTE FUNCTION "public"."create_health_alert"();



CREATE OR REPLACE TRIGGER "knowledge_source_sync_updated_at" BEFORE UPDATE ON "public"."knowledge_source_sync" FOR EACH ROW EXECUTE FUNCTION "public"."update_knowledge_version_timestamp"();



CREATE OR REPLACE TRIGGER "knowledge_versions_updated_at" BEFORE UPDATE ON "public"."knowledge_versions" FOR EACH ROW EXECUTE FUNCTION "public"."update_knowledge_version_timestamp"();



CREATE OR REPLACE TRIGGER "media_library_updated_at" BEFORE UPDATE ON "public"."media_library" FOR EACH ROW EXECUTE FUNCTION "public"."update_media_library_updated_at"();



CREATE OR REPLACE TRIGGER "pmpp_knowledge_updated_at" BEFORE UPDATE ON "public"."pmpp_knowledge" FOR EACH ROW EXECUTE FUNCTION "public"."update_knowledge_version_timestamp"();



CREATE OR REPLACE TRIGGER "profile_appearances_updated_at" BEFORE UPDATE ON "public"."profile_appearances" FOR EACH ROW EXECUTE FUNCTION "public"."update_profile_appearances_updated_at"();



CREATE OR REPLACE TRIGGER "set_event_slug" BEFORE INSERT ON "public"."events" FOR EACH ROW EXECUTE FUNCTION "public"."generate_event_slug"();



CREATE OR REPLACE TRIGGER "site_health_check_update" AFTER INSERT ON "public"."site_health_checks" FOR EACH ROW EXECUTE FUNCTION "public"."update_site_health_from_check"();



CREATE OR REPLACE TRIGGER "story_analysis_updated_at" BEFORE UPDATE ON "public"."story_analysis" FOR EACH ROW EXECUTE FUNCTION "public"."update_story_analysis_updated_at"();



CREATE OR REPLACE TRIGGER "storyteller_ai_intelligence_update_updated_at" BEFORE UPDATE ON "public"."storyteller_ai_intelligence" FOR EACH ROW EXECUTE FUNCTION "public"."update_storyteller_ai_intelligence_updated_at"();



CREATE OR REPLACE TRIGGER "storyteller_videos_update_updated_at" BEFORE UPDATE ON "public"."storyteller_videos" FOR EACH ROW EXECUTE FUNCTION "public"."update_storyteller_videos_updated_at"();



CREATE OR REPLACE TRIGGER "subscriptions_updated_at" BEFORE UPDATE ON "public"."discovered_subscriptions" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "subscriptions_updated_at" BEFORE UPDATE ON "public"."subscriptions" FOR EACH ROW EXECUTE FUNCTION "public"."update_subscriptions_timestamp"();



CREATE OR REPLACE TRIGGER "task_queue_updated" BEFORE UPDATE ON "public"."agent_task_queue" FOR EACH ROW EXECUTE FUNCTION "public"."update_task_timestamp"();



CREATE OR REPLACE TRIGGER "trg_analysis_jobs_updated_at" BEFORE UPDATE ON "public"."analysis_jobs" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "trg_contact_cadence_metrics_updated" BEFORE UPDATE ON "public"."contact_cadence_metrics" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_contact_intelligence_insights_updated" BEFORE UPDATE ON "public"."contact_intelligence_insights" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_contact_support_preferences_updated" BEFORE UPDATE ON "public"."contact_support_preferences" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_contact_support_recommendations_updated" BEFORE UPDATE ON "public"."contact_support_recommendations" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_financial_project_summaries_updated" BEFORE UPDATE ON "public"."financial_project_summaries" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_notion_opportunities_updated" BEFORE UPDATE ON "public"."notion_opportunities" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_notion_organizations_updated" BEFORE UPDATE ON "public"."notion_organizations" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_notion_projects_updated" BEFORE UPDATE ON "public"."notion_projects" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_outreach_tasks_updated" BEFORE UPDATE ON "public"."outreach_tasks" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_project_support_graph_updated" BEFORE UPDATE ON "public"."project_support_graph" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_projects_updated" BEFORE UPDATE ON "public"."projects" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_storytellers_updated" BEFORE UPDATE ON "public"."storytellers" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_auto_calculate_temperature" BEFORE INSERT OR UPDATE ON "public"."relationship_health" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_calculate_temperature"();



CREATE OR REPLACE TRIGGER "trigger_auto_person_identity" BEFORE UPDATE ON "public"."linkedin_contacts" FOR EACH ROW EXECUTE FUNCTION "public"."auto_create_person_identity"();



COMMENT ON TRIGGER "trigger_auto_person_identity" ON "public"."linkedin_contacts" IS 'Auto-creates person identity mapping after Exa enrichment (UPDATE)';



CREATE OR REPLACE TRIGGER "trigger_auto_person_identity_insert" BEFORE INSERT ON "public"."linkedin_contacts" FOR EACH ROW EXECUTE FUNCTION "public"."auto_create_person_identity"();



CREATE OR REPLACE TRIGGER "trigger_canonical_entities_updated" BEFORE UPDATE ON "public"."canonical_entities" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_check_cultural_content" BEFORE INSERT OR UPDATE OF "transcript" ON "public"."voice_notes" FOR EACH ROW EXECUTE FUNCTION "public"."check_cultural_content"();



CREATE OR REPLACE TRIGGER "trigger_comms_history_updated" BEFORE UPDATE ON "public"."communications_history" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_community_event_sync_delete" AFTER DELETE ON "public"."community_events" FOR EACH ROW EXECUTE FUNCTION "public"."queue_community_event_sync"();



CREATE OR REPLACE TRIGGER "trigger_community_event_sync_insert" AFTER INSERT ON "public"."community_events" FOR EACH ROW EXECUTE FUNCTION "public"."queue_community_event_sync"();



CREATE OR REPLACE TRIGGER "trigger_community_event_sync_update" AFTER UPDATE ON "public"."community_events" FOR EACH ROW WHEN (("old".* IS DISTINCT FROM "new".*)) EXECUTE FUNCTION "public"."queue_community_event_sync"();



CREATE OR REPLACE TRIGGER "trigger_cultural_protocols_updated" BEFORE UPDATE ON "public"."cultural_protocols" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_cultural_sync_guard" BEFORE INSERT OR UPDATE ON "public"."sync_queue" FOR EACH ROW EXECUTE FUNCTION "public"."prevent_cultural_sync"();



CREATE OR REPLACE TRIGGER "trigger_decision_input_hash" BEFORE INSERT ON "public"."decision_traces" FOR EACH ROW EXECUTE FUNCTION "public"."generate_input_hash"();



CREATE OR REPLACE TRIGGER "trigger_funding_applications_updated" BEFORE UPDATE ON "public"."alma_funding_applications" FOR EACH ROW EXECUTE FUNCTION "public"."update_funding_opportunities_timestamp"();



CREATE OR REPLACE TRIGGER "trigger_funding_opportunities_updated" BEFORE UPDATE ON "public"."alma_funding_opportunities" FOR EACH ROW EXECUTE FUNCTION "public"."update_funding_opportunities_timestamp"();



CREATE OR REPLACE TRIGGER "trigger_funding_status_update" BEFORE INSERT OR UPDATE ON "public"."alma_funding_opportunities" FOR EACH ROW EXECUTE FUNCTION "public"."update_funding_opportunity_status"();



CREATE OR REPLACE TRIGGER "trigger_generate_public_profile_slug" BEFORE INSERT OR UPDATE OF "full_name" ON "public"."public_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."generate_public_profile_slug"();



CREATE OR REPLACE TRIGGER "trigger_ghl_contacts_updated" BEFORE UPDATE ON "public"."ghl_contacts" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_ghl_opportunities_updated" BEFORE UPDATE ON "public"."ghl_opportunities" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_knowledge_chunks_updated" BEFORE UPDATE ON "public"."knowledge_chunks" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_learned_thresholds_updated_at" BEFORE UPDATE ON "public"."learned_thresholds" FOR EACH ROW EXECUTE FUNCTION "public"."update_learned_thresholds_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_pending_contacts_updated" BEFORE UPDATE ON "public"."pending_contacts" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_pk_updated" BEFORE UPDATE ON "public"."project_knowledge" FOR EACH ROW EXECUTE FUNCTION "public"."update_pk_timestamp"();



CREATE OR REPLACE TRIGGER "trigger_project_outcome_sync_delete" AFTER DELETE ON "public"."project_outcomes" FOR EACH ROW EXECUTE FUNCTION "public"."queue_project_outcome_sync"();



CREATE OR REPLACE TRIGGER "trigger_project_outcome_sync_insert" AFTER INSERT ON "public"."project_outcomes" FOR EACH ROW EXECUTE FUNCTION "public"."queue_project_outcome_sync"();



CREATE OR REPLACE TRIGGER "trigger_project_outcome_sync_update" AFTER UPDATE ON "public"."project_outcomes" FOR EACH ROW WHEN (("old".* IS DISTINCT FROM "new".*)) EXECUTE FUNCTION "public"."queue_project_outcome_sync"();



CREATE OR REPLACE TRIGGER "trigger_project_sync_delete" AFTER DELETE ON "public"."projects" FOR EACH ROW EXECUTE FUNCTION "public"."queue_project_sync"();



CREATE OR REPLACE TRIGGER "trigger_project_sync_insert" AFTER INSERT ON "public"."projects" FOR EACH ROW EXECUTE FUNCTION "public"."queue_project_sync"();



CREATE OR REPLACE TRIGGER "trigger_project_sync_update" AFTER UPDATE ON "public"."projects" FOR EACH ROW WHEN (("old".* IS DISTINCT FROM "new".*)) EXECUTE FUNCTION "public"."queue_project_sync"();



CREATE OR REPLACE TRIGGER "trigger_recommendation_outcomes_updated" BEFORE UPDATE ON "public"."recommendation_outcomes" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_relationship_health_updated" BEFORE UPDATE ON "public"."relationship_health" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_set_album_slug" BEFORE INSERT ON "public"."photo_albums" FOR EACH ROW EXECUTE FUNCTION "public"."set_album_slug"();



CREATE OR REPLACE TRIGGER "trigger_source_document_search" BEFORE INSERT OR UPDATE ON "public"."alma_source_documents" FOR EACH ROW EXECUTE FUNCTION "public"."update_source_document_search_vector"();



CREATE OR REPLACE TRIGGER "trigger_update_album_timestamp" BEFORE UPDATE ON "public"."photo_albums" FOR EACH ROW EXECUTE FUNCTION "public"."update_album_timestamp"();



CREATE OR REPLACE TRIGGER "trigger_update_alma_contexts_search_vector" BEFORE INSERT OR UPDATE ON "public"."alma_community_contexts" FOR EACH ROW EXECUTE FUNCTION "public"."update_alma_contexts_search_vector"();



CREATE OR REPLACE TRIGGER "trigger_update_alma_contexts_updated_at" BEFORE UPDATE ON "public"."alma_community_contexts" FOR EACH ROW EXECUTE FUNCTION "public"."update_alma_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_alma_evidence_search_vector" BEFORE INSERT OR UPDATE ON "public"."alma_evidence" FOR EACH ROW EXECUTE FUNCTION "public"."update_alma_evidence_search_vector"();



CREATE OR REPLACE TRIGGER "trigger_update_alma_evidence_updated_at" BEFORE UPDATE ON "public"."alma_evidence" FOR EACH ROW EXECUTE FUNCTION "public"."update_alma_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_alma_ingestion_jobs_updated_at" BEFORE UPDATE ON "public"."alma_ingestion_jobs" FOR EACH ROW EXECUTE FUNCTION "public"."update_alma_ingestion_jobs_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_alma_interventions_search_vector" BEFORE INSERT OR UPDATE ON "public"."alma_interventions" FOR EACH ROW EXECUTE FUNCTION "public"."update_alma_interventions_search_vector"();



CREATE OR REPLACE TRIGGER "trigger_update_alma_interventions_updated_at" BEFORE UPDATE ON "public"."alma_interventions" FOR EACH ROW EXECUTE FUNCTION "public"."update_alma_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_alma_outcomes_search_vector" BEFORE INSERT OR UPDATE ON "public"."alma_outcomes" FOR EACH ROW EXECUTE FUNCTION "public"."update_alma_outcomes_search_vector"();



CREATE OR REPLACE TRIGGER "trigger_update_alma_outcomes_updated_at" BEFORE UPDATE ON "public"."alma_outcomes" FOR EACH ROW EXECUTE FUNCTION "public"."update_alma_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_citation_count" AFTER INSERT OR DELETE ON "public"."alma_entity_sources" FOR EACH ROW EXECUTE FUNCTION "public"."update_citation_count"();



CREATE OR REPLACE TRIGGER "trigger_update_community_programs_search_vector" BEFORE INSERT OR UPDATE ON "public"."registered_services" FOR EACH ROW EXECUTE FUNCTION "public"."update_community_programs_search_vector"();



CREATE OR REPLACE TRIGGER "trigger_update_community_programs_updated_at" BEFORE UPDATE ON "public"."registered_services" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "trigger_update_email_financial_documents_updated_at" BEFORE UPDATE ON "public"."email_financial_documents" FOR EACH ROW EXECUTE FUNCTION "public"."update_email_financial_documents_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_migration_priority" BEFORE INSERT OR UPDATE OF "amount", "metadata", "confidence" ON "public"."discovered_subscriptions" FOR EACH ROW EXECUTE FUNCTION "public"."update_migration_priority"();



CREATE OR REPLACE TRIGGER "trigger_update_public_profiles_updated_at" BEFORE UPDATE ON "public"."public_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."update_public_profiles_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_raw_content_stats" AFTER INSERT ON "public"."alma_content_entities" FOR EACH ROW EXECUTE FUNCTION "public"."update_raw_content_stats"();



CREATE OR REPLACE TRIGGER "trigger_update_relationship_health" AFTER INSERT ON "public"."communications_history" FOR EACH ROW WHEN (("new"."ghl_contact_id" IS NOT NULL)) EXECUTE FUNCTION "public"."update_relationship_health"();



CREATE OR REPLACE TRIGGER "trigger_update_tag_usage" AFTER INSERT OR DELETE ON "public"."alma_entity_tags" FOR EACH ROW EXECUTE FUNCTION "public"."update_tag_usage_count"();



CREATE OR REPLACE TRIGGER "trigger_user_identities_updated" BEFORE UPDATE ON "public"."user_identities" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_user_profile_sync_delete" AFTER DELETE ON "public"."user_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."queue_user_profile_sync"();



CREATE OR REPLACE TRIGGER "trigger_user_profile_sync_insert" AFTER INSERT ON "public"."user_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."queue_user_profile_sync"();



CREATE OR REPLACE TRIGGER "trigger_user_profile_sync_update" AFTER UPDATE ON "public"."user_profiles" FOR EACH ROW WHEN (("old".* IS DISTINCT FROM "new".*)) EXECUTE FUNCTION "public"."queue_user_profile_sync"();



CREATE OR REPLACE TRIGGER "trigger_voice_notes_updated" BEFORE UPDATE ON "public"."voice_notes" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_webhook_sync_notification" AFTER INSERT ON "public"."sync_events" FOR EACH ROW EXECUTE FUNCTION "public"."notify_webhook_sync_event"();



CREATE OR REPLACE TRIGGER "trigger_weekly_reports_updated" BEFORE UPDATE ON "public"."alma_weekly_reports" FOR EACH ROW EXECUTE FUNCTION "public"."update_funding_opportunities_timestamp"();



CREATE OR REPLACE TRIGGER "update_agent_registry_updated_at" BEFORE UPDATE ON "public"."agent_registry" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_art_innovation_updated_at" BEFORE UPDATE ON "public"."art_innovation" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_articles_updated_at" BEFORE UPDATE ON "public"."articles" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_australian_frameworks_updated_at" BEFORE UPDATE ON "public"."australian_frameworks" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_authors_updated_at" BEFORE UPDATE ON "public"."authors" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_automated_insights_updated_at" BEFORE UPDATE ON "public"."automated_insights" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_best_practices_updated_at" BEFORE UPDATE ON "public"."best_practices" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_business_alerts_updated_at" BEFORE UPDATE ON "public"."business_alerts" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_cms_content_blocks_updated_at" BEFORE UPDATE ON "public"."cms_content_blocks" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_cms_pages_updated_at" BEFORE UPDATE ON "public"."cms_pages" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_compliance_tracking_updated_at" BEFORE UPDATE ON "public"."compliance_tracking" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_consent_records_updated_at" BEFORE UPDATE ON "public"."consent_records" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_contact_edges_updated_at" BEFORE UPDATE ON "public"."contact_edges" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_contact_intelligence_updated_at" BEFORE UPDATE ON "public"."contact_intelligence" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_contact_invites_updated_at" BEFORE UPDATE ON "public"."contact_invites" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_conversation_context_updated_at" BEFORE UPDATE ON "public"."conversation_context" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_decisions_updated_at" BEFORE UPDATE ON "public"."decisions" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_enrichment_reviews_updated_at" BEFORE UPDATE ON "public"."enrichment_reviews" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_entities_updated_at" BEFORE UPDATE ON "public"."entities" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_entity_relationships_updated_at" BEFORE UPDATE ON "public"."entity_relationships" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_event_registrations_updated_at" BEFORE UPDATE ON "public"."event_registrations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "update_events_updated_at" BEFORE UPDATE ON "public"."events" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "update_ghl_engagement_metrics_updated_at" BEFORE UPDATE ON "public"."ghl_engagement_metrics" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_grant_opportunities_updated_at" BEFORE UPDATE ON "public"."grant_opportunities" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_historical_inquiries_updated_at" BEFORE UPDATE ON "public"."historical_inquiries" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "update_interactions_updated_at" BEFORE UPDATE ON "public"."interactions" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_international_programs_updated_at" BEFORE UPDATE ON "public"."international_programs" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_knowledge_chunks_updated_at" BEFORE UPDATE ON "public"."knowledge_chunks" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_last_active_on_event" AFTER INSERT ON "public"."community_events" FOR EACH ROW WHEN (("new"."user_id" IS NOT NULL)) EXECUTE FUNCTION "public"."update_user_last_active"();



CREATE OR REPLACE TRIGGER "update_media_files_updated_at" BEFORE UPDATE ON "public"."media_files" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_media_items_updated_at" BEFORE UPDATE ON "public"."media_items" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_opportunities_updated_at" BEFORE UPDATE ON "public"."opportunities" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_org_members_updated_at" BEFORE UPDATE ON "public"."organization_members" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_organizations_profiles_updated_at" BEFORE UPDATE ON "public"."organizations_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_organizations_updated_at" BEFORE UPDATE ON "public"."organizations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_outreach_strategies_updated_at" BEFORE UPDATE ON "public"."outreach_strategies" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_pages_updated_at" BEFORE UPDATE ON "public"."pages" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_partner_impact_updated_at" BEFORE UPDATE ON "public"."partner_impact_metrics" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "update_partner_videos_updated_at" BEFORE UPDATE ON "public"."partner_videos" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();



CREATE OR REPLACE TRIGGER "update_platform_media_collections_timestamp" BEFORE UPDATE ON "public"."platform_media_collections" FOR EACH ROW EXECUTE FUNCTION "public"."update_platform_updated_at"();



CREATE OR REPLACE TRIGGER "update_platform_media_items_timestamp" BEFORE UPDATE ON "public"."platform_media_items" FOR EACH ROW EXECUTE FUNCTION "public"."update_platform_updated_at"();



CREATE OR REPLACE TRIGGER "update_platform_org_activity_on_media_insert" AFTER INSERT ON "public"."platform_media_items" FOR EACH ROW EXECUTE FUNCTION "public"."update_platform_organization_activity"();



CREATE OR REPLACE TRIGGER "update_platform_organizations_timestamp" BEFORE UPDATE ON "public"."platform_organizations" FOR EACH ROW EXECUTE FUNCTION "public"."update_platform_updated_at"();



CREATE OR REPLACE TRIGGER "update_profiles_updated_at" BEFORE UPDATE ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_project_contact_matches_updated_at" BEFORE UPDATE ON "public"."project_contact_matches" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_project_outcomes_updated_at" BEFORE UPDATE ON "public"."project_outcomes" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_projects_updated_at" BEFORE UPDATE ON "public"."projects" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_quotes_updated_at" BEFORE UPDATE ON "public"."quotes" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_research_items_updated_at" BEFORE UPDATE ON "public"."research_items" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_service_contacts_updated_at" BEFORE UPDATE ON "public"."service_contacts" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_service_locations_updated_at" BEFORE UPDATE ON "public"."service_locations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_story_analysis_updated_at" BEFORE UPDATE ON "public"."transcript_analysis" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_storytellers_updated_at" BEFORE UPDATE ON "public"."storytellers" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_suggestions_updated_at" BEFORE UPDATE ON "public"."content_link_suggestions" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_sync_state_updated_at" BEFORE UPDATE ON "public"."sync_state" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_themes_updated_at" BEFORE UPDATE ON "public"."themes" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_transcripts_updated_at" BEFORE UPDATE ON "public"."transcripts" FOR EACH ROW EXECUTE FUNCTION "public"."update_transcripts_updated_at"();



CREATE OR REPLACE TRIGGER "update_user_behavior_insights_updated_at" BEFORE UPDATE ON "public"."user_behavior_insights" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_user_community_engagement_updated_at" BEFORE UPDATE ON "public"."user_community_engagement" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_user_profiles_updated_at" BEFORE UPDATE ON "public"."user_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_user_project_preferences_updated_at" BEFORE UPDATE ON "public"."user_project_preferences" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_video_embeds_updated_at" BEFORE UPDATE ON "public"."video_embeds" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "wiki_page_versioning" BEFORE UPDATE ON "public"."wiki_pages" FOR EACH ROW EXECUTE FUNCTION "public"."wiki_page_create_version"();



CREATE OR REPLACE TRIGGER "wiki_pages_review_due" BEFORE INSERT OR UPDATE OF "last_reviewed_at", "review_frequency_days" ON "public"."wiki_pages" FOR EACH ROW EXECUTE FUNCTION "public"."wiki_pages_review_due_trigger"();



CREATE OR REPLACE TRIGGER "wiki_pages_search_update" BEFORE INSERT OR UPDATE OF "title", "excerpt", "content", "tags" ON "public"."wiki_pages" FOR EACH ROW EXECUTE FUNCTION "public"."wiki_pages_search_trigger"();



CREATE OR REPLACE TRIGGER "wiki_pages_updated_at" BEFORE UPDATE ON "public"."wiki_pages" FOR EACH ROW EXECUTE FUNCTION "public"."update_knowledge_version_timestamp"();



CREATE OR REPLACE TRIGGER "xero_invoices_updated_at" BEFORE UPDATE ON "public"."xero_invoices" FOR EACH ROW EXECUTE FUNCTION "public"."update_xero_invoice_timestamp"();



ALTER TABLE ONLY "public"."agent_audit_log"
    ADD CONSTRAINT "agent_audit_log_parent_audit_id_fkey" FOREIGN KEY ("parent_audit_id") REFERENCES "public"."agent_audit_log"("id");



ALTER TABLE ONLY "public"."agent_learnings"
    ADD CONSTRAINT "agent_learnings_agent_id_fkey" FOREIGN KEY ("agent_id") REFERENCES "public"."agents"("id");



ALTER TABLE ONLY "public"."agent_learnings"
    ADD CONSTRAINT "agent_learnings_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."agent_task_queue"("id");



ALTER TABLE ONLY "public"."agent_performance"
    ADD CONSTRAINT "agent_performance_agent_id_fkey" FOREIGN KEY ("agent_id") REFERENCES "public"."agents"("id");



ALTER TABLE ONLY "public"."agent_proposals"
    ADD CONSTRAINT "agent_proposals_action_id_fkey" FOREIGN KEY ("action_id") REFERENCES "public"."agent_actions"("id");



ALTER TABLE ONLY "public"."agent_proposals"
    ADD CONSTRAINT "agent_proposals_parent_proposal_id_fkey" FOREIGN KEY ("parent_proposal_id") REFERENCES "public"."agent_proposals"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."agent_requests"
    ADD CONSTRAINT "agent_requests_source_agent_fkey" FOREIGN KEY ("source_agent") REFERENCES "public"."agent_registry"("agent_id");



ALTER TABLE ONLY "public"."agent_requests"
    ADD CONSTRAINT "agent_requests_target_agent_fkey" FOREIGN KEY ("target_agent") REFERENCES "public"."agent_registry"("agent_id");



ALTER TABLE ONLY "public"."agent_task_queue"
    ADD CONSTRAINT "agent_task_queue_assigned_agent_fkey" FOREIGN KEY ("assigned_agent") REFERENCES "public"."agents"("id");



ALTER TABLE ONLY "public"."agentic_chat"
    ADD CONSTRAINT "agentic_chat_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."agentic_projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."agentic_chat"
    ADD CONSTRAINT "agentic_chat_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."agentic_tasks"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."agentic_tasks"
    ADD CONSTRAINT "agentic_tasks_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."agentic_projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."agentic_work_log"
    ADD CONSTRAINT "agentic_work_log_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."agentic_projects"("id");



ALTER TABLE ONLY "public"."agentic_work_log"
    ADD CONSTRAINT "agentic_work_log_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."agentic_tasks"("id");



ALTER TABLE ONLY "public"."ai_content_verifications"
    ADD CONSTRAINT "ai_content_verifications_elder_reviewed_by_fkey" FOREIGN KEY ("elder_reviewed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."ai_content_verifications"
    ADD CONSTRAINT "ai_content_verifications_verified_by_fkey" FOREIGN KEY ("verified_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."ai_discoveries"
    ADD CONSTRAINT "ai_discoveries_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ai_discoveries"
    ADD CONSTRAINT "ai_discoveries_transcript_id_fkey" FOREIGN KEY ("transcript_id") REFERENCES "public"."transcripts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_content_entities"
    ADD CONSTRAINT "alma_content_entities_raw_content_id_fkey" FOREIGN KEY ("raw_content_id") REFERENCES "public"."alma_raw_content"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_entity_sources"
    ADD CONSTRAINT "alma_entity_sources_source_document_id_fkey" FOREIGN KEY ("source_document_id") REFERENCES "public"."alma_source_documents"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_entity_tags"
    ADD CONSTRAINT "alma_entity_tags_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "public"."alma_tags"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_evidence"
    ADD CONSTRAINT "alma_evidence_author_profile_id_fkey" FOREIGN KEY ("author_profile_id") REFERENCES "public"."public_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."alma_evidence_outcomes"
    ADD CONSTRAINT "alma_evidence_outcomes_evidence_id_fkey" FOREIGN KEY ("evidence_id") REFERENCES "public"."alma_evidence"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_evidence_outcomes"
    ADD CONSTRAINT "alma_evidence_outcomes_outcome_id_fkey" FOREIGN KEY ("outcome_id") REFERENCES "public"."alma_outcomes"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_extraction_patterns"
    ADD CONSTRAINT "alma_extraction_patterns_superseded_by_fkey" FOREIGN KEY ("superseded_by") REFERENCES "public"."alma_extraction_patterns"("id");



ALTER TABLE ONLY "public"."alma_funding_applications"
    ADD CONSTRAINT "alma_funding_applications_opportunity_id_fkey" FOREIGN KEY ("opportunity_id") REFERENCES "public"."alma_funding_opportunities"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_funding_applications"
    ADD CONSTRAINT "alma_funding_applications_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."alma_intervention_contexts"
    ADD CONSTRAINT "alma_intervention_contexts_context_id_fkey" FOREIGN KEY ("context_id") REFERENCES "public"."alma_community_contexts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_intervention_contexts"
    ADD CONSTRAINT "alma_intervention_contexts_intervention_id_fkey" FOREIGN KEY ("intervention_id") REFERENCES "public"."alma_interventions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_intervention_evidence"
    ADD CONSTRAINT "alma_intervention_evidence_evidence_id_fkey" FOREIGN KEY ("evidence_id") REFERENCES "public"."alma_evidence"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_intervention_evidence"
    ADD CONSTRAINT "alma_intervention_evidence_intervention_id_fkey" FOREIGN KEY ("intervention_id") REFERENCES "public"."alma_interventions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_intervention_funding"
    ADD CONSTRAINT "alma_intervention_funding_funding_data_id_fkey" FOREIGN KEY ("funding_data_id") REFERENCES "public"."alma_funding_data"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."alma_intervention_funding"
    ADD CONSTRAINT "alma_intervention_funding_intervention_id_fkey" FOREIGN KEY ("intervention_id") REFERENCES "public"."alma_interventions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_intervention_outcomes"
    ADD CONSTRAINT "alma_intervention_outcomes_intervention_id_fkey" FOREIGN KEY ("intervention_id") REFERENCES "public"."alma_interventions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_intervention_outcomes"
    ADD CONSTRAINT "alma_intervention_outcomes_outcome_id_fkey" FOREIGN KEY ("outcome_id") REFERENCES "public"."alma_outcomes"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_intervention_profiles"
    ADD CONSTRAINT "alma_intervention_profiles_intervention_id_fkey" FOREIGN KEY ("intervention_id") REFERENCES "public"."alma_interventions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_intervention_profiles"
    ADD CONSTRAINT "alma_intervention_profiles_public_profile_id_fkey" FOREIGN KEY ("public_profile_id") REFERENCES "public"."public_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_interventions"
    ADD CONSTRAINT "alma_interventions_linked_community_program_id_fkey" FOREIGN KEY ("linked_community_program_id") REFERENCES "public"."registered_services"("id");



ALTER TABLE ONLY "public"."alma_interventions"
    ADD CONSTRAINT "alma_interventions_linked_service_id_fkey" FOREIGN KEY ("linked_service_id") REFERENCES "public"."services"("id");



ALTER TABLE ONLY "public"."alma_interventions"
    ADD CONSTRAINT "alma_interventions_operating_organization_id_fkey" FOREIGN KEY ("operating_organization_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."alma_interventions"
    ADD CONSTRAINT "alma_interventions_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."alma_media_articles"
    ADD CONSTRAINT "alma_media_articles_job_id_fkey" FOREIGN KEY ("job_id") REFERENCES "public"."alma_ingestion_jobs"("id");



ALTER TABLE ONLY "public"."alma_program_interventions"
    ADD CONSTRAINT "alma_program_interventions_intervention_id_fkey" FOREIGN KEY ("intervention_id") REFERENCES "public"."alma_interventions"("id");



ALTER TABLE ONLY "public"."alma_program_interventions"
    ADD CONSTRAINT "alma_program_interventions_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."alma_government_programs"("id");



ALTER TABLE ONLY "public"."alma_report_deliveries"
    ADD CONSTRAINT "alma_report_deliveries_recipient_user_id_fkey" FOREIGN KEY ("recipient_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."alma_report_deliveries"
    ADD CONSTRAINT "alma_report_deliveries_report_id_fkey" FOREIGN KEY ("report_id") REFERENCES "public"."alma_weekly_reports"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_report_deliveries"
    ADD CONSTRAINT "alma_report_deliveries_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."alma_report_subscriptions"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."alma_report_subscriptions"
    ADD CONSTRAINT "alma_report_subscriptions_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."alma_report_subscriptions"
    ADD CONSTRAINT "alma_report_subscriptions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_research_findings"
    ADD CONSTRAINT "alma_research_findings_session_id_fkey" FOREIGN KEY ("session_id") REFERENCES "public"."alma_research_sessions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_research_sessions"
    ADD CONSTRAINT "alma_research_sessions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."alma_research_tool_logs"
    ADD CONSTRAINT "alma_research_tool_logs_session_id_fkey" FOREIGN KEY ("session_id") REFERENCES "public"."alma_research_sessions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."alma_scrape_history"
    ADD CONSTRAINT "alma_scrape_history_pattern_id_fkey" FOREIGN KEY ("pattern_id") REFERENCES "public"."alma_extraction_patterns"("id");



ALTER TABLE ONLY "public"."alma_scrape_history"
    ADD CONSTRAINT "alma_scrape_history_source_id_fkey" FOREIGN KEY ("source_id") REFERENCES "public"."alma_source_registry"("id");



ALTER TABLE ONLY "public"."alma_tags"
    ADD CONSTRAINT "alma_tags_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "public"."alma_tags"("id");



ALTER TABLE ONLY "public"."alma_usage_log"
    ADD CONSTRAINT "alma_usage_log_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."alma_weekly_reports"
    ADD CONSTRAINT "alma_weekly_reports_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."analysis_jobs"
    ADD CONSTRAINT "analysis_jobs_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."analysis_jobs"
    ADD CONSTRAINT "analysis_jobs_transcript_id_fkey" FOREIGN KEY ("transcript_id") REFERENCES "public"."transcripts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."art_innovation"
    ADD CONSTRAINT "art_innovation_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."art_innovation_profiles"
    ADD CONSTRAINT "art_innovation_profiles_art_innovation_id_fkey" FOREIGN KEY ("art_innovation_id") REFERENCES "public"."art_innovation"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."art_innovation_profiles"
    ADD CONSTRAINT "art_innovation_profiles_public_profile_id_fkey" FOREIGN KEY ("public_profile_id") REFERENCES "public"."public_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."art_innovation"
    ADD CONSTRAINT "art_innovation_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."registered_services"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."article_locations"
    ADD CONSTRAINT "article_locations_article_id_fkey" FOREIGN KEY ("article_id") REFERENCES "public"."articles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."article_related_art"
    ADD CONSTRAINT "article_related_art_art_innovation_id_fkey" FOREIGN KEY ("art_innovation_id") REFERENCES "public"."art_innovation"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."article_related_art"
    ADD CONSTRAINT "article_related_art_article_id_fkey" FOREIGN KEY ("article_id") REFERENCES "public"."articles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."article_related_articles"
    ADD CONSTRAINT "article_related_articles_article_id_fkey" FOREIGN KEY ("article_id") REFERENCES "public"."articles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."article_related_articles"
    ADD CONSTRAINT "article_related_articles_related_article_id_fkey" FOREIGN KEY ("related_article_id") REFERENCES "public"."articles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."article_related_evidence"
    ADD CONSTRAINT "article_related_evidence_article_id_fkey" FOREIGN KEY ("article_id") REFERENCES "public"."articles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."article_related_evidence"
    ADD CONSTRAINT "article_related_evidence_evidence_id_fkey" FOREIGN KEY ("evidence_id") REFERENCES "public"."alma_evidence"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."article_related_interventions"
    ADD CONSTRAINT "article_related_interventions_article_id_fkey" FOREIGN KEY ("article_id") REFERENCES "public"."articles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."article_related_interventions"
    ADD CONSTRAINT "article_related_interventions_intervention_id_fkey" FOREIGN KEY ("intervention_id") REFERENCES "public"."alma_interventions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."article_related_programs"
    ADD CONSTRAINT "article_related_programs_article_id_fkey" FOREIGN KEY ("article_id") REFERENCES "public"."articles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."article_related_programs"
    ADD CONSTRAINT "article_related_programs_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."registered_services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."article_related_services"
    ADD CONSTRAINT "article_related_services_article_id_fkey" FOREIGN KEY ("article_id") REFERENCES "public"."articles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."article_related_services"
    ADD CONSTRAINT "article_related_services_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."article_tags"
    ADD CONSTRAINT "article_tags_article_id_fkey" FOREIGN KEY ("article_id") REFERENCES "public"."articles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."articles"
    ADD CONSTRAINT "articles_author_id_fkey" FOREIGN KEY ("author_id") REFERENCES "public"."public_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."audit_logs"
    ADD CONSTRAINT "audit_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id");



ALTER TABLE ONLY "public"."authors"
    ADD CONSTRAINT "authors_public_profile_id_fkey" FOREIGN KEY ("public_profile_id") REFERENCES "public"."public_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."autonomous_executions"
    ADD CONSTRAINT "autonomous_executions_action_id_fkey" FOREIGN KEY ("action_id") REFERENCES "public"."agent_actions"("id");



ALTER TABLE ONLY "public"."billing_invoice_lines"
    ADD CONSTRAINT "billing_invoice_lines_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."billing_invoices"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."billing_invoice_lines"
    ADD CONSTRAINT "billing_invoice_lines_price_id_fkey" FOREIGN KEY ("price_id") REFERENCES "public"."billing_prices"("id");



ALTER TABLE ONLY "public"."billing_invoice_lines"
    ADD CONSTRAINT "billing_invoice_lines_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."billing_products"("id");



ALTER TABLE ONLY "public"."billing_invoices"
    ADD CONSTRAINT "billing_invoices_customer_id_fkey" FOREIGN KEY ("customer_id") REFERENCES "public"."billing_customers"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."billing_invoices"
    ADD CONSTRAINT "billing_invoices_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."billing_subscriptions"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."billing_payments"
    ADD CONSTRAINT "billing_payments_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."billing_invoices"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."billing_prices"
    ADD CONSTRAINT "billing_prices_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."billing_products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."billing_subscription_items"
    ADD CONSTRAINT "billing_subscription_items_price_id_fkey" FOREIGN KEY ("price_id") REFERENCES "public"."billing_prices"("id");



ALTER TABLE ONLY "public"."billing_subscription_items"
    ADD CONSTRAINT "billing_subscription_items_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."billing_subscriptions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."billing_subscriptions"
    ADD CONSTRAINT "billing_subscriptions_customer_id_fkey" FOREIGN KEY ("customer_id") REFERENCES "public"."billing_customers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."billing_tax_settings"
    ADD CONSTRAINT "billing_tax_settings_default_tax_rate_id_fkey" FOREIGN KEY ("default_tax_rate_id") REFERENCES "public"."billing_tax_rates"("id");



ALTER TABLE ONLY "public"."blog_comments"
    ADD CONSTRAINT "blog_comments_author_id_fkey" FOREIGN KEY ("author_id") REFERENCES "public"."public_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."blog_comments"
    ADD CONSTRAINT "blog_comments_blog_post_id_fkey" FOREIGN KEY ("blog_post_id") REFERENCES "public"."blog_posts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."blog_comments"
    ADD CONSTRAINT "blog_comments_parent_comment_id_fkey" FOREIGN KEY ("parent_comment_id") REFERENCES "public"."blog_comments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."blog_content_links"
    ADD CONSTRAINT "blog_content_links_art_id_fkey" FOREIGN KEY ("art_id") REFERENCES "public"."art_innovation"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."blog_content_links"
    ADD CONSTRAINT "blog_content_links_blog_post_id_fkey" FOREIGN KEY ("blog_post_id") REFERENCES "public"."blog_posts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."blog_content_links"
    ADD CONSTRAINT "blog_content_links_profile_id_fkey" FOREIGN KEY ("profile_id") REFERENCES "public"."public_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."blog_content_links"
    ADD CONSTRAINT "blog_content_links_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."registered_services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."blog_content_links"
    ADD CONSTRAINT "blog_content_links_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."blog_content_links"
    ADD CONSTRAINT "blog_content_links_story_id_fkey" FOREIGN KEY ("story_id") REFERENCES "public"."articles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."blog_media"
    ADD CONSTRAINT "blog_media_blog_post_id_fkey" FOREIGN KEY ("blog_post_id") REFERENCES "public"."blog_posts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."blog_posts"
    ADD CONSTRAINT "blog_posts_author_id_fkey" FOREIGN KEY ("author_id") REFERENCES "public"."public_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."blog_posts_profiles"
    ADD CONSTRAINT "blog_posts_profiles_blog_post_id_fkey" FOREIGN KEY ("blog_post_id") REFERENCES "public"."blog_posts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."blog_posts_profiles"
    ADD CONSTRAINT "blog_posts_profiles_public_profile_id_fkey" FOREIGN KEY ("public_profile_id") REFERENCES "public"."public_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."bookkeeping_project_links"
    ADD CONSTRAINT "bookkeeping_project_links_transaction_id_fkey" FOREIGN KEY ("transaction_id") REFERENCES "public"."bookkeeping_transactions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ce_brand_analyses"
    ADD CONSTRAINT "ce_brand_analyses_content_id_fkey" FOREIGN KEY ("content_id") REFERENCES "public"."ce_stories"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."channel_messages"
    ADD CONSTRAINT "channel_messages_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."agent_task_queue"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."cms_content_blocks"
    ADD CONSTRAINT "cms_content_blocks_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id");



ALTER TABLE ONLY "public"."cms_media"
    ADD CONSTRAINT "cms_media_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id");



ALTER TABLE ONLY "public"."cms_pages"
    ADD CONSTRAINT "cms_pages_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id");



ALTER TABLE ONLY "public"."coe_key_people"
    ADD CONSTRAINT "coe_key_people_profile_id_fkey" FOREIGN KEY ("profile_id") REFERENCES "public"."public_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."collection_media"
    ADD CONSTRAINT "collection_media_collection_id_fkey" FOREIGN KEY ("collection_id") REFERENCES "public"."media_collections"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."collection_media"
    ADD CONSTRAINT "collection_media_media_id_fkey" FOREIGN KEY ("media_id") REFERENCES "public"."media_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."communications_history"
    ADD CONSTRAINT "communications_history_from_identity_fkey" FOREIGN KEY ("from_identity") REFERENCES "public"."user_identities"("id");



ALTER TABLE ONLY "public"."communications_history"
    ADD CONSTRAINT "communications_history_ghl_contact_id_fkey" FOREIGN KEY ("ghl_contact_id") REFERENCES "public"."ghl_contacts"("ghl_id");



ALTER TABLE ONLY "public"."communications_history"
    ADD CONSTRAINT "communications_history_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "public"."communications_history"("id");



ALTER TABLE ONLY "public"."community_connections"
    ADD CONSTRAINT "community_connections_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."community_events"
    ADD CONSTRAINT "community_events_outcome_id_fkey" FOREIGN KEY ("outcome_id") REFERENCES "public"."project_outcomes"("id");



ALTER TABLE ONLY "public"."community_events"
    ADD CONSTRAINT "community_events_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id");



ALTER TABLE ONLY "public"."community_feedback"
    ADD CONSTRAINT "community_feedback_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."community_feedback"
    ADD CONSTRAINT "community_feedback_submitted_by_fkey" FOREIGN KEY ("submitted_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."registered_services"
    ADD CONSTRAINT "community_programs_alma_intervention_id_fkey" FOREIGN KEY ("alma_intervention_id") REFERENCES "public"."alma_interventions"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."registered_services"
    ADD CONSTRAINT "community_programs_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."registered_services_profiles"
    ADD CONSTRAINT "community_programs_profiles_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."registered_services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."registered_services_profiles"
    ADD CONSTRAINT "community_programs_profiles_public_profile_id_fkey" FOREIGN KEY ("public_profile_id") REFERENCES "public"."public_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."registered_services"
    ADD CONSTRAINT "community_programs_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."consent_management"
    ADD CONSTRAINT "consent_management_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."consent_records"
    ADD CONSTRAINT "consent_records_recorded_by_fkey" FOREIGN KEY ("recorded_by") REFERENCES "public"."profiles"("id");



ALTER TABLE ONLY "public"."consent_records"
    ADD CONSTRAINT "consent_records_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."consent_records"
    ADD CONSTRAINT "consent_records_witnessed_by_fkey" FOREIGN KEY ("witnessed_by") REFERENCES "public"."profiles"("id");



ALTER TABLE ONLY "public"."contact_intelligence_scores"
    ADD CONSTRAINT "contact_intelligence_scores_person_id_fkey" FOREIGN KEY ("person_id") REFERENCES "public"."person_identity_map"("person_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."contact_invites"
    ADD CONSTRAINT "contact_invites_opportunity_id_fkey" FOREIGN KEY ("opportunity_id") REFERENCES "public"."opportunities"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."contact_project_links"
    ADD CONSTRAINT "contact_project_links_entity_id_fkey" FOREIGN KEY ("entity_id") REFERENCES "public"."canonical_entities"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."content_link_suggestions"
    ADD CONSTRAINT "content_link_suggestions_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."cultural_protocols"
    ADD CONSTRAINT "cultural_protocols_ghl_contact_id_fkey" FOREIGN KEY ("ghl_contact_id") REFERENCES "public"."ghl_contacts"("ghl_id");



ALTER TABLE ONLY "public"."decision_outcomes"
    ADD CONSTRAINT "decision_outcomes_decision_id_fkey" FOREIGN KEY ("decision_id") REFERENCES "public"."decisions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."decision_traces"
    ADD CONSTRAINT "decision_traces_parent_decision_id_fkey" FOREIGN KEY ("parent_decision_id") REFERENCES "public"."decision_traces"("id");



ALTER TABLE ONLY "public"."donations"
    ADD CONSTRAINT "donations_ghl_contact_id_fkey" FOREIGN KEY ("ghl_contact_id") REFERENCES "public"."ghl_contacts"("ghl_id");



ALTER TABLE ONLY "public"."elder_review_queue"
    ADD CONSTRAINT "elder_review_queue_assigned_to_fkey" FOREIGN KEY ("assigned_to") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."elder_review_queue"
    ADD CONSTRAINT "elder_review_queue_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."elder_review_queue"
    ADD CONSTRAINT "elder_review_queue_submitted_by_fkey" FOREIGN KEY ("submitted_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."elder_review_queue"
    ADD CONSTRAINT "elder_review_queue_verification_id_fkey" FOREIGN KEY ("verification_id") REFERENCES "public"."ai_content_verifications"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."email_financial_documents"
    ADD CONSTRAINT "email_financial_documents_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."discovered_subscriptions"("id");



ALTER TABLE ONLY "public"."enrichment_reviews"
    ADD CONSTRAINT "enrichment_reviews_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."entity_identifiers"
    ADD CONSTRAINT "entity_identifiers_entity_id_fkey" FOREIGN KEY ("entity_id") REFERENCES "public"."canonical_entities"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."entity_mappings"
    ADD CONSTRAINT "entity_mappings_entity_id_fkey" FOREIGN KEY ("entity_id") REFERENCES "public"."entities"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."entity_merge_log"
    ADD CONSTRAINT "entity_merge_log_surviving_entity_id_fkey" FOREIGN KEY ("surviving_entity_id") REFERENCES "public"."canonical_entities"("id");



ALTER TABLE ONLY "public"."entity_potential_matches"
    ADD CONSTRAINT "entity_potential_matches_entity_a_id_fkey" FOREIGN KEY ("entity_a_id") REFERENCES "public"."canonical_entities"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."entity_potential_matches"
    ADD CONSTRAINT "entity_potential_matches_entity_b_id_fkey" FOREIGN KEY ("entity_b_id") REFERENCES "public"."canonical_entities"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."event_registrations"
    ADD CONSTRAINT "event_registrations_event_id_fkey" FOREIGN KEY ("event_id") REFERENCES "public"."events"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."events"
    ADD CONSTRAINT "events_node_id_fkey" FOREIGN KEY ("node_id") REFERENCES "public"."justicehub_nodes"("id");



ALTER TABLE ONLY "public"."exa_enrichment_queue"
    ADD CONSTRAINT "exa_enrichment_queue_person_id_fkey" FOREIGN KEY ("person_id") REFERENCES "public"."person_identity_map"("person_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exa_linkedin_profiles"
    ADD CONSTRAINT "exa_linkedin_profiles_person_id_fkey" FOREIGN KEY ("person_id") REFERENCES "public"."person_identity_map"("person_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exa_media_mentions"
    ADD CONSTRAINT "exa_media_mentions_person_id_fkey" FOREIGN KEY ("person_id") REFERENCES "public"."person_identity_map"("person_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."facility_partnerships"
    ADD CONSTRAINT "facility_partnerships_facility_id_fkey" FOREIGN KEY ("facility_id") REFERENCES "public"."youth_detention_facilities"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."facility_partnerships"
    ADD CONSTRAINT "facility_partnerships_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."facility_partnerships"
    ADD CONSTRAINT "facility_partnerships_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."registered_services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."facility_partnerships"
    ADD CONSTRAINT "facility_partnerships_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."facility_statistics"
    ADD CONSTRAINT "facility_statistics_facility_id_fkey" FOREIGN KEY ("facility_id") REFERENCES "public"."youth_detention_facilities"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."linkedin_contacts"
    ADD CONSTRAINT "fk_linkedin_contacts_person" FOREIGN KEY ("person_id") REFERENCES "public"."person_identity_map"("person_id");



ALTER TABLE ONLY "public"."ghl_engagement_metrics"
    ADD CONSTRAINT "ghl_engagement_metrics_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."linkedin_contacts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ghl_engagement_metrics"
    ADD CONSTRAINT "ghl_engagement_metrics_person_id_fkey" FOREIGN KEY ("person_id") REFERENCES "public"."person_identity_map"("person_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ghl_opportunities"
    ADD CONSTRAINT "ghl_opportunities_ghl_contact_id_fkey" FOREIGN KEY ("ghl_contact_id") REFERENCES "public"."ghl_contacts"("ghl_id");



ALTER TABLE ONLY "public"."gmail_auth_tokens"
    ADD CONSTRAINT "gmail_auth_tokens_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."gmail_sync_state"
    ADD CONSTRAINT "gmail_sync_state_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."gmail_auth_tokens"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."goal_metrics"
    ADD CONSTRAINT "goal_metrics_goal_id_fkey" FOREIGN KEY ("goal_id") REFERENCES "public"."goals_2026"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."goal_updates"
    ADD CONSTRAINT "goal_updates_goal_id_fkey" FOREIGN KEY ("goal_id") REFERENCES "public"."goals_2026"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."grant_financial_tracking"
    ADD CONSTRAINT "grant_financial_tracking_opportunity_id_fkey" FOREIGN KEY ("opportunity_id") REFERENCES "public"."ghl_opportunities"("id");



ALTER TABLE ONLY "public"."health_alerts"
    ADD CONSTRAINT "health_alerts_site_id_fkey" FOREIGN KEY ("site_id") REFERENCES "public"."ecosystem_sites"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."impact_evidence"
    ADD CONSTRAINT "impact_evidence_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."impact_stories"
    ADD CONSTRAINT "impact_stories_story_source_fkey" FOREIGN KEY ("story_source") REFERENCES "public"."transcripts"("id");



ALTER TABLE ONLY "public"."impact_stories"
    ADD CONSTRAINT "impact_stories_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."international_invitations"
    ADD CONSTRAINT "international_invitations_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."international_programs"("id");



ALTER TABLE ONLY "public"."international_programs"
    ADD CONSTRAINT "international_programs_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."justice_matrix_discovered"
    ADD CONSTRAINT "justice_matrix_discovered_approved_campaign_id_fkey" FOREIGN KEY ("approved_campaign_id") REFERENCES "public"."justice_matrix_campaigns"("id");



ALTER TABLE ONLY "public"."justice_matrix_discovered"
    ADD CONSTRAINT "justice_matrix_discovered_approved_case_id_fkey" FOREIGN KEY ("approved_case_id") REFERENCES "public"."justice_matrix_cases"("id");



ALTER TABLE ONLY "public"."justice_matrix_discovered"
    ADD CONSTRAINT "justice_matrix_discovered_approved_resource_id_fkey" FOREIGN KEY ("approved_resource_id") REFERENCES "public"."justice_matrix_resources"("id");



ALTER TABLE ONLY "public"."justice_matrix_discovered"
    ADD CONSTRAINT "justice_matrix_discovered_source_id_fkey" FOREIGN KEY ("source_id") REFERENCES "public"."justice_matrix_sources"("id");



ALTER TABLE ONLY "public"."justice_matrix_resources"
    ADD CONSTRAINT "justice_matrix_resources_campaign_id_fkey" FOREIGN KEY ("campaign_id") REFERENCES "public"."justice_matrix_campaigns"("id");



ALTER TABLE ONLY "public"."justice_matrix_resources"
    ADD CONSTRAINT "justice_matrix_resources_case_id_fkey" FOREIGN KEY ("case_id") REFERENCES "public"."justice_matrix_cases"("id");



ALTER TABLE ONLY "public"."justice_matrix_scrape_logs"
    ADD CONSTRAINT "justice_matrix_scrape_logs_source_id_fkey" FOREIGN KEY ("source_id") REFERENCES "public"."justice_matrix_sources"("id");



ALTER TABLE ONLY "public"."knowledge_extraction_queue"
    ADD CONSTRAINT "knowledge_extraction_queue_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."knowledge_extraction_queue"
    ADD CONSTRAINT "knowledge_extraction_queue_wiki_page_id_fkey" FOREIGN KEY ("wiki_page_id") REFERENCES "public"."wiki_pages"("id");



ALTER TABLE ONLY "public"."knowledge_sources"
    ADD CONSTRAINT "knowledge_sources_superseded_by_fkey" FOREIGN KEY ("superseded_by") REFERENCES "public"."knowledge_sources"("id");



ALTER TABLE ONLY "public"."knowledge_sources"
    ADD CONSTRAINT "knowledge_sources_verified_by_fkey" FOREIGN KEY ("verified_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."knowledge_versions"
    ADD CONSTRAINT "knowledge_versions_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."knowledge_versions"
    ADD CONSTRAINT "knowledge_versions_changed_by_fkey" FOREIGN KEY ("changed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."linkedin_project_connections"
    ADD CONSTRAINT "linkedin_project_connections_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."linkedin_contacts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."media_files"
    ADD CONSTRAINT "media_files_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id");



ALTER TABLE ONLY "public"."media_files"
    ADD CONSTRAINT "media_files_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id");



ALTER TABLE ONLY "public"."media_files"
    ADD CONSTRAINT "media_files_uploaded_by_fkey" FOREIGN KEY ("uploaded_by") REFERENCES "public"."profiles"("id");



ALTER TABLE ONLY "public"."media_items"
    ADD CONSTRAINT "media_items_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."media_library"
    ADD CONSTRAINT "media_library_uploaded_by_fkey" FOREIGN KEY ("uploaded_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."media_processing_jobs"
    ADD CONSTRAINT "media_processing_jobs_media_id_fkey" FOREIGN KEY ("media_id") REFERENCES "public"."media_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."media_usage"
    ADD CONSTRAINT "media_usage_media_id_fkey" FOREIGN KEY ("media_id") REFERENCES "public"."media_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_portrait_id_fkey" FOREIGN KEY ("portrait_id") REFERENCES "public"."portraits"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."notion_organization_people"
    ADD CONSTRAINT "notion_organization_people_notion_organizations_id_fkey" FOREIGN KEY ("notion_organizations_id") REFERENCES "public"."notion_organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."notion_organization_people"
    ADD CONSTRAINT "notion_organization_people_notion_people_id_fkey" FOREIGN KEY ("notion_people_id") REFERENCES "public"."notion_people"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."notion_project_organizations"
    ADD CONSTRAINT "notion_project_organizations_notion_organizations_id_fkey" FOREIGN KEY ("notion_organizations_id") REFERENCES "public"."notion_organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."notion_project_organizations"
    ADD CONSTRAINT "notion_project_organizations_notion_project_id_fkey" FOREIGN KEY ("notion_project_id") REFERENCES "public"."notion_projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."notion_project_people"
    ADD CONSTRAINT "notion_project_people_notion_people_id_fkey" FOREIGN KEY ("notion_people_id") REFERENCES "public"."notion_people"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."notion_project_people"
    ADD CONSTRAINT "notion_project_people_notion_project_id_fkey" FOREIGN KEY ("notion_project_id") REFERENCES "public"."notion_projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."organization_connections"
    ADD CONSTRAINT "organization_connections_mentioned_in_transcript_fkey" FOREIGN KEY ("mentioned_in_transcript") REFERENCES "public"."transcripts"("id");



ALTER TABLE ONLY "public"."organization_connections"
    ADD CONSTRAINT "organization_connections_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."organization_connections"
    ADD CONSTRAINT "organization_connections_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."organization_enrichment"
    ADD CONSTRAINT "organization_enrichment_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."organization_members"
    ADD CONSTRAINT "organization_members_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."organization_members"
    ADD CONSTRAINT "organization_members_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."organization_sync_log"
    ADD CONSTRAINT "organization_sync_log_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."organizations_profiles"
    ADD CONSTRAINT "organizations_profiles_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."organizations_profiles"
    ADD CONSTRAINT "organizations_profiles_public_profile_id_fkey" FOREIGN KEY ("public_profile_id") REFERENCES "public"."public_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."partner_contacts"
    ADD CONSTRAINT "partner_contacts_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."partner_external_links"
    ADD CONSTRAINT "partner_external_links_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."partner_goals"
    ADD CONSTRAINT "partner_goals_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."partner_impact_metrics"
    ADD CONSTRAINT "partner_impact_metrics_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."partner_photos"
    ADD CONSTRAINT "partner_photos_node_id_fkey" FOREIGN KEY ("node_id") REFERENCES "public"."justicehub_nodes"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."partner_photos"
    ADD CONSTRAINT "partner_photos_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."partner_site_locations"
    ADD CONSTRAINT "partner_site_locations_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."partner_stories"
    ADD CONSTRAINT "partner_stories_node_id_fkey" FOREIGN KEY ("node_id") REFERENCES "public"."justicehub_nodes"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."partner_stories"
    ADD CONSTRAINT "partner_stories_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."partner_storytellers"
    ADD CONSTRAINT "partner_storytellers_node_id_fkey" FOREIGN KEY ("node_id") REFERENCES "public"."justicehub_nodes"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."partner_storytellers"
    ADD CONSTRAINT "partner_storytellers_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."partner_videos"
    ADD CONSTRAINT "partner_videos_node_id_fkey" FOREIGN KEY ("node_id") REFERENCES "public"."justicehub_nodes"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."partner_videos"
    ADD CONSTRAINT "partner_videos_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."photo_album_photos"
    ADD CONSTRAINT "photo_album_photos_album_id_fkey" FOREIGN KEY ("album_id") REFERENCES "public"."photo_albums"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."photo_album_photos"
    ADD CONSTRAINT "photo_album_photos_photo_id_fkey" FOREIGN KEY ("photo_id") REFERENCES "public"."photos"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."photo_album_shares"
    ADD CONSTRAINT "photo_album_shares_album_id_fkey" FOREIGN KEY ("album_id") REFERENCES "public"."photo_albums"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."photo_albums"
    ADD CONSTRAINT "photo_albums_cover_photo_id_fkey" FOREIGN KEY ("cover_photo_id") REFERENCES "public"."photos"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."photo_albums"
    ADD CONSTRAINT "photo_albums_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."photo_storyteller_tags"
    ADD CONSTRAINT "photo_storyteller_tags_photo_id_fkey" FOREIGN KEY ("photo_id") REFERENCES "public"."photos"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."photo_storyteller_tags"
    ADD CONSTRAINT "photo_storyteller_tags_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."platform_collection_media"
    ADD CONSTRAINT "platform_collection_media_collection_id_fkey" FOREIGN KEY ("collection_id") REFERENCES "public"."platform_media_collections"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."platform_collection_media"
    ADD CONSTRAINT "platform_collection_media_media_id_fkey" FOREIGN KEY ("media_id") REFERENCES "public"."platform_media_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."platform_media_collections"
    ADD CONSTRAINT "platform_media_collections_cover_image_id_fkey" FOREIGN KEY ("cover_image_id") REFERENCES "public"."platform_media_items"("id");



ALTER TABLE ONLY "public"."platform_media_collections"
    ADD CONSTRAINT "platform_media_collections_platform_organization_id_fkey" FOREIGN KEY ("platform_organization_id") REFERENCES "public"."platform_organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."platform_media_items"
    ADD CONSTRAINT "platform_media_items_platform_organization_id_fkey" FOREIGN KEY ("platform_organization_id") REFERENCES "public"."platform_organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."platform_media_processing_jobs"
    ADD CONSTRAINT "platform_media_processing_jobs_media_id_fkey" FOREIGN KEY ("media_id") REFERENCES "public"."platform_media_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."platform_media_processing_jobs"
    ADD CONSTRAINT "platform_media_processing_jobs_platform_organization_id_fkey" FOREIGN KEY ("platform_organization_id") REFERENCES "public"."platform_organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."platform_media_usage"
    ADD CONSTRAINT "platform_media_usage_media_id_fkey" FOREIGN KEY ("media_id") REFERENCES "public"."platform_media_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."platform_media_usage"
    ADD CONSTRAINT "platform_media_usage_platform_organization_id_fkey" FOREIGN KEY ("platform_organization_id") REFERENCES "public"."platform_organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pmpp_knowledge"
    ADD CONSTRAINT "pmpp_knowledge_parent_method_id_fkey" FOREIGN KEY ("parent_method_id") REFERENCES "public"."pmpp_knowledge"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pmpp_knowledge"
    ADD CONSTRAINT "pmpp_knowledge_parent_practice_id_fkey" FOREIGN KEY ("parent_practice_id") REFERENCES "public"."pmpp_knowledge"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pmpp_knowledge"
    ADD CONSTRAINT "pmpp_knowledge_parent_principle_id_fkey" FOREIGN KEY ("parent_principle_id") REFERENCES "public"."pmpp_knowledge"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profile_appearances"
    ADD CONSTRAINT "profile_appearances_public_profile_id_fkey" FOREIGN KEY ("public_profile_id") REFERENCES "public"."public_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."profile_sync_log"
    ADD CONSTRAINT "profile_sync_log_public_profile_id_fkey" FOREIGN KEY ("public_profile_id") REFERENCES "public"."public_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_primary_organization_id_fkey" FOREIGN KEY ("primary_organization_id") REFERENCES "public"."organizations"("id");



ALTER TABLE ONLY "public"."program_outcomes"
    ADD CONSTRAINT "program_outcomes_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."international_programs"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."program_visits"
    ADD CONSTRAINT "program_visits_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."international_programs"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_activity_summary"
    ADD CONSTRAINT "project_activity_summary_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_contact_matches"
    ADD CONSTRAINT "project_contact_matches_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."linkedin_contacts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_contact_matches"
    ADD CONSTRAINT "project_contact_matches_person_id_fkey" FOREIGN KEY ("person_id") REFERENCES "public"."person_identity_map"("person_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_contributions"
    ADD CONSTRAINT "project_contributions_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_media_links"
    ADD CONSTRAINT "project_media_links_media_id_fkey" FOREIGN KEY ("media_id") REFERENCES "public"."media_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_outcome_updates"
    ADD CONSTRAINT "project_outcome_updates_project_outcome_id_fkey" FOREIGN KEY ("project_outcome_id") REFERENCES "public"."project_outcomes"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_outcomes"
    ADD CONSTRAINT "project_outcomes_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."projects"
    ADD CONSTRAINT "projects_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id");



ALTER TABLE ONLY "public"."public_profiles"
    ADD CONSTRAINT "public_profiles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."pulse_events"
    ADD CONSTRAINT "pulse_events_portrait_id_fkey" FOREIGN KEY ("portrait_id") REFERENCES "public"."portraits"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."quotes"
    ADD CONSTRAINT "quotes_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."quotes"
    ADD CONSTRAINT "quotes_transcript_id_fkey" FOREIGN KEY ("transcript_id") REFERENCES "public"."transcripts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."receipt_match_history"
    ADD CONSTRAINT "receipt_match_history_receipt_match_id_fkey" FOREIGN KEY ("receipt_match_id") REFERENCES "public"."receipt_matches"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."registered_services"
    ADD CONSTRAINT "registered_services_linked_service_id_fkey" FOREIGN KEY ("linked_service_id") REFERENCES "public"."services"("id");



ALTER TABLE ONLY "public"."relationship_health"
    ADD CONSTRAINT "relationship_health_ghl_contact_id_fkey" FOREIGN KEY ("ghl_contact_id") REFERENCES "public"."ghl_contacts"("ghl_id");



ALTER TABLE ONLY "public"."review_media_links"
    ADD CONSTRAINT "review_media_links_media_id_fkey" FOREIGN KEY ("media_id") REFERENCES "public"."media_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."review_projects"
    ADD CONSTRAINT "review_projects_hero_image_id_fkey" FOREIGN KEY ("hero_image_id") REFERENCES "public"."media_items"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."scraped_services"
    ADD CONSTRAINT "scraped_services_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."scraping_metadata"
    ADD CONSTRAINT "scraping_metadata_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."service_contacts"
    ADD CONSTRAINT "service_contacts_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."service_locations"
    ADD CONSTRAINT "service_locations_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."services"
    ADD CONSTRAINT "services_alma_intervention_id_fkey" FOREIGN KEY ("alma_intervention_id") REFERENCES "public"."alma_interventions"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."services"
    ADD CONSTRAINT "services_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."services"
    ADD CONSTRAINT "services_parent_service_id_fkey" FOREIGN KEY ("parent_service_id") REFERENCES "public"."services"("id");



ALTER TABLE ONLY "public"."services_profiles"
    ADD CONSTRAINT "services_profiles_public_profile_id_fkey" FOREIGN KEY ("public_profile_id") REFERENCES "public"."public_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."services_profiles"
    ADD CONSTRAINT "services_profiles_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."site_deployments"
    ADD CONSTRAINT "site_deployments_site_id_fkey" FOREIGN KEY ("site_id") REFERENCES "public"."ecosystem_sites"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."site_health_checks"
    ADD CONSTRAINT "site_health_checks_site_id_fkey" FOREIGN KEY ("site_id") REFERENCES "public"."ecosystem_sites"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."skills_evidence"
    ADD CONSTRAINT "skills_evidence_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stories"
    ADD CONSTRAINT "stories_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."stories"
    ADD CONSTRAINT "stories_public_profile_id_fkey" FOREIGN KEY ("public_profile_id") REFERENCES "public"."public_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."transcript_analysis"
    ADD CONSTRAINT "story_analysis_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "public"."profiles"("id");



ALTER TABLE ONLY "public"."story_analysis"
    ADD CONSTRAINT "story_analysis_reviewed_by_fkey1" FOREIGN KEY ("reviewed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."transcript_analysis"
    ADD CONSTRAINT "story_analysis_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."story_analysis"
    ADD CONSTRAINT "story_analysis_storyteller_id_fkey1" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."transcript_analysis"
    ADD CONSTRAINT "story_analysis_transcript_id_fkey" FOREIGN KEY ("transcript_id") REFERENCES "public"."transcripts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."story_analysis"
    ADD CONSTRAINT "story_analysis_transcript_id_fkey" FOREIGN KEY ("transcript_id") REFERENCES "public"."transcripts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."story_related_art"
    ADD CONSTRAINT "story_related_art_art_innovation_id_fkey" FOREIGN KEY ("art_innovation_id") REFERENCES "public"."art_innovation"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."story_related_art"
    ADD CONSTRAINT "story_related_art_story_id_fkey" FOREIGN KEY ("story_id") REFERENCES "public"."stories"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."story_related_interventions"
    ADD CONSTRAINT "story_related_interventions_intervention_id_fkey" FOREIGN KEY ("intervention_id") REFERENCES "public"."alma_interventions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."story_related_interventions"
    ADD CONSTRAINT "story_related_interventions_story_id_fkey" FOREIGN KEY ("story_id") REFERENCES "public"."stories"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."story_related_programs"
    ADD CONSTRAINT "story_related_programs_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."registered_services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."story_related_programs"
    ADD CONSTRAINT "story_related_programs_story_id_fkey" FOREIGN KEY ("story_id") REFERENCES "public"."stories"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."story_related_services"
    ADD CONSTRAINT "story_related_services_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."story_related_services"
    ADD CONSTRAINT "story_related_services_story_id_fkey" FOREIGN KEY ("story_id") REFERENCES "public"."stories"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."storyteller_ai_intelligence"
    ADD CONSTRAINT "storyteller_ai_intelligence_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."storyteller_connections"
    ADD CONSTRAINT "storyteller_connections_storyteller_a_fkey" FOREIGN KEY ("storyteller_a") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."storyteller_connections"
    ADD CONSTRAINT "storyteller_connections_storyteller_b_fkey" FOREIGN KEY ("storyteller_b") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."storyteller_media"
    ADD CONSTRAINT "storyteller_media_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."storyteller_videos"
    ADD CONSTRAINT "storyteller_videos_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."storytellers"
    ADD CONSTRAINT "storytellers_location_id_fkey" FOREIGN KEY ("location_id") REFERENCES "public"."locations"("id");



ALTER TABLE ONLY "public"."storytellers"
    ADD CONSTRAINT "storytellers_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id");



ALTER TABLE ONLY "public"."storytellers"
    ADD CONSTRAINT "storytellers_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id");



ALTER TABLE ONLY "public"."subscription_analytics"
    ADD CONSTRAINT "subscription_analytics_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."discovered_subscriptions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."subscription_history"
    ADD CONSTRAINT "subscription_history_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."subscriptions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."subscription_receipts"
    ADD CONSTRAINT "subscription_receipts_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."discovered_subscriptions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."suggestion_feedback"
    ADD CONSTRAINT "suggestion_feedback_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."suggestion_feedback"
    ADD CONSTRAINT "suggestion_feedback_suggestion_id_fkey" FOREIGN KEY ("suggestion_id") REFERENCES "public"."content_link_suggestions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."support_matches"
    ADD CONSTRAINT "support_matches_seeker_id_fkey" FOREIGN KEY ("seeker_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."support_matches"
    ADD CONSTRAINT "support_matches_supporter_id_fkey" FOREIGN KEY ("supporter_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."sync_queue"
    ADD CONSTRAINT "sync_queue_cultural_protocol_id_fkey" FOREIGN KEY ("cultural_protocol_id") REFERENCES "public"."cultural_protocols"("id");



ALTER TABLE ONLY "public"."themes"
    ADD CONSTRAINT "themes_parent_theme_id_fkey" FOREIGN KEY ("parent_theme_id") REFERENCES "public"."themes"("id");



ALTER TABLE ONLY "public"."training_dataset"
    ADD CONSTRAINT "training_dataset_verification_id_fkey" FOREIGN KEY ("verification_id") REFERENCES "public"."ai_content_verifications"("id");



ALTER TABLE ONLY "public"."transcripts"
    ADD CONSTRAINT "transcripts_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_community_engagement"
    ADD CONSTRAINT "user_community_engagement_user_profile_id_fkey" FOREIGN KEY ("user_profile_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_identities"
    ADD CONSTRAINT "user_identities_ghl_contact_id_fkey" FOREIGN KEY ("ghl_contact_id") REFERENCES "public"."ghl_contacts"("ghl_id");



ALTER TABLE ONLY "public"."user_project_preferences"
    ADD CONSTRAINT "user_project_preferences_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_project_preferences"
    ADD CONSTRAINT "user_project_preferences_user_profile_id_fkey" FOREIGN KEY ("user_profile_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."vendor_contact_log"
    ADD CONSTRAINT "vendor_contact_log_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."discovered_subscriptions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."voice_note_shares"
    ADD CONSTRAINT "voice_note_shares_shared_by_fkey" FOREIGN KEY ("shared_by") REFERENCES "public"."user_identities"("id");



ALTER TABLE ONLY "public"."voice_note_shares"
    ADD CONSTRAINT "voice_note_shares_shared_with_fkey" FOREIGN KEY ("shared_with") REFERENCES "public"."user_identities"("id");



ALTER TABLE ONLY "public"."voice_note_shares"
    ADD CONSTRAINT "voice_note_shares_voice_note_id_fkey" FOREIGN KEY ("voice_note_id") REFERENCES "public"."voice_notes"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."voice_notes"
    ADD CONSTRAINT "voice_notes_recorded_by_fkey" FOREIGN KEY ("recorded_by") REFERENCES "public"."user_identities"("id");



ALTER TABLE ONLY "public"."voice_notes"
    ADD CONSTRAINT "voice_notes_related_communication_id_fkey" FOREIGN KEY ("related_communication_id") REFERENCES "public"."communications_history"("id");



ALTER TABLE ONLY "public"."voice_notes"
    ADD CONSTRAINT "voice_notes_related_contact_id_fkey" FOREIGN KEY ("related_contact_id") REFERENCES "public"."ghl_contacts"("ghl_id");



ALTER TABLE ONLY "public"."voice_notes"
    ADD CONSTRAINT "voice_notes_reply_to_voice_note_id_fkey" FOREIGN KEY ("reply_to_voice_note_id") REFERENCES "public"."voice_notes"("id");



ALTER TABLE ONLY "public"."volunteer_hours"
    ADD CONSTRAINT "volunteer_hours_ghl_contact_id_fkey" FOREIGN KEY ("ghl_contact_id") REFERENCES "public"."ghl_contacts"("ghl_id");



ALTER TABLE ONLY "public"."wiki_articles"
    ADD CONSTRAINT "wiki_articles_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "public"."wiki_articles"("id");



ALTER TABLE ONLY "public"."wiki_notifications"
    ADD CONSTRAINT "wiki_notifications_queue_item_id_fkey" FOREIGN KEY ("queue_item_id") REFERENCES "public"."knowledge_extraction_queue"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."wiki_notifications"
    ADD CONSTRAINT "wiki_notifications_wiki_page_id_fkey" FOREIGN KEY ("wiki_page_id") REFERENCES "public"."wiki_pages"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."wiki_page_links"
    ADD CONSTRAINT "wiki_page_links_from_page_id_fkey" FOREIGN KEY ("from_page_id") REFERENCES "public"."wiki_pages"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."wiki_page_links"
    ADD CONSTRAINT "wiki_page_links_to_page_id_fkey" FOREIGN KEY ("to_page_id") REFERENCES "public"."wiki_pages"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."wiki_page_versions"
    ADD CONSTRAINT "wiki_page_versions_changed_by_fkey" FOREIGN KEY ("changed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."wiki_page_versions"
    ADD CONSTRAINT "wiki_page_versions_page_id_fkey" FOREIGN KEY ("page_id") REFERENCES "public"."wiki_pages"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."wiki_pages"
    ADD CONSTRAINT "wiki_pages_parent_method_id_fkey" FOREIGN KEY ("parent_method_id") REFERENCES "public"."wiki_pages"("id");



ALTER TABLE ONLY "public"."wiki_pages"
    ADD CONSTRAINT "wiki_pages_parent_practice_id_fkey" FOREIGN KEY ("parent_practice_id") REFERENCES "public"."wiki_pages"("id");



ALTER TABLE ONLY "public"."wiki_pages"
    ADD CONSTRAINT "wiki_pages_parent_principle_id_fkey" FOREIGN KEY ("parent_principle_id") REFERENCES "public"."wiki_pages"("id");



ALTER TABLE ONLY "public"."wiki_pages"
    ADD CONSTRAINT "wiki_pages_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."wiki_pages"
    ADD CONSTRAINT "wiki_pages_verified_by_fkey" FOREIGN KEY ("verified_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."wisdom_extracts"
    ADD CONSTRAINT "wisdom_extracts_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."wisdom_extracts"
    ADD CONSTRAINT "wisdom_extracts_transcript_analysis_id_fkey" FOREIGN KEY ("transcript_analysis_id") REFERENCES "public"."transcript_analysis"("id");



ALTER TABLE ONLY "public"."wisdom_insights"
    ADD CONSTRAINT "wisdom_insights_source_transcript_fkey" FOREIGN KEY ("source_transcript") REFERENCES "public"."transcripts"("id");



ALTER TABLE ONLY "public"."wisdom_insights"
    ADD CONSTRAINT "wisdom_insights_storyteller_id_fkey" FOREIGN KEY ("storyteller_id") REFERENCES "public"."storytellers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."xero_financial_alerts"
    ADD CONSTRAINT "xero_financial_alerts_related_invoice_id_fkey" FOREIGN KEY ("related_invoice_id") REFERENCES "public"."xero_invoices"("id");



CREATE POLICY "Active PMPP is viewable by everyone" ON "public"."pmpp_knowledge" FOR SELECT USING (("status" = 'active'::"text"));



CREATE POLICY "Active wiki pages are publicly readable" ON "public"."wiki_pages" FOR SELECT USING (("status" = 'active'::"text"));



CREATE POLICY "Admin read for discovered" ON "public"."justice_matrix_discovered" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Admin read for scrape logs" ON "public"."justice_matrix_scrape_logs" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Admins can delete profiles" ON "public"."public_profiles" FOR DELETE USING ("public"."is_admin"());



CREATE POLICY "Admins can do anything with media" ON "public"."media_library" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "auth"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND (("users"."raw_user_meta_data" ->> 'user_role'::"text") = 'admin'::"text")))));



CREATE POLICY "Admins can update any profile" ON "public"."public_profiles" FOR UPDATE USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



CREATE POLICY "Admins can view all profiles" ON "public"."public_profiles" FOR SELECT USING ("public"."is_admin"());



CREATE POLICY "Allow all deletes" ON "public"."portraits" FOR DELETE USING (true);



CREATE POLICY "Allow all for service role" ON "public"."ecosystem_sites" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Allow all for service role" ON "public"."goals_2026" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Allow all inserts" ON "public"."portraits" FOR INSERT WITH CHECK (true);



CREATE POLICY "Allow all reads" ON "public"."portraits" FOR SELECT USING (true);



CREATE POLICY "Allow all updates" ON "public"."portraits" FOR UPDATE USING (true);



CREATE POLICY "Allow anonymous insert harvest businesses" ON "public"."harvest_businesses" FOR INSERT TO "authenticated", "anon" WITH CHECK (true);



CREATE POLICY "Allow anonymous insert harvest events" ON "public"."harvest_events" FOR INSERT TO "authenticated", "anon" WITH CHECK (true);



CREATE POLICY "Allow authenticated read" ON "public"."linkedin_contacts" FOR SELECT USING (true);



CREATE POLICY "Allow authenticated read" ON "public"."person_identity_map" FOR SELECT USING (true);



CREATE POLICY "Allow authenticated read ghl_engagement_metrics" ON "public"."ghl_engagement_metrics" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Allow authenticated read notion_projects_cache" ON "public"."notion_projects_cache" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Allow authenticated read project_contact_matches" ON "public"."project_contact_matches" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Allow authenticated users to insert programs" ON "public"."registered_services" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Allow authenticated users to update programs" ON "public"."registered_services" FOR UPDATE TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "Allow public read access to community programs" ON "public"."registered_services" FOR SELECT TO "authenticated", "anon" USING (true);



CREATE POLICY "Allow public select approved harvest businesses" ON "public"."harvest_businesses" FOR SELECT TO "authenticated", "anon" USING (("status" = 'approved'::"text"));



CREATE POLICY "Allow public select approved harvest events" ON "public"."harvest_events" FOR SELECT TO "authenticated", "anon" USING (("status" = 'approved'::"text"));



CREATE POLICY "Allow service role all ghl_engagement_metrics" ON "public"."ghl_engagement_metrics" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Allow service role all notion_projects_cache" ON "public"."notion_projects_cache" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Allow service role all project_contact_matches" ON "public"."project_contact_matches" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Allow service role full access to harvest businesses" ON "public"."harvest_businesses" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Allow service role full access to harvest events" ON "public"."harvest_events" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Anon full access on conversation_context" ON "public"."conversation_context" USING (true);



CREATE POLICY "Anon read access on knowledge_chunks" ON "public"."knowledge_chunks" FOR SELECT USING (true);



CREATE POLICY "Anyone can create pulse events" ON "public"."pulse_events" FOR INSERT WITH CHECK (true);



CREATE POLICY "Anyone can send messages" ON "public"."messages" FOR INSERT WITH CHECK (true);



CREATE POLICY "Anyone can submit community feedback" ON "public"."community_feedback" FOR INSERT WITH CHECK (true);



CREATE POLICY "Anyone can subscribe to newsletter" ON "public"."newsletter_subscribers" FOR INSERT WITH CHECK (true);



CREATE POLICY "Anyone can track attribution events" ON "public"."story_attribution_events" FOR INSERT WITH CHECK (true);



CREATE POLICY "Anyone can view article-evidence links" ON "public"."article_related_evidence" FOR SELECT USING (true);



CREATE POLICY "Anyone can view article-intervention links" ON "public"."article_related_interventions" FOR SELECT USING (true);



CREATE POLICY "Anyone can view evidence-outcome links" ON "public"."alma_evidence_outcomes" FOR SELECT TO "authenticated", "anon" USING (true);



CREATE POLICY "Anyone can view funding opportunities" ON "public"."alma_funding_opportunities" FOR SELECT USING (true);



CREATE POLICY "Anyone can view intervention-profile links" ON "public"."alma_intervention_profiles" FOR SELECT USING (true);



CREATE POLICY "Anyone can view media" ON "public"."media_library" FOR SELECT USING (true);



CREATE POLICY "Anyone can view outcomes" ON "public"."alma_outcomes" FOR SELECT TO "authenticated", "anon" USING (true);



CREATE POLICY "Anyone can view public profiles" ON "public"."public_profiles" FOR SELECT USING (("is_public" = true));



CREATE POLICY "Anyone can view published reports" ON "public"."alma_weekly_reports" FOR SELECT USING (("status" = 'published'::"text"));



CREATE POLICY "Anyone can view story-intervention links" ON "public"."story_related_interventions" FOR SELECT USING (true);



CREATE POLICY "Art & Innovation projects are viewable by everyone" ON "public"."art_innovation" FOR SELECT USING (("status" = 'published'::"text"));



CREATE POLICY "Assigned elders can view their reviews" ON "public"."elder_review_queue" FOR SELECT USING ((("auth"."uid"() = "assigned_to") OR ("auth"."uid"() = "submitted_by")));



CREATE POLICY "Authenticated can manage reports" ON "public"."alma_weekly_reports" TO "authenticated" USING (true);



CREATE POLICY "Authenticated can view all reports" ON "public"."alma_weekly_reports" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated create findings" ON "public"."alma_research_findings" FOR INSERT WITH CHECK (true);



CREATE POLICY "Authenticated create sessions" ON "public"."alma_research_sessions" FOR INSERT WITH CHECK (true);



CREATE POLICY "Authenticated read access on contact_review_decisions" ON "public"."contact_review_decisions" FOR SELECT USING (true);



CREATE POLICY "Authenticated read access on entities" ON "public"."entities" FOR SELECT USING (true);



CREATE POLICY "Authenticated read access on entity_mappings" ON "public"."entity_mappings" FOR SELECT USING (true);



CREATE POLICY "Authenticated read access on ignored_email_patterns" ON "public"."ignored_email_patterns" FOR SELECT USING (true);



CREATE POLICY "Authenticated read access on learned_thresholds" ON "public"."learned_thresholds" FOR SELECT USING (true);



CREATE POLICY "Authenticated read access on recommendation_outcomes" ON "public"."recommendation_outcomes" FOR SELECT USING (true);



CREATE POLICY "Authenticated read access on tag_inference_rules" ON "public"."tag_inference_rules" FOR SELECT USING (true);



CREATE POLICY "Authenticated read access on xero_financial_alerts" ON "public"."xero_financial_alerts" FOR SELECT USING (true);



CREATE POLICY "Authenticated read access on xero_financial_snapshots" ON "public"."xero_financial_snapshots" FOR SELECT USING (true);



CREATE POLICY "Authenticated read access on xero_invoices" ON "public"."xero_invoices" FOR SELECT USING (true);



CREATE POLICY "Authenticated read exa_api_usage" ON "public"."exa_api_usage" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated read exa_company_intelligence" ON "public"."exa_company_intelligence" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated read exa_enrichment_queue" ON "public"."exa_enrichment_queue" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated read exa_linkedin_profiles" ON "public"."exa_linkedin_profiles" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated read exa_media_mentions" ON "public"."exa_media_mentions" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated read for content_entities" ON "public"."alma_content_entities" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated read for embeddings" ON "public"."alma_embeddings" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated read for entity_tags" ON "public"."alma_entity_tags" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated read for intervention_funding" ON "public"."alma_intervention_funding" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated read for metrics_history" ON "public"."alma_metrics_history" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated read for raw_content" ON "public"."alma_raw_content" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated read for sources" ON "public"."justice_matrix_sources" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can create PMPP" ON "public"."pmpp_knowledge" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can create article-evidence links" ON "public"."article_related_evidence" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can create article-intervention links" ON "public"."article_related_interventions" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can create blog posts" ON "public"."blog_posts" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."public_profiles"
  WHERE (("public_profiles"."id" = "blog_posts"."author_id") AND ("public_profiles"."user_id" = "auth"."uid"())))));



CREATE POLICY "Authenticated users can create intervention-profile links" ON "public"."alma_intervention_profiles" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can create knowledge versions" ON "public"."knowledge_versions" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can create sources" ON "public"."knowledge_sources" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can create story-intervention links" ON "public"."story_related_interventions" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can create verifications" ON "public"."ai_content_verifications" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can create wiki pages" ON "public"."wiki_pages" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can delete frameworks" ON "public"."australian_frameworks" FOR DELETE TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can delete research" ON "public"."research_items" FOR DELETE TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can delete their media" ON "public"."media_items" FOR DELETE TO "authenticated" USING ((("created_by" IS NULL) OR ("auth"."uid"() = "created_by")));



CREATE POLICY "Authenticated users can insert art & innovation projects" ON "public"."art_innovation" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Authenticated users can insert articles" ON "public"."articles" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Authenticated users can insert frameworks" ON "public"."australian_frameworks" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Authenticated users can insert funding opportunities" ON "public"."alma_funding_opportunities" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Authenticated users can insert international programs" ON "public"."international_programs" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can insert media" ON "public"."media_items" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Authenticated users can insert media" ON "public"."media_library" FOR INSERT TO "authenticated" WITH CHECK (("uploaded_by" = "auth"."uid"()));



CREATE POLICY "Authenticated users can insert research" ON "public"."research_items" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Authenticated users can manage applications" ON "public"."alma_funding_applications" TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can manage enrichments" ON "public"."enrichment_reviews" TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can manage media links" ON "public"."project_media_links" TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can manage video embeds" ON "public"."video_embeds" TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can read agent_registry" ON "public"."agent_registry" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can read agent_requests" ON "public"."agent_requests" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can read business agent queries" ON "public"."business_agent_queries" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can read business alerts" ON "public"."business_alerts" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can read compliance tracking" ON "public"."compliance_tracking" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can read contact enrichments" ON "public"."contact_enrichments" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can read contact intelligence" ON "public"."contact_intelligence" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can read contact interactions" ON "public"."contact_interactions" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can read grant opportunities" ON "public"."grant_opportunities" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can read outreach strategies" ON "public"."outreach_strategies" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can read project health analysis" ON "public"."project_health_analysis" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can read projects" ON "public"."projects" FOR SELECT USING ((("auth"."role"() = 'authenticated'::"text") OR ("auth"."role"() = 'service_role'::"text")));



CREATE POLICY "Authenticated users can read sprint_snapshots" ON "public"."sprint_snapshots" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can read storytellers with consent" ON "public"."storytellers" FOR SELECT USING (((("auth"."role"() = 'authenticated'::"text") OR ("auth"."role"() = 'service_role'::"text")) AND ("consent_given" = true)));



CREATE POLICY "Authenticated users can submit for elder review" ON "public"."elder_review_queue" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can update extraction queue" ON "public"."knowledge_extraction_queue" FOR UPDATE USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can update frameworks" ON "public"."australian_frameworks" FOR UPDATE TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "Authenticated users can update funding opportunities" ON "public"."alma_funding_opportunities" FOR UPDATE TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can update international programs" ON "public"."international_programs" FOR UPDATE USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can update research" ON "public"."research_items" FOR UPDATE TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "Authenticated users can update their media" ON "public"."media_items" FOR UPDATE TO "authenticated" USING ((("created_by" IS NULL) OR ("auth"."uid"() = "created_by")));



CREATE POLICY "Authenticated users can view applications" ON "public"."alma_funding_applications" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can view approved community interventions" ON "public"."alma_interventions" FOR SELECT TO "authenticated" USING ((("review_status" = ANY (ARRAY['Approved'::"text", 'Published'::"text"])) AND ("consent_level" = ANY (ARRAY['Public Knowledge Commons'::"text", 'Community Controlled'::"text"]))));



COMMENT ON POLICY "Authenticated users can view approved community interventions" ON "public"."alma_interventions" IS 'Community Controlled tier - visible to authenticated users when Approved';



CREATE POLICY "Authenticated users can view community contexts" ON "public"."alma_community_contexts" FOR SELECT TO "authenticated" USING (("consent_level" = ANY (ARRAY['Public Knowledge Commons'::"text", 'Community Controlled'::"text"])));



CREATE POLICY "Authenticated users can view community evidence" ON "public"."alma_evidence" FOR SELECT TO "authenticated" USING (("consent_level" = ANY (ARRAY['Public Knowledge Commons'::"text", 'Community Controlled'::"text"])));



CREATE POLICY "Authenticated users can view extraction queue" ON "public"."knowledge_extraction_queue" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can view feedback" ON "public"."community_feedback" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can view source sync status" ON "public"."knowledge_source_sync" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can view training data" ON "public"."training_dataset" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated write access for curated entries" ON "public"."review_curated_entries" USING (true) WITH CHECK (true);



CREATE POLICY "Authenticated write access for year settings" ON "public"."review_year_settings" USING (true) WITH CHECK (true);



CREATE POLICY "Best practices are viewable by everyone" ON "public"."best_practices" FOR SELECT USING (true);



CREATE POLICY "International programs are viewable by everyone" ON "public"."international_programs" FOR SELECT USING (("status" = 'published'::"text"));



CREATE POLICY "Knowledge is viewable by everyone" ON "public"."knowledge_versions" FOR SELECT USING (("status" = 'active'::"text"));



CREATE POLICY "Messages are readable by portrait owner" ON "public"."messages" FOR SELECT USING (true);



CREATE POLICY "Platform organization collection isolation" ON "public"."platform_media_collections" USING (("platform_organization_id" = "public"."get_current_platform_organization_id"()));



CREATE POLICY "Platform organization collection media isolation" ON "public"."platform_collection_media" USING (("collection_id" IN ( SELECT "platform_media_collections"."id"
   FROM "public"."platform_media_collections"
  WHERE ("platform_media_collections"."platform_organization_id" = "public"."get_current_platform_organization_id"()))));



CREATE POLICY "Platform organization media isolation" ON "public"."platform_media_items" USING (("platform_organization_id" = "public"."get_current_platform_organization_id"()));



CREATE POLICY "Platform organization processing isolation" ON "public"."platform_media_processing_jobs" USING (("platform_organization_id" = "public"."get_current_platform_organization_id"()));



CREATE POLICY "Platform organization usage isolation" ON "public"."platform_media_usage" USING (("platform_organization_id" = "public"."get_current_platform_organization_id"()));



CREATE POLICY "Program outcomes are viewable by everyone" ON "public"."program_outcomes" FOR SELECT USING (true);



CREATE POLICY "Program visits are viewable by everyone" ON "public"."program_visits" FOR SELECT USING (true);



CREATE POLICY "Public can read approved enrichments" ON "public"."enrichment_reviews" FOR SELECT USING (("status" = 'approved'::"text"));



CREATE POLICY "Public can read media_items" ON "public"."media_items" FOR SELECT USING (true);



CREATE POLICY "Public can read project_media_links" ON "public"."project_media_links" FOR SELECT USING (true);



CREATE POLICY "Public can read video_embeds" ON "public"."video_embeds" FOR SELECT USING (true);



CREATE POLICY "Public can view approved media" ON "public"."media_items" FOR SELECT USING ((("community_approved" = true) AND ("consent_verified" = true)));



CREATE POLICY "Public can view article locations" ON "public"."article_locations" FOR SELECT USING (true);



CREATE POLICY "Public can view article tags" ON "public"."article_tags" FOR SELECT USING (true);



CREATE POLICY "Public can view authors" ON "public"."authors" FOR SELECT USING (true);



CREATE POLICY "Public can view collection media" ON "public"."collection_media" FOR SELECT USING (("collection_id" IN ( SELECT "media_collections"."id"
   FROM "public"."media_collections"
  WHERE ("media_collections"."public_visible" = true))));



CREATE POLICY "Public can view contacts" ON "public"."partner_contacts" FOR SELECT USING (true);



CREATE POLICY "Public can view goals" ON "public"."partner_goals" FOR SELECT USING (true);



CREATE POLICY "Public can view impact metrics" ON "public"."partner_impact_metrics" FOR SELECT USING (("is_featured" = true));



CREATE POLICY "Public can view inquiries" ON "public"."historical_inquiries" FOR SELECT USING (true);



CREATE POLICY "Public can view key people" ON "public"."coe_key_people" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Public can view nodes" ON "public"."justicehub_nodes" FOR SELECT USING (true);



CREATE POLICY "Public can view public collections" ON "public"."media_collections" FOR SELECT USING (("public_visible" = true));



CREATE POLICY "Public can view public contexts" ON "public"."alma_community_contexts" FOR SELECT TO "authenticated", "anon" USING (("consent_level" = 'Public Knowledge Commons'::"text"));



CREATE POLICY "Public can view public events" ON "public"."events" FOR SELECT USING (("is_public" = true));



CREATE POLICY "Public can view public evidence" ON "public"."alma_evidence" FOR SELECT TO "authenticated", "anon" USING (("consent_level" = 'Public Knowledge Commons'::"text"));



CREATE POLICY "Public can view public photos" ON "public"."partner_photos" FOR SELECT USING (("is_public" = true));



CREATE POLICY "Public can view public stories" ON "public"."partner_stories" FOR SELECT USING ((("is_public" = true) AND ("consent_level" = 'public'::"text")));



CREATE POLICY "Public can view public storytellers" ON "public"."partner_storytellers" FOR SELECT USING ((("is_public" = true) AND ("consent_level" = 'public'::"text")));



CREATE POLICY "Public can view public videos" ON "public"."partner_videos" FOR SELECT USING (("is_public" = true));



CREATE POLICY "Public can view published articles" ON "public"."articles" FOR SELECT USING (("status" = 'published'::"text"));



CREATE POLICY "Public can view published interventions" ON "public"."alma_interventions" FOR SELECT USING ((("review_status" = 'Published'::"text") AND ("consent_level" = ANY (ARRAY['Public Knowledge Commons'::"text", 'Community Controlled'::"text"]))));



CREATE POLICY "Public can view published pages" ON "public"."pages" FOR SELECT USING (("published" = true));



CREATE POLICY "Public can view published review projects" ON "public"."review_projects" FOR SELECT USING (("is_published" = true));



CREATE POLICY "Public can view review media links" ON "public"."review_media_links" FOR SELECT USING (true);



CREATE POLICY "Public can view review videos" ON "public"."review_videos" FOR SELECT USING (true);



CREATE POLICY "Public can view role taxonomy" ON "public"."role_taxonomy" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Public can view site locations" ON "public"."partner_site_locations" FOR SELECT USING (true);



CREATE POLICY "Public delete reactions" ON "public"."story_reactions" FOR DELETE USING (true);



CREATE POLICY "Public insert comments" ON "public"."story_comments" FOR INSERT WITH CHECK (true);



CREATE POLICY "Public insert reactions" ON "public"."story_reactions" FOR INSERT WITH CHECK (true);



CREATE POLICY "Public read access" ON "public"."facility_partnerships" FOR SELECT USING (true);



CREATE POLICY "Public read access" ON "public"."facility_statistics" FOR SELECT USING (true);



CREATE POLICY "Public read access" ON "public"."youth_detention_facilities" FOR SELECT USING (true);



CREATE POLICY "Public read access for campaigns" ON "public"."justice_matrix_campaigns" FOR SELECT USING (true);



CREATE POLICY "Public read access for cases" ON "public"."justice_matrix_cases" FOR SELECT USING (true);



CREATE POLICY "Public read access for curated entries" ON "public"."review_curated_entries" FOR SELECT USING (true);



CREATE POLICY "Public read access for locations" ON "public"."locations" FOR SELECT USING (true);



CREATE POLICY "Public read access for organizations" ON "public"."organizations" FOR SELECT USING (true);



CREATE POLICY "Public read access for projects" ON "public"."projects" FOR SELECT USING (true);



CREATE POLICY "Public read access for published pages" ON "public"."cms_pages" FOR SELECT USING ((("status")::"text" = 'published'::"text"));



CREATE POLICY "Public read access for resources" ON "public"."justice_matrix_resources" FOR SELECT USING (("is_public" = true));



CREATE POLICY "Public read access for service_contacts" ON "public"."service_contacts" FOR SELECT USING (true);



CREATE POLICY "Public read access for service_locations" ON "public"."service_locations" FOR SELECT USING (true);



CREATE POLICY "Public read access for year settings" ON "public"."review_year_settings" FOR SELECT USING (true);



CREATE POLICY "Public read active frameworks" ON "public"."australian_frameworks" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Public read active research" ON "public"."research_items" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Public read cache" ON "public"."alma_external_source_cache" FOR SELECT USING (true);



CREATE POLICY "Public read comments" ON "public"."story_comments" FOR SELECT USING (true);



CREATE POLICY "Public read findings" ON "public"."alma_research_findings" FOR SELECT USING (true);



CREATE POLICY "Public read for active blocks" ON "public"."cms_content_blocks" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Public read for consenting storytellers" ON "public"."storytellers" FOR SELECT USING ((("consent_given" = true) AND ((("privacy_preferences" ->> 'public_display'::"text"))::boolean = true)));



CREATE POLICY "Public read for entity_sources" ON "public"."alma_entity_sources" FOR SELECT USING (true);



CREATE POLICY "Public read for locations" ON "public"."alma_locations" FOR SELECT USING (true);



CREATE POLICY "Public read for media" ON "public"."cms_media" FOR SELECT USING (true);



CREATE POLICY "Public read for source_documents" ON "public"."alma_source_documents" FOR SELECT USING (true);



CREATE POLICY "Public read for tags" ON "public"."alma_tags" FOR SELECT USING (true);



CREATE POLICY "Public read reactions" ON "public"."story_reactions" FOR SELECT USING (true);



CREATE POLICY "Public read research sessions" ON "public"."alma_research_sessions" FOR SELECT USING (true);



CREATE POLICY "Public read tool logs" ON "public"."alma_research_tool_logs" FOR SELECT USING (true);



CREATE POLICY "Pulse events are readable" ON "public"."pulse_events" FOR SELECT USING (true);



CREATE POLICY "Push subscriptions are private" ON "public"."push_subscriptions" USING (true);



CREATE POLICY "Service role can access all business agent queries" ON "public"."business_agent_queries" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role can access all business alerts" ON "public"."business_alerts" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role can access all compliance tracking" ON "public"."compliance_tracking" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role can access all contact enrichments" ON "public"."contact_enrichments" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role can access all contact intelligence" ON "public"."contact_intelligence" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role can access all contact interactions" ON "public"."contact_interactions" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role can access all grant opportunities" ON "public"."grant_opportunities" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role can access all outreach strategies" ON "public"."outreach_strategies" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role can access all project health analysis" ON "public"."project_health_analysis" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role can do anything on entities" ON "public"."entities" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role can do anything on entity_mappings" ON "public"."entity_mappings" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role can manage project activity" ON "public"."project_activity_summary" USING (("auth"."role"() = 'service_role'::"text")) WITH CHECK (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role can manage sprint_snapshots" ON "public"."sprint_snapshots" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role can write service_contacts" ON "public"."service_contacts" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role can write service_locations" ON "public"."service_locations" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access" ON "public"."public_profiles" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access contacts" ON "public"."partner_contacts" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access content_entities" ON "public"."alma_content_entities" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access embeddings" ON "public"."alma_embeddings" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access entity_sources" ON "public"."alma_entity_sources" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access entity_tags" ON "public"."alma_entity_tags" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access events" ON "public"."events" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access goals" ON "public"."partner_goals" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access impact" ON "public"."partner_impact_metrics" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access inquiries" ON "public"."historical_inquiries" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access intervention_funding" ON "public"."alma_intervention_funding" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access key people" ON "public"."coe_key_people" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access metrics_history" ON "public"."alma_metrics_history" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access newsletter" ON "public"."newsletter_subscriptions" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access on contact_communications" ON "public"."contact_communications" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access on contact_review_decisions" ON "public"."contact_review_decisions" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access on conversation_context" ON "public"."conversation_context" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access on entity_relationships" ON "public"."entity_relationships" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access on ignored_email_patterns" ON "public"."ignored_email_patterns" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access on knowledge_chunks" ON "public"."knowledge_chunks" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access on learned_thresholds" ON "public"."learned_thresholds" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access on sync_state" ON "public"."sync_state" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access on tag_inference_rules" ON "public"."tag_inference_rules" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access on xero_financial_alerts" ON "public"."xero_financial_alerts" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access on xero_financial_snapshots" ON "public"."xero_financial_snapshots" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access on xero_invoices" ON "public"."xero_invoices" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access photos" ON "public"."partner_photos" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access platform collection_media" ON "public"."platform_collection_media" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access platform collections" ON "public"."platform_media_collections" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access platform media" ON "public"."platform_media_items" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access platform organizations" ON "public"."platform_organizations" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access platform processing" ON "public"."platform_media_processing_jobs" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access platform usage" ON "public"."platform_media_usage" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access raw_content" ON "public"."alma_raw_content" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access registrations" ON "public"."event_registrations" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access review_media_links" ON "public"."review_media_links" USING (true);



CREATE POLICY "Service role full access review_projects" ON "public"."review_projects" USING (true);



CREATE POLICY "Service role full access review_videos" ON "public"."review_videos" USING (true);



CREATE POLICY "Service role full access role taxonomy" ON "public"."role_taxonomy" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access sites" ON "public"."partner_site_locations" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access source_documents" ON "public"."alma_source_documents" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access stories" ON "public"."partner_stories" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access storytellers" ON "public"."partner_storytellers" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access to events" ON "public"."events" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access to exa_api_usage" ON "public"."exa_api_usage" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access to exa_company_intelligence" ON "public"."exa_company_intelligence" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access to exa_enrichment_queue" ON "public"."exa_enrichment_queue" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access to exa_linkedin_profiles" ON "public"."exa_linkedin_profiles" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access to exa_media_mentions" ON "public"."exa_media_mentions" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role full access to inquiries" ON "public"."historical_inquiries" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access to key people" ON "public"."coe_key_people" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access to nodes" ON "public"."justicehub_nodes" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access to registrations" ON "public"."event_registrations" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access videos" ON "public"."partner_videos" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role has full access on recommendation_outcomes" ON "public"."recommendation_outcomes" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role has full access to agent_registry" ON "public"."agent_registry" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role has full access to agent_requests" ON "public"."agent_requests" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role has full access to email_financial_documents" ON "public"."email_financial_documents" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role has full access to projects" ON "public"."projects" USING (true) WITH CHECK (true);



CREATE POLICY "Service role has full access to storytellers" ON "public"."storytellers" USING (true) WITH CHECK (true);



CREATE POLICY "Service role manage frameworks" ON "public"."australian_frameworks" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role manage research" ON "public"."research_items" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role write access" ON "public"."facility_partnerships" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role write access" ON "public"."facility_statistics" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role write access" ON "public"."youth_detention_facilities" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Session owners can update" ON "public"."alma_research_sessions" FOR UPDATE USING ((("auth"."uid"() = "user_id") OR ("user_id" IS NULL)));



CREATE POLICY "Sources are viewable by everyone" ON "public"."knowledge_sources" FOR SELECT USING (true);



CREATE POLICY "System can create training data" ON "public"."training_dataset" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "System can insert usage log entries" ON "public"."alma_usage_log" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "System insert tool logs" ON "public"."alma_research_tool_logs" FOR INSERT WITH CHECK (true);



CREATE POLICY "System manage cache" ON "public"."alma_external_source_cache" USING (true);



CREATE POLICY "Users can create own profile" ON "public"."public_profiles" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can delete their own articles" ON "public"."articles" FOR DELETE TO "authenticated" USING (("author_id" IN ( SELECT "public_profiles"."id"
   FROM "public"."public_profiles"
  WHERE ("public_profiles"."user_id" = "auth"."uid"()))));



CREATE POLICY "Users can delete their own media" ON "public"."media_library" FOR DELETE TO "authenticated" USING (("uploaded_by" = "auth"."uid"()));



CREATE POLICY "Users can manage own subscriptions" ON "public"."alma_report_subscriptions" TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can update own profile" ON "public"."public_profiles" FOR UPDATE USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can update their own art & innovation projects" ON "public"."art_innovation" FOR UPDATE TO "authenticated" USING (true);



CREATE POLICY "Users can update their own articles" ON "public"."articles" FOR UPDATE TO "authenticated" USING (("author_id" IN ( SELECT "public_profiles"."id"
   FROM "public"."public_profiles"
  WHERE ("public_profiles"."user_id" = "auth"."uid"())))) WITH CHECK (("author_id" IN ( SELECT "public_profiles"."id"
   FROM "public"."public_profiles"
  WHERE ("public_profiles"."user_id" = "auth"."uid"()))));



CREATE POLICY "Users can update their own blog posts" ON "public"."blog_posts" FOR UPDATE USING (((EXISTS ( SELECT 1
   FROM "public"."public_profiles"
  WHERE (("public_profiles"."id" = "blog_posts"."author_id") AND ("public_profiles"."user_id" = "auth"."uid"())))) OR ("auth"."uid"() IN ( SELECT "public_profiles"."user_id"
   FROM "public"."public_profiles"
  WHERE ("public_profiles"."id" = ANY ("blog_posts"."co_authors"))))));



CREATE POLICY "Users can update their own media" ON "public"."media_library" FOR UPDATE TO "authenticated" USING (("uploaded_by" = "auth"."uid"())) WITH CHECK (("uploaded_by" = "auth"."uid"()));



CREATE POLICY "Users can update their own verifications" ON "public"."ai_content_verifications" FOR UPDATE USING (("auth"."uid"() = "verified_by"));



CREATE POLICY "Users can update their own wiki pages" ON "public"."wiki_pages" FOR UPDATE USING ((("auth"."uid"() = "updated_by") OR ("auth"."uid"() = "verified_by")));



CREATE POLICY "Users can view all scores" ON "public"."contact_intelligence_scores" FOR SELECT USING (true);



CREATE POLICY "Users can view own deliveries" ON "public"."alma_report_deliveries" FOR SELECT TO "authenticated" USING (("recipient_user_id" = "auth"."uid"()));



CREATE POLICY "Users can view own profile" ON "public"."public_profiles" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can view own registrations" ON "public"."event_registrations" FOR SELECT USING (("email" = ("auth"."jwt"() ->> 'email'::"text")));



CREATE POLICY "Users can view own subscriptions" ON "public"."alma_report_subscriptions" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can view their own articles" ON "public"."articles" FOR SELECT TO "authenticated" USING ((("status" = 'published'::"text") OR ("author_id" IN ( SELECT "public_profiles"."id"
   FROM "public"."public_profiles"
  WHERE ("public_profiles"."user_id" = "auth"."uid"())))));



CREATE POLICY "Users can view their own blog posts" ON "public"."blog_posts" FOR SELECT USING (((EXISTS ( SELECT 1
   FROM "public"."public_profiles"
  WHERE (("public_profiles"."id" = "blog_posts"."author_id") AND ("public_profiles"."user_id" = "auth"."uid"())))) OR ("auth"."uid"() IN ( SELECT "public_profiles"."user_id"
   FROM "public"."public_profiles"
  WHERE ("public_profiles"."id" = ANY ("blog_posts"."co_authors"))))));



CREATE POLICY "Users can view their tenant's email financial documents" ON "public"."email_financial_documents" FOR SELECT TO "authenticated" USING (("tenant_id" = "current_setting"('app.current_tenant_id'::"text", true)));



CREATE POLICY "Users see their own platform organization" ON "public"."platform_organizations" USING (("id" = "public"."get_current_platform_organization_id"()));



CREATE POLICY "Verifications are viewable by everyone" ON "public"."ai_content_verifications" FOR SELECT USING (true);



CREATE POLICY "Wiki links are publicly readable" ON "public"."wiki_page_links" FOR SELECT USING (true);



CREATE POLICY "Wiki versions are readable if page is active" ON "public"."wiki_page_versions" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."wiki_pages"
  WHERE (("wiki_pages"."id" = "wiki_page_versions"."page_id") AND ("wiki_pages"."status" = 'active'::"text")))));



CREATE POLICY "admin_coverage_metrics" ON "public"."alma_coverage_metrics" USING ((("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text"));



CREATE POLICY "admin_discovered_links" ON "public"."alma_discovered_links" USING ((("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text"));



CREATE POLICY "admin_extraction_patterns" ON "public"."alma_extraction_patterns" USING ((("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text"));



CREATE POLICY "admin_funding_data" ON "public"."alma_funding_data" USING ((("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text"));



CREATE POLICY "admin_scrape_history" ON "public"."alma_scrape_history" USING ((("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text"));



CREATE POLICY "admin_source_registry" ON "public"."alma_source_registry" USING ((("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text"));



ALTER TABLE "public"."agent_registry" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."agent_requests" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_content_verifications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_discoveries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_community_contexts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_consent_ledger" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_content_entities" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_coverage_metrics" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_discovered_links" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_embeddings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_entity_sources" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_entity_tags" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_evidence" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_evidence_outcomes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_external_source_cache" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_extraction_patterns" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_funding_applications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_funding_data" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_funding_opportunities" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_intervention_contexts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_intervention_evidence" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_intervention_funding" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_intervention_outcomes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_intervention_profiles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_interventions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_locations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_metrics_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_outcomes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_raw_content" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_report_deliveries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_report_subscriptions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_research_findings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_research_sessions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_research_tool_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_scrape_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_source_documents" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_source_registry" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_tags" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_usage_log" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."alma_weekly_reports" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."analysis_jobs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."app_users" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "app_users_insert_own" ON "public"."app_users" FOR INSERT WITH CHECK ((("auth"."uid"() = "openId") AND ("role" = 'user'::"public"."user_role")));



CREATE POLICY "app_users_select_own" ON "public"."app_users" FOR SELECT USING (("auth"."uid"() = "openId"));



CREATE POLICY "app_users_update_own" ON "public"."app_users" FOR UPDATE USING (("auth"."uid"() = "openId")) WITH CHECK ((("auth"."uid"() = "openId") AND ("role" = 'user'::"public"."user_role")));



ALTER TABLE "public"."art_innovation" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."art_innovation_profiles" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "art_innovation_profiles_public_read" ON "public"."art_innovation_profiles" FOR SELECT USING (true);



CREATE POLICY "art_innovation_profiles_service_manage" ON "public"."art_innovation_profiles" TO "service_role" USING (true) WITH CHECK (true);



ALTER TABLE "public"."article_locations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."article_related_art" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "article_related_art_public_read" ON "public"."article_related_art" FOR SELECT USING (true);



CREATE POLICY "article_related_art_service_manage" ON "public"."article_related_art" TO "service_role" USING (true) WITH CHECK (true);



ALTER TABLE "public"."article_related_articles" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "article_related_articles_public_read" ON "public"."article_related_articles" FOR SELECT USING (true);



CREATE POLICY "article_related_articles_service_manage" ON "public"."article_related_articles" TO "service_role" USING (true) WITH CHECK (true);



ALTER TABLE "public"."article_related_evidence" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."article_related_interventions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."article_related_programs" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "article_related_programs_public_read" ON "public"."article_related_programs" FOR SELECT USING (true);



CREATE POLICY "article_related_programs_service_manage" ON "public"."article_related_programs" TO "service_role" USING (true) WITH CHECK (true);



ALTER TABLE "public"."article_related_services" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "article_related_services_public_read" ON "public"."article_related_services" FOR SELECT USING (true);



CREATE POLICY "article_related_services_service_manage" ON "public"."article_related_services" TO "service_role" USING (true) WITH CHECK (true);



ALTER TABLE "public"."article_tags" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."articles" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "audit_admin_only" ON "public"."audit_logs" USING ((EXISTS ( SELECT 1
   FROM "public"."profiles"
  WHERE (("profiles"."id" = "auth"."uid"()) AND ("profiles"."role" = ANY (ARRAY['admin'::"text", 'super_admin'::"text"]))))));



ALTER TABLE "public"."audit_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."australian_frameworks" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."authors" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."automated_insights" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "automated_insights_authenticated" ON "public"."automated_insights" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."best_practices" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."business_agent_queries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."business_alerts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."businesses" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "businesses_insert_pending" ON "public"."businesses" FOR INSERT WITH CHECK ((("status" = 'pending'::"public"."business_status") AND ("userOpenId" IS NULL)));



CREATE POLICY "businesses_select_approved" ON "public"."businesses" FOR SELECT USING (("status" = 'approved'::"public"."business_status"));



CREATE POLICY "businesses_select_own" ON "public"."businesses" FOR SELECT USING (("auth"."uid"() = "userOpenId"));



ALTER TABLE "public"."cms_content_blocks" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."cms_media" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."cms_pages" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."coe_key_people" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."collection_media" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."communications_history" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "communications_history_team" ON "public"."communications_history" TO "authenticated" USING (true);



ALTER TABLE "public"."community_connections" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."community_events" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "community_events_own_data" ON "public"."community_events" USING (((("auth"."uid"())::"text" = ("user_id")::"text") OR (("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text")));



ALTER TABLE "public"."community_feedback" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."community_health_metrics" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "community_health_metrics_authenticated" ON "public"."community_health_metrics" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "community_programs_profiles_public_read" ON "public"."registered_services_profiles" FOR SELECT USING (true);



CREATE POLICY "community_programs_profiles_service_manage" ON "public"."registered_services_profiles" TO "service_role" USING (true) WITH CHECK (true);



ALTER TABLE "public"."compliance_tracking" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "consent_access" ON "public"."consent_records" USING ((EXISTS ( SELECT 1
   FROM "public"."storytellers" "st"
  WHERE (("st"."id" = "consent_records"."storyteller_id") AND (("st"."id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."organization_members" "om"
          WHERE (("om"."organization_id" = "st"."organization_id") AND ("om"."user_id" = "auth"."uid"()) AND ("om"."status" = 'active'::"text") AND ("om"."role" = ANY (ARRAY['admin'::"text", 'staff'::"text", 'counselor'::"text"]))))))))));



ALTER TABLE "public"."consent_management" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."consent_records" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."contact_communications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."contact_enrichments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."contact_intelligence" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."contact_intelligence_scores" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."contact_interactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."contact_review_decisions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."conversation_context" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."cultural_protocols" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "cultural_protocols_admin" ON "public"."cultural_protocols" TO "authenticated" USING (((("auth"."jwt"() ->> 'role'::"text") = 'admin'::"text") OR (("auth"."jwt"() ->> 'role'::"text") = 'cultural_liaison'::"text")));



ALTER TABLE "public"."data_quality_metrics" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."discovered_subscriptions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."donations" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "donations_admin" ON "public"."donations" TO "authenticated" USING ((("auth"."jwt"() ->> 'role'::"text") = ANY (ARRAY['admin'::"text", 'finance'::"text"])));



ALTER TABLE "public"."ecosystem_sites" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."elder_review_queue" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."email_financial_documents" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."enrichment_reviews" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."entities" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."entity_mappings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."entity_relationships" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."event_registrations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."events" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "events_insert_pending" ON "public"."events_old_backup" FOR INSERT WITH CHECK (("status" = 'pending'::"public"."event_status"));



ALTER TABLE "public"."events_old_backup" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "events_select_approved" ON "public"."events_old_backup" FOR SELECT USING (("status" = 'approved'::"public"."event_status"));



ALTER TABLE "public"."exa_api_usage" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."exa_company_intelligence" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."exa_enrichment_queue" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."exa_linkedin_profiles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."exa_media_mentions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."facility_partnerships" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."facility_statistics" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ghl_contacts" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "ghl_contacts_anon_read" ON "public"."ghl_contacts" FOR SELECT TO "anon" USING (true);



CREATE POLICY "ghl_contacts_team" ON "public"."ghl_contacts" TO "authenticated" USING (true);



ALTER TABLE "public"."ghl_engagement_metrics" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ghl_opportunities" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "ghl_opportunities_team" ON "public"."ghl_opportunities" TO "authenticated" USING (true);



ALTER TABLE "public"."goal_metrics" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "goal_metrics_service_role" ON "public"."goal_metrics" TO "service_role" USING (true) WITH CHECK (true);



ALTER TABLE "public"."goal_updates" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "goal_updates_service_role" ON "public"."goal_updates" TO "service_role" USING (true) WITH CHECK (true);



ALTER TABLE "public"."goals_2026" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."grant_opportunities" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."health_alerts" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "health_alerts_service_role" ON "public"."health_alerts" TO "service_role" USING (true) WITH CHECK (true);



ALTER TABLE "public"."historical_inquiries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ignored_email_patterns" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."impact_evidence" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."impact_stories" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."international_invitations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."international_programs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."justice_matrix_campaigns" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."justice_matrix_cases" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."justice_matrix_discovered" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."justice_matrix_resources" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."justice_matrix_scrape_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."justice_matrix_sources" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."justicehub_nodes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."knowledge_chunks" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "knowledge_chunks_team" ON "public"."knowledge_chunks" TO "authenticated" USING (true);



ALTER TABLE "public"."knowledge_extraction_queue" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."knowledge_source_sync" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."knowledge_sources" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."knowledge_versions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."learned_thresholds" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "learned_thresholds_team" ON "public"."learned_thresholds" TO "authenticated" USING (true);



ALTER TABLE "public"."linkedin_contacts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."locations" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "media_access" ON "public"."media_files" USING ((("visibility" = 'public'::"text") OR ("uploaded_by" = "auth"."uid"()) OR (("visibility" = 'organization'::"text") AND (EXISTS ( SELECT 1
   FROM "public"."organization_members" "om"
  WHERE (("om"."organization_id" = "media_files"."organization_id") AND ("om"."user_id" = "auth"."uid"()) AND ("om"."status" = 'active'::"text")))))));



ALTER TABLE "public"."media_collections" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."media_files" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."media_items" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."media_library" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."messages" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."newsletter_subscribers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."newsletter_subscriptions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."notion_projects_cache" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "org_members_admin_access" ON "public"."organization_members" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."profiles" "p"
  WHERE (("p"."id" = "auth"."uid"()) AND ("p"."role" = ANY (ARRAY['admin'::"text", 'super_admin'::"text"]))))));



CREATE POLICY "org_members_basic_access" ON "public"."organization_members" USING (("user_id" = "auth"."uid"()));



ALTER TABLE "public"."organization_connections" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."organization_members" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."organizations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."outreach_strategies" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "owners_can_read_own_jobs" ON "public"."analysis_jobs" FOR SELECT USING (("storyteller_id" IN ( SELECT "storytellers"."id"
   FROM "public"."storytellers"
  WHERE ("storytellers"."user_id" = "auth"."uid"()))));



ALTER TABLE "public"."pages" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."partner_contacts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."partner_goals" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."partner_impact_metrics" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."partner_photos" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."partner_site_locations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."partner_stories" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."partner_storytellers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."partner_videos" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."pending_contacts" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "pending_contacts_team" ON "public"."pending_contacts" TO "authenticated" USING (true);



ALTER TABLE "public"."person_identity_map" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "pk_insert_all" ON "public"."project_knowledge" FOR INSERT WITH CHECK (true);



CREATE POLICY "pk_read_all" ON "public"."project_knowledge" FOR SELECT USING (true);



CREATE POLICY "pk_update_all" ON "public"."project_knowledge" FOR UPDATE USING (true) WITH CHECK (true);



ALTER TABLE "public"."platform_collection_media" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."platform_media_collections" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."platform_media_items" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."platform_media_processing_jobs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."platform_media_usage" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."platform_organizations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."pmpp_knowledge" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."portraits" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."profile_appearances" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "profile_appearances_admin_write" ON "public"."profile_appearances" USING ((("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text"));



CREATE POLICY "profile_appearances_public_read" ON "public"."profile_appearances" FOR SELECT USING (true);



CREATE POLICY "profiles_own_data" ON "public"."profiles" USING (("auth"."uid"() = "id"));



ALTER TABLE "public"."program_outcomes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."program_visits" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."project_activity_summary" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."project_contact_matches" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."project_contributions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."project_health_analysis" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."project_knowledge" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."project_media_links" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."project_outcome_updates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."project_outcomes" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "project_outcomes_auth_write" ON "public"."project_outcomes" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() IS NOT NULL));



CREATE POLICY "project_outcomes_public_read" ON "public"."project_outcomes" FOR SELECT USING (("public_visibility" = true));



ALTER TABLE "public"."projects" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."public_profiles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."pulse_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."push_subscriptions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "quotes_access" ON "public"."quotes" USING ((("visibility" = 'public'::"text") OR (("visibility" = 'organization'::"text") AND (EXISTS ( SELECT 1
   FROM ("public"."storytellers" "st"
     JOIN "public"."organization_members" "om" ON (("st"."organization_id" = "om"."organization_id")))
  WHERE (("st"."id" = "quotes"."storyteller_id") AND ("om"."user_id" = "auth"."uid"()) AND ("om"."status" = 'active'::"text")))))));



ALTER TABLE "public"."rd_activity_log" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "read_coverage_metrics" ON "public"."alma_coverage_metrics" FOR SELECT USING (true);



CREATE POLICY "read_discovered_links" ON "public"."alma_discovered_links" FOR SELECT USING (true);



CREATE POLICY "read_extraction_patterns" ON "public"."alma_extraction_patterns" FOR SELECT USING (true);



CREATE POLICY "read_funding_data" ON "public"."alma_funding_data" FOR SELECT USING (true);



CREATE POLICY "read_scrape_history" ON "public"."alma_scrape_history" FOR SELECT USING (true);



CREATE POLICY "read_source_registry" ON "public"."alma_source_registry" FOR SELECT USING (true);



ALTER TABLE "public"."recommendation_outcomes" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "recommendation_outcomes_team" ON "public"."recommendation_outcomes" TO "authenticated" USING (true);



ALTER TABLE "public"."registered_services" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."registered_services_profiles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."relationship_health" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "relationship_health_team" ON "public"."relationship_health" TO "authenticated" USING (true);



ALTER TABLE "public"."research_items" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."review_curated_entries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."review_media_links" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."review_projects" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."review_videos" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."review_year_settings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."role_taxonomy" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."service_contacts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."service_locations" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "service_role_all_analytics" ON "public"."subscription_analytics" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "service_role_all_rd_log" ON "public"."rd_activity_log" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "service_role_all_receipts" ON "public"."subscription_receipts" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "service_role_all_subscriptions" ON "public"."discovered_subscriptions" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "service_role_full_access_analysis_jobs" ON "public"."analysis_jobs" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "service_role_full_access_story_analysis" ON "public"."story_analysis" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "service_role_story_analysis_all" ON "public"."story_analysis" USING ((("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text"));



CREATE POLICY "service_role_transcript_analysis_all" ON "public"."transcript_analysis" USING ((("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text"));



ALTER TABLE "public"."services_profiles" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "services_profiles_public_read" ON "public"."services_profiles" FOR SELECT USING (true);



CREATE POLICY "services_profiles_service_manage" ON "public"."services_profiles" TO "service_role" USING (true) WITH CHECK (true);



ALTER TABLE "public"."site_deployments" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "site_deployments_service_role" ON "public"."site_deployments" TO "service_role" USING (true) WITH CHECK (true);



ALTER TABLE "public"."site_health_checks" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "site_health_checks_service_role" ON "public"."site_health_checks" TO "service_role" USING (true) WITH CHECK (true);



ALTER TABLE "public"."skills_evidence" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."sprint_snapshots" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."story_analysis" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "story_analysis_analytics_read" ON "public"."transcript_analysis" FOR SELECT USING (("processing_status" = 'completed'::"text"));



ALTER TABLE "public"."story_attribution_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."story_comments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."story_related_art" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "story_related_art_public_read" ON "public"."story_related_art" FOR SELECT USING (true);



CREATE POLICY "story_related_art_service_manage" ON "public"."story_related_art" TO "service_role" USING (true) WITH CHECK (true);



ALTER TABLE "public"."story_related_interventions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."story_related_programs" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "story_related_programs_public_read" ON "public"."story_related_programs" FOR SELECT USING (true);



CREATE POLICY "story_related_programs_service_manage" ON "public"."story_related_programs" TO "service_role" USING (true) WITH CHECK (true);



ALTER TABLE "public"."story_related_services" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "story_related_services_public_read" ON "public"."story_related_services" FOR SELECT USING (true);



CREATE POLICY "story_related_services_service_manage" ON "public"."story_related_services" TO "service_role" USING (true) WITH CHECK (true);



ALTER TABLE "public"."storyteller_ai_intelligence" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "storyteller_ai_intelligence_authenticated_manage" ON "public"."storyteller_ai_intelligence" TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "storyteller_ai_intelligence_public_read" ON "public"."storyteller_ai_intelligence" FOR SELECT USING (true);



ALTER TABLE "public"."storyteller_connections" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "storyteller_story_analysis_select" ON "public"."story_analysis" FOR SELECT USING ((("storyteller_id" IN ( SELECT "storytellers"."id"
   FROM "public"."storytellers"
  WHERE ("storytellers"."user_id" = "auth"."uid"()))) OR (("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text")));



CREATE POLICY "storyteller_transcript_analysis_select" ON "public"."transcript_analysis" FOR SELECT USING ((("storyteller_id" IN ( SELECT "storytellers"."id"
   FROM "public"."storytellers"
  WHERE ("storytellers"."user_id" = "auth"."uid"()))) OR (("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text")));



ALTER TABLE "public"."storyteller_videos" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "storyteller_videos_authenticated_manage" ON "public"."storyteller_videos" TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "storyteller_videos_public_read" ON "public"."storyteller_videos" FOR SELECT USING (true);



ALTER TABLE "public"."storytellers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."subscription_analytics" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."subscription_receipts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."support_matches" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."sync_events" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "sync_events_authenticated_read" ON "public"."sync_events" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "sync_events_service_role" ON "public"."sync_events" TO "service_role" USING (true);



ALTER TABLE "public"."sync_state" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "sync_state_team" ON "public"."sync_state" TO "authenticated" USING (true);



ALTER TABLE "public"."tag_inference_rules" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "themes_read" ON "public"."themes" FOR SELECT USING (("status" = 'active'::"text"));



CREATE POLICY "themes_write" ON "public"."themes" USING ((EXISTS ( SELECT 1
   FROM "public"."profiles"
  WHERE (("profiles"."id" = "auth"."uid"()) AND ("profiles"."role" = ANY (ARRAY['admin'::"text", 'super_admin'::"text"]))))));



ALTER TABLE "public"."training_dataset" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."transcript_analysis" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_behavior_insights" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_community_engagement" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_identities" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "user_identities_team" ON "public"."user_identities" TO "authenticated" USING (true);



ALTER TABLE "public"."user_profiles" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "user_profiles_own_data" ON "public"."user_profiles" USING ((("auth"."uid"())::"text" = ("user_id")::"text"));



CREATE POLICY "user_profiles_service_role" ON "public"."user_profiles" TO "service_role" USING (true);



ALTER TABLE "public"."user_project_preferences" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."video_embeds" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."voice_note_shares" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "voice_note_shares_team" ON "public"."voice_note_shares" TO "authenticated" USING (true);



ALTER TABLE "public"."voice_notes" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "voice_notes_access" ON "public"."voice_notes" FOR SELECT TO "authenticated" USING ((("visibility" = 'public'::"text") OR ("visibility" = 'team'::"text") OR ("recorded_by" = (("auth"."jwt"() ->> 'sub'::"text"))::"uuid") OR ((("auth"."jwt"() ->> 'sub'::"text"))::"uuid" = ANY ("shared_with"))));



CREATE POLICY "voice_notes_owner" ON "public"."voice_notes" TO "authenticated" USING ((("recorded_by" = (("auth"."jwt"() ->> 'sub'::"text"))::"uuid") OR (("auth"."jwt"() ->> 'role'::"text") = 'admin'::"text")));



ALTER TABLE "public"."volunteer_hours" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "volunteer_hours_team" ON "public"."volunteer_hours" TO "authenticated" USING (true);



ALTER TABLE "public"."wiki_page_links" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."wiki_page_versions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."wiki_pages" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."wisdom_extracts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."wisdom_insights" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."xero_financial_alerts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."xero_financial_snapshots" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."xero_invoices" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."youth_detention_facilities" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";






ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."pulse_events";



GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";



GRANT ALL ON FUNCTION "public"."gtrgm_in"("cstring") TO "postgres";
GRANT ALL ON FUNCTION "public"."gtrgm_in"("cstring") TO "anon";
GRANT ALL ON FUNCTION "public"."gtrgm_in"("cstring") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gtrgm_in"("cstring") TO "service_role";



GRANT ALL ON FUNCTION "public"."gtrgm_out"("public"."gtrgm") TO "postgres";
GRANT ALL ON FUNCTION "public"."gtrgm_out"("public"."gtrgm") TO "anon";
GRANT ALL ON FUNCTION "public"."gtrgm_out"("public"."gtrgm") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gtrgm_out"("public"."gtrgm") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_in"("cstring", "oid", integer) TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_in"("cstring", "oid", integer) TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_in"("cstring", "oid", integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_in"("cstring", "oid", integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_out"("public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_out"("public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_out"("public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_out"("public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_recv"("internal", "oid", integer) TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_recv"("internal", "oid", integer) TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_recv"("internal", "oid", integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_recv"("internal", "oid", integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_send"("public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_send"("public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_send"("public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_send"("public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_typmod_in"("cstring"[]) TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_typmod_in"("cstring"[]) TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_typmod_in"("cstring"[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_typmod_in"("cstring"[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec_in"("cstring", "oid", integer) TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec_in"("cstring", "oid", integer) TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec_in"("cstring", "oid", integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec_in"("cstring", "oid", integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec_out"("public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec_out"("public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec_out"("public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec_out"("public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec_recv"("internal", "oid", integer) TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec_recv"("internal", "oid", integer) TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec_recv"("internal", "oid", integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec_recv"("internal", "oid", integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec_send"("public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec_send"("public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec_send"("public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec_send"("public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec_typmod_in"("cstring"[]) TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec_typmod_in"("cstring"[]) TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec_typmod_in"("cstring"[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec_typmod_in"("cstring"[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_in"("cstring", "oid", integer) TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_in"("cstring", "oid", integer) TO "anon";
GRANT ALL ON FUNCTION "public"."vector_in"("cstring", "oid", integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_in"("cstring", "oid", integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_out"("public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_out"("public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_out"("public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_out"("public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_recv"("internal", "oid", integer) TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_recv"("internal", "oid", integer) TO "anon";
GRANT ALL ON FUNCTION "public"."vector_recv"("internal", "oid", integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_recv"("internal", "oid", integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_send"("public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_send"("public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_send"("public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_send"("public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_typmod_in"("cstring"[]) TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_typmod_in"("cstring"[]) TO "anon";
GRANT ALL ON FUNCTION "public"."vector_typmod_in"("cstring"[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_typmod_in"("cstring"[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."array_to_halfvec"(real[], integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."array_to_halfvec"(real[], integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."array_to_halfvec"(real[], integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."array_to_halfvec"(real[], integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."array_to_sparsevec"(real[], integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."array_to_sparsevec"(real[], integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."array_to_sparsevec"(real[], integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."array_to_sparsevec"(real[], integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."array_to_vector"(real[], integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."array_to_vector"(real[], integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."array_to_vector"(real[], integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."array_to_vector"(real[], integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."array_to_halfvec"(double precision[], integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."array_to_halfvec"(double precision[], integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."array_to_halfvec"(double precision[], integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."array_to_halfvec"(double precision[], integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."array_to_sparsevec"(double precision[], integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."array_to_sparsevec"(double precision[], integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."array_to_sparsevec"(double precision[], integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."array_to_sparsevec"(double precision[], integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."array_to_vector"(double precision[], integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."array_to_vector"(double precision[], integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."array_to_vector"(double precision[], integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."array_to_vector"(double precision[], integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."array_to_halfvec"(integer[], integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."array_to_halfvec"(integer[], integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."array_to_halfvec"(integer[], integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."array_to_halfvec"(integer[], integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."array_to_sparsevec"(integer[], integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."array_to_sparsevec"(integer[], integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."array_to_sparsevec"(integer[], integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."array_to_sparsevec"(integer[], integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."array_to_vector"(integer[], integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."array_to_vector"(integer[], integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."array_to_vector"(integer[], integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."array_to_vector"(integer[], integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."array_to_halfvec"(numeric[], integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."array_to_halfvec"(numeric[], integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."array_to_halfvec"(numeric[], integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."array_to_halfvec"(numeric[], integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."array_to_sparsevec"(numeric[], integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."array_to_sparsevec"(numeric[], integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."array_to_sparsevec"(numeric[], integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."array_to_sparsevec"(numeric[], integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."array_to_vector"(numeric[], integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."array_to_vector"(numeric[], integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."array_to_vector"(numeric[], integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."array_to_vector"(numeric[], integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_to_float4"("public"."halfvec", integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_to_float4"("public"."halfvec", integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_to_float4"("public"."halfvec", integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_to_float4"("public"."halfvec", integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec"("public"."halfvec", integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec"("public"."halfvec", integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec"("public"."halfvec", integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec"("public"."halfvec", integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_to_sparsevec"("public"."halfvec", integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_to_sparsevec"("public"."halfvec", integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_to_sparsevec"("public"."halfvec", integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_to_sparsevec"("public"."halfvec", integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_to_vector"("public"."halfvec", integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_to_vector"("public"."halfvec", integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_to_vector"("public"."halfvec", integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_to_vector"("public"."halfvec", integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec_to_halfvec"("public"."sparsevec", integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec_to_halfvec"("public"."sparsevec", integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec_to_halfvec"("public"."sparsevec", integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec_to_halfvec"("public"."sparsevec", integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec"("public"."sparsevec", integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec"("public"."sparsevec", integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec"("public"."sparsevec", integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec"("public"."sparsevec", integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec_to_vector"("public"."sparsevec", integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec_to_vector"("public"."sparsevec", integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec_to_vector"("public"."sparsevec", integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec_to_vector"("public"."sparsevec", integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_to_float4"("public"."vector", integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_to_float4"("public"."vector", integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."vector_to_float4"("public"."vector", integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_to_float4"("public"."vector", integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_to_halfvec"("public"."vector", integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_to_halfvec"("public"."vector", integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."vector_to_halfvec"("public"."vector", integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_to_halfvec"("public"."vector", integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_to_sparsevec"("public"."vector", integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_to_sparsevec"("public"."vector", integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."vector_to_sparsevec"("public"."vector", integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_to_sparsevec"("public"."vector", integer, boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."vector"("public"."vector", integer, boolean) TO "postgres";
GRANT ALL ON FUNCTION "public"."vector"("public"."vector", integer, boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."vector"("public"."vector", integer, boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector"("public"."vector", integer, boolean) TO "service_role";

























































































































































GRANT ALL ON FUNCTION "public"."add_new_storyteller"("p_email" "text", "p_full_name" "text", "p_community" "text", "p_bio" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."add_new_storyteller"("p_email" "text", "p_full_name" "text", "p_community" "text", "p_bio" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_new_storyteller"("p_email" "text", "p_full_name" "text", "p_community" "text", "p_bio" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."analyze_contact_strategic_value"() TO "anon";
GRANT ALL ON FUNCTION "public"."analyze_contact_strategic_value"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."analyze_contact_strategic_value"() TO "service_role";



GRANT ALL ON FUNCTION "public"."approve_proposal"("proposal_id" "uuid", "reviewer" "text", "notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."approve_proposal"("proposal_id" "uuid", "reviewer" "text", "notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."approve_proposal"("proposal_id" "uuid", "reviewer" "text", "notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."assign_engagement_tier"("person_uuid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."assign_engagement_tier"("person_uuid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."assign_engagement_tier"("person_uuid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."assign_task_to_agent"("p_task_id" "uuid", "p_agent_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."assign_task_to_agent"("p_task_id" "uuid", "p_agent_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."assign_task_to_agent"("p_task_id" "uuid", "p_agent_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."auto_approve_high_confidence"("confidence_threshold" double precision, "dry_run" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."auto_approve_high_confidence"("confidence_threshold" double precision, "dry_run" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_approve_high_confidence"("confidence_threshold" double precision, "dry_run" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."auto_create_person_identity"() TO "anon";
GRANT ALL ON FUNCTION "public"."auto_create_person_identity"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_create_person_identity"() TO "service_role";



GRANT ALL ON FUNCTION "public"."backfill_all_community_programs_to_alma"() TO "anon";
GRANT ALL ON FUNCTION "public"."backfill_all_community_programs_to_alma"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."backfill_all_community_programs_to_alma"() TO "service_role";



GRANT ALL ON FUNCTION "public"."backfill_community_program_to_alma_intervention"("p_program_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."backfill_community_program_to_alma_intervention"("p_program_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."backfill_community_program_to_alma_intervention"("p_program_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."binary_quantize"("public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."binary_quantize"("public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."binary_quantize"("public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."binary_quantize"("public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."binary_quantize"("public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."binary_quantize"("public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."binary_quantize"("public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."binary_quantize"("public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_api_cost"("p_provider" "text", "p_model" "text", "p_endpoint" "text", "p_input_tokens" integer, "p_output_tokens" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_api_cost"("p_provider" "text", "p_model" "text", "p_endpoint" "text", "p_input_tokens" integer, "p_output_tokens" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_api_cost"("p_provider" "text", "p_model" "text", "p_endpoint" "text", "p_input_tokens" integer, "p_output_tokens" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_community_authority_signal"("intervention_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_community_authority_signal"("intervention_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_community_authority_signal"("intervention_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_community_investment_score"("p_jurisdiction" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_community_investment_score"("p_jurisdiction" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_community_investment_score"("p_jurisdiction" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_coverage_metrics"() TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_coverage_metrics"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_coverage_metrics"() TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_empowerment_score"("analysis_data" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_empowerment_score"("analysis_data" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_empowerment_score"("analysis_data" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_engagement_score"("session_time" integer, "page_views" integer, "interactions" integer, "collaborations" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_engagement_score"("session_time" integer, "page_views" integer, "interactions" integer, "collaborations" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_engagement_score"("session_time" integer, "page_views" integer, "interactions" integer, "collaborations" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_evidence_signal"("intervention_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_evidence_signal"("intervention_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_evidence_signal"("intervention_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_funding_relevance"("opportunity_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_funding_relevance"("opportunity_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_funding_relevance"("opportunity_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_harm_risk_signal"("intervention_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_harm_risk_signal"("intervention_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_harm_risk_signal"("intervention_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_health_trend"("p_site_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_health_trend"("p_site_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_health_trend"("p_site_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_implementation_signal"("intervention_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_implementation_signal"("intervention_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_implementation_signal"("intervention_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_migration_priority"("sub_amount" numeric, "sub_metadata" "jsonb", "sub_confidence" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_migration_priority"("sub_amount" numeric, "sub_metadata" "jsonb", "sub_confidence" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_migration_priority"("sub_amount" numeric, "sub_metadata" "jsonb", "sub_confidence" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_next_scrape"("p_update_frequency" "text", "p_priority_score" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_next_scrape"("p_update_frequency" "text", "p_priority_score" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_next_scrape"("p_update_frequency" "text", "p_priority_score" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_option_value_signal"("intervention_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_option_value_signal"("intervention_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_option_value_signal"("intervention_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_portfolio_score"("int_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_portfolio_score"("int_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_portfolio_score"("int_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_portfolio_signals"("p_intervention_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_portfolio_signals"("p_intervention_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_portfolio_signals"("p_intervention_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_potential_savings"("p_young_people_diverted" integer, "p_detention_cost_per_day" numeric, "p_community_cost_per_day" numeric, "p_avg_detention_days" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_potential_savings"("p_young_people_diverted" integer, "p_detention_cost_per_day" numeric, "p_community_cost_per_day" numeric, "p_avg_detention_days" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_potential_savings"("p_young_people_diverted" integer, "p_detention_cost_per_day" numeric, "p_community_cost_per_day" numeric, "p_avg_detention_days" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_project_sovereignty_score"("target_project_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_project_sovereignty_score"("target_project_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_project_sovereignty_score"("target_project_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_reading_time"("content_text" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_reading_time"("content_text" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_reading_time"("content_text" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_relationship_score"("contact_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_relationship_score"("contact_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_relationship_score"("contact_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_relationship_temperature"("p_days_since_contact" integer, "p_total_touchpoints" integer, "p_inbound_count" integer, "p_outbound_count" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_relationship_temperature"("p_days_since_contact" integer, "p_total_touchpoints" integer, "p_inbound_count" integer, "p_outbound_count" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_relationship_temperature"("p_days_since_contact" integer, "p_total_touchpoints" integer, "p_inbound_count" integer, "p_outbound_count" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_service_completeness"("service_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_service_completeness"("service_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_service_completeness"("service_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_trust_score"("interaction_dates" timestamp with time zone[], "quality_scores" numeric[], "base_score" numeric, "decay_days" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_trust_score"("interaction_dates" timestamp with time zone[], "quality_scores" numeric[], "base_score" numeric, "decay_days" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_trust_score"("interaction_dates" timestamp with time zone[], "quality_scores" numeric[], "base_score" numeric, "decay_days" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."can_access_story"("story_id" "uuid", "user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."can_access_story"("story_id" "uuid", "user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."can_access_story"("story_id" "uuid", "user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."can_read_storyteller_data"() TO "anon";
GRANT ALL ON FUNCTION "public"."can_read_storyteller_data"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."can_read_storyteller_data"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_action_bounds"("p_action_name" "text", "p_params" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."check_action_bounds"("p_action_name" "text", "p_params" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_action_bounds"("p_action_name" "text", "p_params" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_consent_compliance"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."check_consent_compliance"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_consent_compliance"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_coordination_complete"("p_parent_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."check_coordination_complete"("p_parent_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_coordination_complete"("p_parent_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_cultural_content"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_cultural_content"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_cultural_content"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_cultural_restrictions"("p_entity_type" "text", "p_entity_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."check_cultural_restrictions"("p_entity_type" "text", "p_entity_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_cultural_restrictions"("p_entity_type" "text", "p_entity_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_daily_spend_alert"("p_threshold_usd" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."check_daily_spend_alert"("p_threshold_usd" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_daily_spend_alert"("p_threshold_usd" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_expired_conversations"() TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_expired_conversations"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_expired_conversations"() TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_expired_proposals"() TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_expired_proposals"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_expired_proposals"() TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_old_audit_logs"("retention_days" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_old_audit_logs"("retention_days" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_old_audit_logs"("retention_days" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_old_sync_events"("retention_days" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_old_sync_events"("retention_days" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_old_sync_events"("retention_days" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."compare_interventions"("p_intervention_ids" "uuid"[]) TO "anon";
GRANT ALL ON FUNCTION "public"."compare_interventions"("p_intervention_ids" "uuid"[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."compare_interventions"("p_intervention_ids" "uuid"[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."complete_task"("p_task_id" "uuid", "p_output" "jsonb", "p_reasoning" "text", "p_confidence" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."complete_task"("p_task_id" "uuid", "p_output" "jsonb", "p_reasoning" "text", "p_confidence" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."complete_task"("p_task_id" "uuid", "p_output" "jsonb", "p_reasoning" "text", "p_confidence" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."contact_matches_region"("contact_location" "text", "region_tags" "text"[]) TO "anon";
GRANT ALL ON FUNCTION "public"."contact_matches_region"("contact_location" "text", "region_tags" "text"[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."contact_matches_region"("contact_location" "text", "region_tags" "text"[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."contact_matches_role"("contact_position" "text", "contact_company" "text", "contact_industry" "text", "contact_skills" "text"[], "contact_alignment_tags" "text"[], "role_tags" "text"[]) TO "anon";
GRANT ALL ON FUNCTION "public"."contact_matches_role"("contact_position" "text", "contact_company" "text", "contact_industry" "text", "contact_skills" "text"[], "contact_alignment_tags" "text"[], "role_tags" "text"[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."contact_matches_role"("contact_position" "text", "contact_company" "text", "contact_industry" "text", "contact_skills" "text"[], "contact_alignment_tags" "text"[], "role_tags" "text"[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."cosine_distance"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."cosine_distance"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."cosine_distance"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."cosine_distance"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."cosine_distance"("public"."sparsevec", "public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."cosine_distance"("public"."sparsevec", "public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."cosine_distance"("public"."sparsevec", "public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."cosine_distance"("public"."sparsevec", "public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."cosine_distance"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."cosine_distance"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."cosine_distance"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."cosine_distance"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."cosine_similarity"("a" "public"."vector", "b" "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."cosine_similarity"("a" "public"."vector", "b" "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."cosine_similarity"("a" "public"."vector", "b" "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_decision_outcomes_table"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_decision_outcomes_table"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_decision_outcomes_table"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_decisions_table"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_decisions_table"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_decisions_table"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_empathy_project"("project_name" "text", "organization_name" "text", "organization_email" "text", "creator_user_id" "uuid", "template_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_empathy_project"("project_name" "text", "organization_name" "text", "organization_email" "text", "creator_user_id" "uuid", "template_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_empathy_project"("project_name" "text", "organization_name" "text", "organization_email" "text", "creator_user_id" "uuid", "template_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_extraction_notifications"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_extraction_notifications"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_extraction_notifications"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_health_alert"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_health_alert"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_health_alert"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_research_session"("p_query" "text", "p_depth" "text", "p_max_consent_level" "text", "p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_research_session"("p_query" "text", "p_depth" "text", "p_max_consent_level" "text", "p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_research_session"("p_query" "text", "p_depth" "text", "p_max_consent_level" "text", "p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_review_reminders"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_review_reminders"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_review_reminders"() TO "service_role";



GRANT ALL ON FUNCTION "public"."daitch_mokotoff"("text") TO "postgres";
GRANT ALL ON FUNCTION "public"."daitch_mokotoff"("text") TO "anon";
GRANT ALL ON FUNCTION "public"."daitch_mokotoff"("text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."daitch_mokotoff"("text") TO "service_role";



GRANT ALL ON FUNCTION "public"."decrement_communities_joined"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."decrement_communities_joined"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."decrement_communities_joined"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."decrement_stories_contributed"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."decrement_stories_contributed"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."decrement_stories_contributed"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."delete_old_pulse_events"() TO "anon";
GRANT ALL ON FUNCTION "public"."delete_old_pulse_events"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."delete_old_pulse_events"() TO "service_role";



GRANT ALL ON FUNCTION "public"."detect_cultural_content"() TO "anon";
GRANT ALL ON FUNCTION "public"."detect_cultural_content"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."detect_cultural_content"() TO "service_role";



GRANT ALL ON FUNCTION "public"."determine_lcaa_stage"("p_temperature" integer, "p_inbound_count" integer, "p_outbound_count" integer, "p_total_touchpoints" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."determine_lcaa_stage"("p_temperature" integer, "p_inbound_count" integer, "p_outbound_count" integer, "p_total_touchpoints" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."determine_lcaa_stage"("p_temperature" integer, "p_inbound_count" integer, "p_outbound_count" integer, "p_total_touchpoints" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."difference"("text", "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."difference"("text", "text") TO "anon";
GRANT ALL ON FUNCTION "public"."difference"("text", "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."difference"("text", "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."dmetaphone"("text") TO "postgres";
GRANT ALL ON FUNCTION "public"."dmetaphone"("text") TO "anon";
GRANT ALL ON FUNCTION "public"."dmetaphone"("text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."dmetaphone"("text") TO "service_role";



GRANT ALL ON FUNCTION "public"."dmetaphone_alt"("text") TO "postgres";
GRANT ALL ON FUNCTION "public"."dmetaphone_alt"("text") TO "anon";
GRANT ALL ON FUNCTION "public"."dmetaphone_alt"("text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."dmetaphone_alt"("text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."exec"("sql" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."exec"("sql" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."exec"("sql" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."exec"("sql" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."exec_sql"("query" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."exec_sql"("query" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."exec_sql"("query" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."execute_sql"("sql_query" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."execute_sql"("sql_query" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."execute_sql"("sql_query" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."expire_old_proposals"() TO "anon";
GRANT ALL ON FUNCTION "public"."expire_old_proposals"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."expire_old_proposals"() TO "service_role";



GRANT ALL ON FUNCTION "public"."find_evidence_gaps"("p_jurisdiction" "text", "p_intervention_type" "text", "p_limit" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."find_evidence_gaps"("p_jurisdiction" "text", "p_intervention_type" "text", "p_limit" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."find_evidence_gaps"("p_jurisdiction" "text", "p_intervention_type" "text", "p_limit" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."find_potential_duplicates"("p_entity_id" "uuid", "p_threshold" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."find_potential_duplicates"("p_entity_id" "uuid", "p_threshold" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."find_potential_duplicates"("p_entity_id" "uuid", "p_threshold" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."find_similar_decisions"("p_input_context" "jsonb", "p_decision_type" "text", "p_limit" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."find_similar_decisions"("p_input_context" "jsonb", "p_decision_type" "text", "p_limit" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."find_similar_decisions"("p_input_context" "jsonb", "p_decision_type" "text", "p_limit" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."find_similar_knowledge"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."find_similar_knowledge"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."find_similar_knowledge"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."flag_low_confidence_executions"() TO "anon";
GRANT ALL ON FUNCTION "public"."flag_low_confidence_executions"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."flag_low_confidence_executions"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_album_slug"("title_text" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."generate_album_slug"("title_text" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_album_slug"("title_text" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_event_slug"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_event_slug"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_event_slug"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_input_hash"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_input_hash"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_input_hash"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_public_profile_slug"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_public_profile_slug"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_public_profile_slug"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_short_id"("length" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."generate_short_id"("length" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_short_id"("length" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_storage_prefix"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_storage_prefix"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_storage_prefix"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_weekly_report_data"("p_week_start" "date", "p_organization_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."generate_weekly_report_data"("p_week_start" "date", "p_organization_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_weekly_report_data"("p_week_start" "date", "p_organization_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_agent_health"("p_hours" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_agent_health"("p_hours" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_agent_health"("p_hours" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_auto_approval_stats"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_auto_approval_stats"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_auto_approval_stats"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_business_state_summary"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_business_state_summary"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_business_state_summary"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_calendar_events"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_project_code" "text", "p_calendar_id" "text", "p_limit" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_calendar_events"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_project_code" "text", "p_calendar_id" "text", "p_limit" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_calendar_events"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_project_code" "text", "p_calendar_id" "text", "p_limit" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_calendar_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."get_calendar_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_calendar_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_contacts_needing_attention"("days_threshold" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_contacts_needing_attention"("days_threshold" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_contacts_needing_attention"("days_threshold" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_cost_summary"("p_start_date" "date", "p_end_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_cost_summary"("p_start_date" "date", "p_end_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_cost_summary"("p_start_date" "date", "p_end_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_current_platform_organization_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_current_platform_organization_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_current_platform_organization_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_decision_quality_metrics"("p_agent_id" "text", "p_decision_type" "text", "p_days" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_decision_quality_metrics"("p_agent_id" "text", "p_decision_type" "text", "p_days" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_decision_quality_metrics"("p_agent_id" "text", "p_decision_type" "text", "p_days" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_decision_recommendations"("limit_count" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_decision_recommendations"("limit_count" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_decision_recommendations"("limit_count" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_entity_by_identifier"("identifier" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_entity_by_identifier"("identifier" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_entity_by_identifier"("identifier" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_gmail_accounts_for_sync"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_gmail_accounts_for_sync"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_gmail_accounts_for_sync"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_hero_image"("p_link_type" "text", "p_link_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_hero_image"("p_link_type" "text", "p_link_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_hero_image"("p_link_type" "text", "p_link_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_intervention_comprehensive"("p_intervention_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_intervention_comprehensive"("p_intervention_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_intervention_comprehensive"("p_intervention_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_jurisdiction_stats"("p_jurisdiction" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_jurisdiction_stats"("p_jurisdiction" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_jurisdiction_stats"("p_jurisdiction" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_location_id_by_name"("location_name" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_location_id_by_name"("location_name" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_location_id_by_name"("location_name" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_next_exa_batch"("p_batch_size" integer, "p_campaign_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_next_exa_batch"("p_batch_size" integer, "p_campaign_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_next_exa_batch"("p_batch_size" integer, "p_campaign_type" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_pending_enrichments"("p_project_slug" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_pending_enrichments"("p_project_slug" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_pending_enrichments"("p_project_slug" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_pending_sync_events"("batch_size" integer, "target_filter" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_pending_sync_events"("batch_size" integer, "target_filter" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_pending_sync_events"("batch_size" integer, "target_filter" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_project_context"("p_project_code" "text", "p_days" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_project_context"("p_project_code" "text", "p_days" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_project_context"("p_project_code" "text", "p_days" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_project_media"("p_link_type" "text", "p_link_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_project_media"("p_link_type" "text", "p_link_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_project_media"("p_link_type" "text", "p_link_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_project_timeline"("p_project_code" "text", "p_limit" integer, "p_types" "text"[]) TO "anon";
GRANT ALL ON FUNCTION "public"."get_project_timeline"("p_project_code" "text", "p_limit" integer, "p_types" "text"[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_project_timeline"("p_project_code" "text", "p_limit" integer, "p_types" "text"[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_roles_by_category"("p_category" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_roles_by_category"("p_category" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_roles_by_category"("p_category" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_stories_needing_analysis"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_stories_needing_analysis"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_stories_needing_analysis"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_storytellers_needing_analysis"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_storytellers_needing_analysis"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_storytellers_needing_analysis"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_sub_task_results"("p_parent_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_sub_task_results"("p_parent_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_sub_task_results"("p_parent_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_transcript_analysis_for_story"("p_story_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_transcript_analysis_for_story"("p_story_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_transcript_analysis_for_story"("p_story_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_unified_services_stats"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_unified_services_stats"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_unified_services_stats"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_week_start"("p_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_week_start"("p_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_week_start"("p_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."gin_extract_query_trgm"("text", "internal", smallint, "internal", "internal", "internal", "internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."gin_extract_query_trgm"("text", "internal", smallint, "internal", "internal", "internal", "internal") TO "anon";
GRANT ALL ON FUNCTION "public"."gin_extract_query_trgm"("text", "internal", smallint, "internal", "internal", "internal", "internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gin_extract_query_trgm"("text", "internal", smallint, "internal", "internal", "internal", "internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."gin_extract_value_trgm"("text", "internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."gin_extract_value_trgm"("text", "internal") TO "anon";
GRANT ALL ON FUNCTION "public"."gin_extract_value_trgm"("text", "internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gin_extract_value_trgm"("text", "internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."gin_trgm_consistent"("internal", smallint, "text", integer, "internal", "internal", "internal", "internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."gin_trgm_consistent"("internal", smallint, "text", integer, "internal", "internal", "internal", "internal") TO "anon";
GRANT ALL ON FUNCTION "public"."gin_trgm_consistent"("internal", smallint, "text", integer, "internal", "internal", "internal", "internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gin_trgm_consistent"("internal", smallint, "text", integer, "internal", "internal", "internal", "internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."gin_trgm_triconsistent"("internal", smallint, "text", integer, "internal", "internal", "internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."gin_trgm_triconsistent"("internal", smallint, "text", integer, "internal", "internal", "internal") TO "anon";
GRANT ALL ON FUNCTION "public"."gin_trgm_triconsistent"("internal", smallint, "text", integer, "internal", "internal", "internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gin_trgm_triconsistent"("internal", smallint, "text", integer, "internal", "internal", "internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."gtrgm_compress"("internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."gtrgm_compress"("internal") TO "anon";
GRANT ALL ON FUNCTION "public"."gtrgm_compress"("internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gtrgm_compress"("internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."gtrgm_consistent"("internal", "text", smallint, "oid", "internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."gtrgm_consistent"("internal", "text", smallint, "oid", "internal") TO "anon";
GRANT ALL ON FUNCTION "public"."gtrgm_consistent"("internal", "text", smallint, "oid", "internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gtrgm_consistent"("internal", "text", smallint, "oid", "internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."gtrgm_decompress"("internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."gtrgm_decompress"("internal") TO "anon";
GRANT ALL ON FUNCTION "public"."gtrgm_decompress"("internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gtrgm_decompress"("internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."gtrgm_distance"("internal", "text", smallint, "oid", "internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."gtrgm_distance"("internal", "text", smallint, "oid", "internal") TO "anon";
GRANT ALL ON FUNCTION "public"."gtrgm_distance"("internal", "text", smallint, "oid", "internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gtrgm_distance"("internal", "text", smallint, "oid", "internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."gtrgm_options"("internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."gtrgm_options"("internal") TO "anon";
GRANT ALL ON FUNCTION "public"."gtrgm_options"("internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gtrgm_options"("internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."gtrgm_penalty"("internal", "internal", "internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."gtrgm_penalty"("internal", "internal", "internal") TO "anon";
GRANT ALL ON FUNCTION "public"."gtrgm_penalty"("internal", "internal", "internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gtrgm_penalty"("internal", "internal", "internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."gtrgm_picksplit"("internal", "internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."gtrgm_picksplit"("internal", "internal") TO "anon";
GRANT ALL ON FUNCTION "public"."gtrgm_picksplit"("internal", "internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gtrgm_picksplit"("internal", "internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."gtrgm_same"("public"."gtrgm", "public"."gtrgm", "internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."gtrgm_same"("public"."gtrgm", "public"."gtrgm", "internal") TO "anon";
GRANT ALL ON FUNCTION "public"."gtrgm_same"("public"."gtrgm", "public"."gtrgm", "internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gtrgm_same"("public"."gtrgm", "public"."gtrgm", "internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."gtrgm_union"("internal", "internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."gtrgm_union"("internal", "internal") TO "anon";
GRANT ALL ON FUNCTION "public"."gtrgm_union"("internal", "internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gtrgm_union"("internal", "internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_accum"(double precision[], "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_accum"(double precision[], "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_accum"(double precision[], "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_accum"(double precision[], "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_add"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_add"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_add"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_add"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_avg"(double precision[]) TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_avg"(double precision[]) TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_avg"(double precision[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_avg"(double precision[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_cmp"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_cmp"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_cmp"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_cmp"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_combine"(double precision[], double precision[]) TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_combine"(double precision[], double precision[]) TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_combine"(double precision[], double precision[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_combine"(double precision[], double precision[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_concat"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_concat"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_concat"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_concat"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_eq"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_eq"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_eq"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_eq"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_ge"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_ge"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_ge"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_ge"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_gt"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_gt"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_gt"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_gt"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_l2_squared_distance"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_l2_squared_distance"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_l2_squared_distance"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_l2_squared_distance"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_le"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_le"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_le"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_le"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_lt"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_lt"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_lt"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_lt"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_mul"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_mul"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_mul"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_mul"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_ne"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_ne"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_ne"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_ne"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_negative_inner_product"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_negative_inner_product"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_negative_inner_product"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_negative_inner_product"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_spherical_distance"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_spherical_distance"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_spherical_distance"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_spherical_distance"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."halfvec_sub"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."halfvec_sub"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."halfvec_sub"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."halfvec_sub"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."hamming_distance"(bit, bit) TO "postgres";
GRANT ALL ON FUNCTION "public"."hamming_distance"(bit, bit) TO "anon";
GRANT ALL ON FUNCTION "public"."hamming_distance"(bit, bit) TO "authenticated";
GRANT ALL ON FUNCTION "public"."hamming_distance"(bit, bit) TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "service_role";



GRANT ALL ON FUNCTION "public"."hnsw_bit_support"("internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."hnsw_bit_support"("internal") TO "anon";
GRANT ALL ON FUNCTION "public"."hnsw_bit_support"("internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."hnsw_bit_support"("internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."hnsw_halfvec_support"("internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."hnsw_halfvec_support"("internal") TO "anon";
GRANT ALL ON FUNCTION "public"."hnsw_halfvec_support"("internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."hnsw_halfvec_support"("internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."hnsw_sparsevec_support"("internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."hnsw_sparsevec_support"("internal") TO "anon";
GRANT ALL ON FUNCTION "public"."hnsw_sparsevec_support"("internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."hnsw_sparsevec_support"("internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."hnswhandler"("internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."hnswhandler"("internal") TO "anon";
GRANT ALL ON FUNCTION "public"."hnswhandler"("internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."hnswhandler"("internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."increment_clicks"("portrait_uuid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."increment_clicks"("portrait_uuid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."increment_clicks"("portrait_uuid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."increment_communities_joined"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."increment_communities_joined"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."increment_communities_joined"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."increment_stories_contributed"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."increment_stories_contributed"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."increment_stories_contributed"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."increment_views"("portrait_uuid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."increment_views"("portrait_uuid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."increment_views"("portrait_uuid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."inner_product"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."inner_product"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."inner_product"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."inner_product"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."inner_product"("public"."sparsevec", "public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."inner_product"("public"."sparsevec", "public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."inner_product"("public"."sparsevec", "public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."inner_product"("public"."sparsevec", "public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."inner_product"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."inner_product"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."inner_product"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."inner_product"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."insert_community_programs_profile"() TO "anon";
GRANT ALL ON FUNCTION "public"."insert_community_programs_profile"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."insert_community_programs_profile"() TO "service_role";



GRANT ALL ON FUNCTION "public"."is_admin"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_admin"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_admin"() TO "service_role";



GRANT ALL ON FUNCTION "public"."ivfflat_bit_support"("internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."ivfflat_bit_support"("internal") TO "anon";
GRANT ALL ON FUNCTION "public"."ivfflat_bit_support"("internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."ivfflat_bit_support"("internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."ivfflat_halfvec_support"("internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."ivfflat_halfvec_support"("internal") TO "anon";
GRANT ALL ON FUNCTION "public"."ivfflat_halfvec_support"("internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."ivfflat_halfvec_support"("internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."ivfflathandler"("internal") TO "postgres";
GRANT ALL ON FUNCTION "public"."ivfflathandler"("internal") TO "anon";
GRANT ALL ON FUNCTION "public"."ivfflathandler"("internal") TO "authenticated";
GRANT ALL ON FUNCTION "public"."ivfflathandler"("internal") TO "service_role";



GRANT ALL ON FUNCTION "public"."jaccard_distance"(bit, bit) TO "postgres";
GRANT ALL ON FUNCTION "public"."jaccard_distance"(bit, bit) TO "anon";
GRANT ALL ON FUNCTION "public"."jaccard_distance"(bit, bit) TO "authenticated";
GRANT ALL ON FUNCTION "public"."jaccard_distance"(bit, bit) TO "service_role";



GRANT ALL ON FUNCTION "public"."jsonb_object_keys_count"("j" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."jsonb_object_keys_count"("j" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."jsonb_object_keys_count"("j" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."l1_distance"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."l1_distance"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."l1_distance"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."l1_distance"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."l1_distance"("public"."sparsevec", "public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."l1_distance"("public"."sparsevec", "public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."l1_distance"("public"."sparsevec", "public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."l1_distance"("public"."sparsevec", "public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."l1_distance"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."l1_distance"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."l1_distance"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."l1_distance"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."l2_distance"("public"."halfvec", "public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."l2_distance"("public"."halfvec", "public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."l2_distance"("public"."halfvec", "public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."l2_distance"("public"."halfvec", "public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."l2_distance"("public"."sparsevec", "public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."l2_distance"("public"."sparsevec", "public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."l2_distance"("public"."sparsevec", "public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."l2_distance"("public"."sparsevec", "public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."l2_distance"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."l2_distance"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."l2_distance"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."l2_distance"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."l2_norm"("public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."l2_norm"("public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."l2_norm"("public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."l2_norm"("public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."l2_norm"("public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."l2_norm"("public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."l2_norm"("public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."l2_norm"("public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."l2_normalize"("public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."l2_normalize"("public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."l2_normalize"("public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."l2_normalize"("public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."l2_normalize"("public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."l2_normalize"("public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."l2_normalize"("public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."l2_normalize"("public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."l2_normalize"("public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."l2_normalize"("public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."l2_normalize"("public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."l2_normalize"("public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."levenshtein"("text", "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."levenshtein"("text", "text") TO "anon";
GRANT ALL ON FUNCTION "public"."levenshtein"("text", "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."levenshtein"("text", "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."levenshtein"("text", "text", integer, integer, integer) TO "postgres";
GRANT ALL ON FUNCTION "public"."levenshtein"("text", "text", integer, integer, integer) TO "anon";
GRANT ALL ON FUNCTION "public"."levenshtein"("text", "text", integer, integer, integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."levenshtein"("text", "text", integer, integer, integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."levenshtein_less_equal"("text", "text", integer) TO "postgres";
GRANT ALL ON FUNCTION "public"."levenshtein_less_equal"("text", "text", integer) TO "anon";
GRANT ALL ON FUNCTION "public"."levenshtein_less_equal"("text", "text", integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."levenshtein_less_equal"("text", "text", integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."levenshtein_less_equal"("text", "text", integer, integer, integer, integer) TO "postgres";
GRANT ALL ON FUNCTION "public"."levenshtein_less_equal"("text", "text", integer, integer, integer, integer) TO "anon";
GRANT ALL ON FUNCTION "public"."levenshtein_less_equal"("text", "text", integer, integer, integer, integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."levenshtein_less_equal"("text", "text", integer, integer, integer, integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."log_agent_action"("p_agent_id" "text", "p_action" "text", "p_target_table" "text", "p_target_id" "text", "p_success" boolean, "p_duration_ms" integer, "p_error_message" "text", "p_input_summary" "jsonb", "p_output_summary" "jsonb", "p_user_context" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."log_agent_action"("p_agent_id" "text", "p_action" "text", "p_target_table" "text", "p_target_id" "text", "p_success" boolean, "p_duration_ms" integer, "p_error_message" "text", "p_input_summary" "jsonb", "p_output_summary" "jsonb", "p_user_context" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_agent_action"("p_agent_id" "text", "p_action" "text", "p_target_table" "text", "p_target_id" "text", "p_success" boolean, "p_duration_ms" integer, "p_error_message" "text", "p_input_summary" "jsonb", "p_output_summary" "jsonb", "p_user_context" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."log_alma_usage"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text", "p_query_text" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."log_alma_usage"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text", "p_query_text" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_alma_usage"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text", "p_query_text" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."log_api_usage"("p_provider" "text", "p_model" "text", "p_endpoint" "text", "p_input_tokens" integer, "p_output_tokens" integer, "p_script_name" "text", "p_cache_hit" boolean, "p_latency_ms" integer, "p_agent_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."log_api_usage"("p_provider" "text", "p_model" "text", "p_endpoint" "text", "p_input_tokens" integer, "p_output_tokens" integer, "p_script_name" "text", "p_cache_hit" boolean, "p_latency_ms" integer, "p_agent_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_api_usage"("p_provider" "text", "p_model" "text", "p_endpoint" "text", "p_input_tokens" integer, "p_output_tokens" integer, "p_script_name" "text", "p_cache_hit" boolean, "p_latency_ms" integer, "p_agent_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."log_decision_trace"("p_decision_type" "text", "p_agent_id" "text", "p_input_context" "jsonb", "p_decision" "jsonb", "p_reasoning" "text", "p_confidence" numeric, "p_retrieved_context" "jsonb", "p_alternatives" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."log_decision_trace"("p_decision_type" "text", "p_agent_id" "text", "p_input_context" "jsonb", "p_decision" "jsonb", "p_reasoning" "text", "p_confidence" numeric, "p_retrieved_context" "jsonb", "p_alternatives" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_decision_trace"("p_decision_type" "text", "p_agent_id" "text", "p_input_context" "jsonb", "p_decision" "jsonb", "p_reasoning" "text", "p_confidence" numeric, "p_retrieved_context" "jsonb", "p_alternatives" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."log_goal_update"() TO "anon";
GRANT ALL ON FUNCTION "public"."log_goal_update"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_goal_update"() TO "service_role";



GRANT ALL ON FUNCTION "public"."log_research_tool"("p_session_id" "uuid", "p_tool_name" "text", "p_tool_input" "jsonb", "p_tool_output" "jsonb", "p_execution_time_ms" integer, "p_success" boolean, "p_error_message" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."log_research_tool"("p_session_id" "uuid", "p_tool_name" "text", "p_tool_input" "jsonb", "p_tool_output" "jsonb", "p_execution_time_ms" integer, "p_success" boolean, "p_error_message" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_research_tool"("p_session_id" "uuid", "p_tool_name" "text", "p_tool_input" "jsonb", "p_tool_output" "jsonb", "p_execution_time_ms" integer, "p_success" boolean, "p_error_message" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."mark_service_verified"("service_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."mark_service_verified"("service_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_service_verified"("service_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."mark_task_for_review"("p_task_id" "uuid", "p_output" "jsonb", "p_reasoning" "text", "p_confidence" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."mark_task_for_review"("p_task_id" "uuid", "p_output" "jsonb", "p_reasoning" "text", "p_confidence" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_task_for_review"("p_task_id" "uuid", "p_output" "jsonb", "p_reasoning" "text", "p_confidence" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."match_knowledge_chunks"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "filter_source_type" "text", "filter_project_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."match_knowledge_chunks"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "filter_source_type" "text", "filter_project_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."match_knowledge_chunks"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "filter_source_type" "text", "filter_project_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."metaphone"("text", integer) TO "postgres";
GRANT ALL ON FUNCTION "public"."metaphone"("text", integer) TO "anon";
GRANT ALL ON FUNCTION "public"."metaphone"("text", integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."metaphone"("text", integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."name_similarity"("name1" "text", "name2" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."name_similarity"("name1" "text", "name2" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."name_similarity"("name1" "text", "name2" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."normalize_email"("email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."normalize_email"("email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."normalize_email"("email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."normalize_location_name"("input_name" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."normalize_location_name"("input_name" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."normalize_location_name"("input_name" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."normalize_phone"("phone" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."normalize_phone"("phone" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."normalize_phone"("phone" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_webhook_sync_event"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_webhook_sync_event"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_webhook_sync_event"() TO "service_role";



GRANT ALL ON FUNCTION "public"."populate_media_quote_links"() TO "anon";
GRANT ALL ON FUNCTION "public"."populate_media_quote_links"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."populate_media_quote_links"() TO "service_role";



GRANT ALL ON FUNCTION "public"."populate_storyteller_media_links"() TO "anon";
GRANT ALL ON FUNCTION "public"."populate_storyteller_media_links"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."populate_storyteller_media_links"() TO "service_role";



GRANT ALL ON FUNCTION "public"."prevent_cultural_sync"() TO "anon";
GRANT ALL ON FUNCTION "public"."prevent_cultural_sync"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."prevent_cultural_sync"() TO "service_role";



GRANT ALL ON FUNCTION "public"."process_new_transcript"("p_story_id" "uuid", "p_transcript_text" "text", "p_source" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."process_new_transcript"("p_story_id" "uuid", "p_transcript_text" "text", "p_source" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_new_transcript"("p_story_id" "uuid", "p_transcript_text" "text", "p_source" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."queue_campaign_for_enrichment"("p_campaign_id" "uuid", "p_campaign_type" "text", "p_limit" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."queue_campaign_for_enrichment"("p_campaign_id" "uuid", "p_campaign_type" "text", "p_limit" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."queue_campaign_for_enrichment"("p_campaign_id" "uuid", "p_campaign_type" "text", "p_limit" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."queue_community_event_sync"() TO "anon";
GRANT ALL ON FUNCTION "public"."queue_community_event_sync"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."queue_community_event_sync"() TO "service_role";



GRANT ALL ON FUNCTION "public"."queue_for_exa_enrichment"("p_person_id" "uuid", "p_campaign_type" "text", "p_priority" integer, "p_enrich_network" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."queue_for_exa_enrichment"("p_person_id" "uuid", "p_campaign_type" "text", "p_priority" integer, "p_enrich_network" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."queue_for_exa_enrichment"("p_person_id" "uuid", "p_campaign_type" "text", "p_priority" integer, "p_enrich_network" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."queue_project_outcome_sync"() TO "anon";
GRANT ALL ON FUNCTION "public"."queue_project_outcome_sync"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."queue_project_outcome_sync"() TO "service_role";



GRANT ALL ON FUNCTION "public"."queue_project_sync"() TO "anon";
GRANT ALL ON FUNCTION "public"."queue_project_sync"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."queue_project_sync"() TO "service_role";



GRANT ALL ON FUNCTION "public"."queue_user_profile_sync"() TO "anon";
GRANT ALL ON FUNCTION "public"."queue_user_profile_sync"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."queue_user_profile_sync"() TO "service_role";



GRANT ALL ON FUNCTION "public"."record_decision_feedback"("p_decision_id" "uuid", "p_feedback" "text", "p_feedback_by" "text", "p_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."record_decision_feedback"("p_decision_id" "uuid", "p_feedback" "text", "p_feedback_by" "text", "p_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."record_decision_feedback"("p_decision_id" "uuid", "p_feedback" "text", "p_feedback_by" "text", "p_notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."record_research_finding"("p_session_id" "uuid", "p_finding_type" "text", "p_content" "jsonb", "p_entity_type" "text", "p_entity_id" "uuid", "p_confidence" numeric, "p_sources" "text"[]) TO "anon";
GRANT ALL ON FUNCTION "public"."record_research_finding"("p_session_id" "uuid", "p_finding_type" "text", "p_content" "jsonb", "p_entity_type" "text", "p_entity_id" "uuid", "p_confidence" numeric, "p_sources" "text"[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."record_research_finding"("p_session_id" "uuid", "p_finding_type" "text", "p_content" "jsonb", "p_entity_type" "text", "p_entity_id" "uuid", "p_confidence" numeric, "p_sources" "text"[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."refresh_alma_dashboards"() TO "anon";
GRANT ALL ON FUNCTION "public"."refresh_alma_dashboards"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."refresh_alma_dashboards"() TO "service_role";



GRANT ALL ON FUNCTION "public"."refresh_funding_relevance_scores"() TO "anon";
GRANT ALL ON FUNCTION "public"."refresh_funding_relevance_scores"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."refresh_funding_relevance_scores"() TO "service_role";



GRANT ALL ON FUNCTION "public"."refresh_portfolio_rankings"() TO "anon";
GRANT ALL ON FUNCTION "public"."refresh_portfolio_rankings"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."refresh_portfolio_rankings"() TO "service_role";



GRANT ALL ON FUNCTION "public"."refresh_sentiment_analytics"() TO "anon";
GRANT ALL ON FUNCTION "public"."refresh_sentiment_analytics"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."refresh_sentiment_analytics"() TO "service_role";



GRANT ALL ON FUNCTION "public"."refresh_trust_scores"() TO "anon";
GRANT ALL ON FUNCTION "public"."refresh_trust_scores"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."refresh_trust_scores"() TO "service_role";



GRANT ALL ON FUNCTION "public"."reject_proposal"("proposal_id" "uuid", "reviewer" "text", "notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."reject_proposal"("proposal_id" "uuid", "reviewer" "text", "notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."reject_proposal"("proposal_id" "uuid", "reviewer" "text", "notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."reset_failed_sync_events"("table_filter" "text", "max_age_hours" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."reset_failed_sync_events"("table_filter" "text", "max_age_hours" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."reset_failed_sync_events"("table_filter" "text", "max_age_hours" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."resolve_entity"("p_source" "text", "p_source_id" "text", "p_name" "text", "p_email" "text", "p_phone" "text", "p_company" "text", "p_entity_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."resolve_entity"("p_source" "text", "p_source_id" "text", "p_name" "text", "p_email" "text", "p_phone" "text", "p_company" "text", "p_entity_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."resolve_entity"("p_source" "text", "p_source_id" "text", "p_name" "text", "p_email" "text", "p_phone" "text", "p_company" "text", "p_entity_type" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."search_alma_interventions"("p_query" "text", "p_geography" "text"[], "p_type" "text", "p_evidence_level" "text", "p_consent_level" "text", "p_limit" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."search_alma_interventions"("p_query" "text", "p_geography" "text"[], "p_type" "text", "p_evidence_level" "text", "p_consent_level" "text", "p_limit" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."search_alma_interventions"("p_query" "text", "p_geography" "text"[], "p_type" "text", "p_evidence_level" "text", "p_consent_level" "text", "p_limit" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."search_alma_unified"("query_text" "text", "entity_types" "text"[], "jurisdictions" "text"[], "limit_results" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."search_alma_unified"("query_text" "text", "entity_types" "text"[], "jurisdictions" "text"[], "limit_results" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."search_alma_unified"("query_text" "text", "entity_types" "text"[], "jurisdictions" "text"[], "limit_results" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."search_interventions_unified"("p_search_query" "text", "p_geography" "text"[], "p_consent_level" "text", "p_min_evidence_level" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."search_interventions_unified"("p_search_query" "text", "p_geography" "text"[], "p_consent_level" "text", "p_min_evidence_level" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."search_interventions_unified"("p_search_query" "text", "p_geography" "text"[], "p_consent_level" "text", "p_min_evidence_level" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."search_knowledge"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "filter_source_type" "text", "filter_project_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."search_knowledge"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "filter_source_type" "text", "filter_project_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."search_knowledge"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "filter_source_type" "text", "filter_project_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."search_media"("p_search_query" "text", "p_file_type" "text", "p_project_slug" "text", "p_tag" "text", "p_limit" integer, "p_offset" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."search_media"("p_search_query" "text", "p_file_type" "text", "p_project_slug" "text", "p_tag" "text", "p_limit" integer, "p_offset" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."search_media"("p_search_query" "text", "p_file_type" "text", "p_project_slug" "text", "p_tag" "text", "p_limit" integer, "p_offset" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."search_project_knowledge"("query_embedding" "public"."vector", "p_project_code" "text", "p_knowledge_types" "text"[], "match_threshold" double precision, "match_count" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."search_project_knowledge"("query_embedding" "public"."vector", "p_project_code" "text", "p_knowledge_types" "text"[], "match_threshold" double precision, "match_count" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."search_project_knowledge"("query_embedding" "public"."vector", "p_project_code" "text", "p_knowledge_types" "text"[], "match_threshold" double precision, "match_count" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."search_voice_notes"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "filter_visibility" "text", "filter_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."search_voice_notes"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "filter_visibility" "text", "filter_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."search_voice_notes"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "filter_visibility" "text", "filter_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."set_album_slug"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_album_slug"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_album_slug"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_limit"(real) TO "postgres";
GRANT ALL ON FUNCTION "public"."set_limit"(real) TO "anon";
GRANT ALL ON FUNCTION "public"."set_limit"(real) TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_limit"(real) TO "service_role";



GRANT ALL ON FUNCTION "public"."set_platform_organization_context"("org_slug" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."set_platform_organization_context"("org_slug" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_platform_organization_context"("org_slug" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."should_promote_to_notion"("person_uuid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."should_promote_to_notion"("person_uuid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."should_promote_to_notion"("person_uuid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."show_limit"() TO "postgres";
GRANT ALL ON FUNCTION "public"."show_limit"() TO "anon";
GRANT ALL ON FUNCTION "public"."show_limit"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."show_limit"() TO "service_role";



GRANT ALL ON FUNCTION "public"."show_trgm"("text") TO "postgres";
GRANT ALL ON FUNCTION "public"."show_trgm"("text") TO "anon";
GRANT ALL ON FUNCTION "public"."show_trgm"("text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."show_trgm"("text") TO "service_role";



GRANT ALL ON FUNCTION "public"."similarity"("text", "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."similarity"("text", "text") TO "anon";
GRANT ALL ON FUNCTION "public"."similarity"("text", "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."similarity"("text", "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."similarity_dist"("text", "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."similarity_dist"("text", "text") TO "anon";
GRANT ALL ON FUNCTION "public"."similarity_dist"("text", "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."similarity_dist"("text", "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."similarity_op"("text", "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."similarity_op"("text", "text") TO "anon";
GRANT ALL ON FUNCTION "public"."similarity_op"("text", "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."similarity_op"("text", "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."snapshot_alma_metrics"() TO "anon";
GRANT ALL ON FUNCTION "public"."snapshot_alma_metrics"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."snapshot_alma_metrics"() TO "service_role";



GRANT ALL ON FUNCTION "public"."soundex"("text") TO "postgres";
GRANT ALL ON FUNCTION "public"."soundex"("text") TO "anon";
GRANT ALL ON FUNCTION "public"."soundex"("text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."soundex"("text") TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec_cmp"("public"."sparsevec", "public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec_cmp"("public"."sparsevec", "public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec_cmp"("public"."sparsevec", "public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec_cmp"("public"."sparsevec", "public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec_eq"("public"."sparsevec", "public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec_eq"("public"."sparsevec", "public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec_eq"("public"."sparsevec", "public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec_eq"("public"."sparsevec", "public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec_ge"("public"."sparsevec", "public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec_ge"("public"."sparsevec", "public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec_ge"("public"."sparsevec", "public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec_ge"("public"."sparsevec", "public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec_gt"("public"."sparsevec", "public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec_gt"("public"."sparsevec", "public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec_gt"("public"."sparsevec", "public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec_gt"("public"."sparsevec", "public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec_l2_squared_distance"("public"."sparsevec", "public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec_l2_squared_distance"("public"."sparsevec", "public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec_l2_squared_distance"("public"."sparsevec", "public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec_l2_squared_distance"("public"."sparsevec", "public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec_le"("public"."sparsevec", "public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec_le"("public"."sparsevec", "public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec_le"("public"."sparsevec", "public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec_le"("public"."sparsevec", "public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec_lt"("public"."sparsevec", "public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec_lt"("public"."sparsevec", "public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec_lt"("public"."sparsevec", "public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec_lt"("public"."sparsevec", "public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec_ne"("public"."sparsevec", "public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec_ne"("public"."sparsevec", "public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec_ne"("public"."sparsevec", "public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec_ne"("public"."sparsevec", "public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."sparsevec_negative_inner_product"("public"."sparsevec", "public"."sparsevec") TO "postgres";
GRANT ALL ON FUNCTION "public"."sparsevec_negative_inner_product"("public"."sparsevec", "public"."sparsevec") TO "anon";
GRANT ALL ON FUNCTION "public"."sparsevec_negative_inner_product"("public"."sparsevec", "public"."sparsevec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sparsevec_negative_inner_product"("public"."sparsevec", "public"."sparsevec") TO "service_role";



GRANT ALL ON FUNCTION "public"."spawn_sub_task"("p_parent_id" "uuid", "p_parent_agent" "text", "p_target_agent" "text", "p_action_name" "text", "p_params" "jsonb", "p_context" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."spawn_sub_task"("p_parent_id" "uuid", "p_parent_agent" "text", "p_target_agent" "text", "p_action_name" "text", "p_params" "jsonb", "p_context" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."spawn_sub_task"("p_parent_id" "uuid", "p_parent_agent" "text", "p_target_agent" "text", "p_action_name" "text", "p_params" "jsonb", "p_context" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."strict_word_similarity"("text", "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."strict_word_similarity"("text", "text") TO "anon";
GRANT ALL ON FUNCTION "public"."strict_word_similarity"("text", "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."strict_word_similarity"("text", "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."strict_word_similarity_commutator_op"("text", "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."strict_word_similarity_commutator_op"("text", "text") TO "anon";
GRANT ALL ON FUNCTION "public"."strict_word_similarity_commutator_op"("text", "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."strict_word_similarity_commutator_op"("text", "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."strict_word_similarity_dist_commutator_op"("text", "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."strict_word_similarity_dist_commutator_op"("text", "text") TO "anon";
GRANT ALL ON FUNCTION "public"."strict_word_similarity_dist_commutator_op"("text", "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."strict_word_similarity_dist_commutator_op"("text", "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."strict_word_similarity_dist_op"("text", "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."strict_word_similarity_dist_op"("text", "text") TO "anon";
GRANT ALL ON FUNCTION "public"."strict_word_similarity_dist_op"("text", "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."strict_word_similarity_dist_op"("text", "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."strict_word_similarity_op"("text", "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."strict_word_similarity_op"("text", "text") TO "anon";
GRANT ALL ON FUNCTION "public"."strict_word_similarity_op"("text", "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."strict_word_similarity_op"("text", "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."subvector"("public"."halfvec", integer, integer) TO "postgres";
GRANT ALL ON FUNCTION "public"."subvector"("public"."halfvec", integer, integer) TO "anon";
GRANT ALL ON FUNCTION "public"."subvector"("public"."halfvec", integer, integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."subvector"("public"."halfvec", integer, integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."subvector"("public"."vector", integer, integer) TO "postgres";
GRANT ALL ON FUNCTION "public"."subvector"("public"."vector", integer, integer) TO "anon";
GRANT ALL ON FUNCTION "public"."subvector"("public"."vector", integer, integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."subvector"("public"."vector", integer, integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_linkedin_contacts_from_imports"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_linkedin_contacts_from_imports"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_linkedin_contacts_from_imports"() TO "service_role";



GRANT ALL ON FUNCTION "public"."text_soundex"("text") TO "postgres";
GRANT ALL ON FUNCTION "public"."text_soundex"("text") TO "anon";
GRANT ALL ON FUNCTION "public"."text_soundex"("text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."text_soundex"("text") TO "service_role";



GRANT ALL ON FUNCTION "public"."track_exa_api_usage"("p_requests_used" integer, "p_request_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."track_exa_api_usage"("p_requests_used" integer, "p_request_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."track_exa_api_usage"("p_requests_used" integer, "p_request_type" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_calculate_temperature"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_calculate_temperature"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_calculate_temperature"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_album_timestamp"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_album_timestamp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_album_timestamp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_alma_contexts_search_vector"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_alma_contexts_search_vector"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_alma_contexts_search_vector"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_alma_evidence_search_vector"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_alma_evidence_search_vector"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_alma_evidence_search_vector"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_alma_ingestion_jobs_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_alma_ingestion_jobs_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_alma_ingestion_jobs_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_alma_interventions_search_vector"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_alma_interventions_search_vector"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_alma_interventions_search_vector"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_alma_outcomes_search_vector"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_alma_outcomes_search_vector"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_alma_outcomes_search_vector"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_alma_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_alma_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_alma_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_article_reading_time"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_article_reading_time"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_article_reading_time"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_calendar_events_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_calendar_events_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_calendar_events_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_citation_count"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_citation_count"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_citation_count"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_community_programs_search_vector"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_community_programs_search_vector"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_community_programs_search_vector"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_contact_review_timestamp"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_contact_review_timestamp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_contact_review_timestamp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_email_financial_documents_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_email_financial_documents_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_email_financial_documents_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_funding_opportunities_timestamp"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_funding_opportunities_timestamp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_funding_opportunities_timestamp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_funding_opportunity_status"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_funding_opportunity_status"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_funding_opportunity_status"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_gmail_sync_state"("p_account_id" "uuid", "p_history_id" "text", "p_items_found" integer, "p_items_extracted" integer, "p_status" "text", "p_error_message" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."update_gmail_sync_state"("p_account_id" "uuid", "p_history_id" "text", "p_items_found" integer, "p_items_extracted" integer, "p_status" "text", "p_error_message" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_gmail_sync_state"("p_account_id" "uuid", "p_history_id" "text", "p_items_found" integer, "p_items_extracted" integer, "p_status" "text", "p_error_message" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_goals_2026_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_goals_2026_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_goals_2026_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_knowledge_version_timestamp"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_knowledge_version_timestamp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_knowledge_version_timestamp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_learned_thresholds_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_learned_thresholds_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_learned_thresholds_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_media_library_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_media_library_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_media_library_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_migration_priority"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_migration_priority"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_migration_priority"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_pk_timestamp"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_pk_timestamp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_pk_timestamp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_platform_organization_activity"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_platform_organization_activity"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_platform_organization_activity"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_platform_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_platform_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_platform_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_profile_appearances_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_profile_appearances_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_profile_appearances_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_profiles_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_profiles_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_profiles_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_project_stats"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_project_stats"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_project_stats"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_public_profiles_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_public_profiles_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_public_profiles_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_raw_content_stats"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_raw_content_stats"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_raw_content_stats"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_relationship_health"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_relationship_health"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_relationship_health"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_research_session"("p_session_id" "uuid", "p_status" "text", "p_plan" "jsonb", "p_scratchpad" "jsonb", "p_results" "jsonb", "p_error_message" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."update_research_session"("p_session_id" "uuid", "p_status" "text", "p_plan" "jsonb", "p_scratchpad" "jsonb", "p_results" "jsonb", "p_error_message" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_research_session"("p_session_id" "uuid", "p_status" "text", "p_plan" "jsonb", "p_scratchpad" "jsonb", "p_results" "jsonb", "p_error_message" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_site_health_from_check"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_site_health_from_check"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_site_health_from_check"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_source_after_scrape"("p_source_url" "text", "p_success" boolean, "p_entities_found" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."update_source_after_scrape"("p_source_url" "text", "p_success" boolean, "p_entities_found" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_source_after_scrape"("p_source_url" "text", "p_success" boolean, "p_entities_found" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."update_source_document_search_vector"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_source_document_search_vector"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_source_document_search_vector"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_story_analysis_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_story_analysis_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_story_analysis_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_storyteller_ai_intelligence_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_storyteller_ai_intelligence_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_storyteller_ai_intelligence_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_storyteller_videos_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_storyteller_videos_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_storyteller_videos_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_subscriptions_timestamp"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_subscriptions_timestamp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_subscriptions_timestamp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_sync_event_status"("event_id" "uuid", "new_status" "text", "error_msg" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."update_sync_event_status"("event_id" "uuid", "new_status" "text", "error_msg" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_sync_event_status"("event_id" "uuid", "new_status" "text", "error_msg" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_tag_usage_count"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_tag_usage_count"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_tag_usage_count"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_task_timestamp"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_task_timestamp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_task_timestamp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_transcript_search_vector"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_transcript_search_vector"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_transcript_search_vector"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_transcripts_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_transcripts_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_transcripts_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_user_last_active"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_user_last_active"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_user_last_active"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_xero_invoice_timestamp"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_xero_invoice_timestamp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_xero_invoice_timestamp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."user_can_perform_alma_action"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."user_can_perform_alma_action"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."user_can_perform_alma_action"("p_entity_type" "text", "p_entity_id" "uuid", "p_action" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_accum"(double precision[], "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_accum"(double precision[], "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_accum"(double precision[], "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_accum"(double precision[], "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_add"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_add"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_add"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_add"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_avg"(double precision[]) TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_avg"(double precision[]) TO "anon";
GRANT ALL ON FUNCTION "public"."vector_avg"(double precision[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_avg"(double precision[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_cmp"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_cmp"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_cmp"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_cmp"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_combine"(double precision[], double precision[]) TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_combine"(double precision[], double precision[]) TO "anon";
GRANT ALL ON FUNCTION "public"."vector_combine"(double precision[], double precision[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_combine"(double precision[], double precision[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_concat"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_concat"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_concat"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_concat"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_dims"("public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_dims"("public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_dims"("public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_dims"("public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_dims"("public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_dims"("public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_dims"("public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_dims"("public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_eq"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_eq"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_eq"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_eq"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_ge"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_ge"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_ge"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_ge"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_gt"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_gt"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_gt"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_gt"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_l2_squared_distance"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_l2_squared_distance"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_l2_squared_distance"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_l2_squared_distance"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_le"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_le"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_le"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_le"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_lt"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_lt"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_lt"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_lt"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_mul"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_mul"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_mul"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_mul"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_ne"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_ne"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_ne"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_ne"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_negative_inner_product"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_negative_inner_product"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_negative_inner_product"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_negative_inner_product"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_norm"("public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_norm"("public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_norm"("public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_norm"("public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_spherical_distance"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_spherical_distance"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_spherical_distance"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_spherical_distance"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."vector_sub"("public"."vector", "public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."vector_sub"("public"."vector", "public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."vector_sub"("public"."vector", "public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."vector_sub"("public"."vector", "public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."wiki_page_create_version"() TO "anon";
GRANT ALL ON FUNCTION "public"."wiki_page_create_version"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."wiki_page_create_version"() TO "service_role";



GRANT ALL ON FUNCTION "public"."wiki_pages_review_due_trigger"() TO "anon";
GRANT ALL ON FUNCTION "public"."wiki_pages_review_due_trigger"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."wiki_pages_review_due_trigger"() TO "service_role";



GRANT ALL ON FUNCTION "public"."wiki_pages_search_trigger"() TO "anon";
GRANT ALL ON FUNCTION "public"."wiki_pages_search_trigger"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."wiki_pages_search_trigger"() TO "service_role";



GRANT ALL ON FUNCTION "public"."word_similarity"("text", "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."word_similarity"("text", "text") TO "anon";
GRANT ALL ON FUNCTION "public"."word_similarity"("text", "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."word_similarity"("text", "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."word_similarity_commutator_op"("text", "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."word_similarity_commutator_op"("text", "text") TO "anon";
GRANT ALL ON FUNCTION "public"."word_similarity_commutator_op"("text", "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."word_similarity_commutator_op"("text", "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."word_similarity_dist_commutator_op"("text", "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."word_similarity_dist_commutator_op"("text", "text") TO "anon";
GRANT ALL ON FUNCTION "public"."word_similarity_dist_commutator_op"("text", "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."word_similarity_dist_commutator_op"("text", "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."word_similarity_dist_op"("text", "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."word_similarity_dist_op"("text", "text") TO "anon";
GRANT ALL ON FUNCTION "public"."word_similarity_dist_op"("text", "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."word_similarity_dist_op"("text", "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."word_similarity_op"("text", "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."word_similarity_op"("text", "text") TO "anon";
GRANT ALL ON FUNCTION "public"."word_similarity_op"("text", "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."word_similarity_op"("text", "text") TO "service_role";












GRANT ALL ON FUNCTION "public"."avg"("public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."avg"("public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."avg"("public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."avg"("public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."avg"("public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."avg"("public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."avg"("public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."avg"("public"."vector") TO "service_role";



GRANT ALL ON FUNCTION "public"."sum"("public"."halfvec") TO "postgres";
GRANT ALL ON FUNCTION "public"."sum"("public"."halfvec") TO "anon";
GRANT ALL ON FUNCTION "public"."sum"("public"."halfvec") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sum"("public"."halfvec") TO "service_role";



GRANT ALL ON FUNCTION "public"."sum"("public"."vector") TO "postgres";
GRANT ALL ON FUNCTION "public"."sum"("public"."vector") TO "anon";
GRANT ALL ON FUNCTION "public"."sum"("public"."vector") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sum"("public"."vector") TO "service_role";









GRANT ALL ON TABLE "public"."_act_migrations" TO "anon";
GRANT ALL ON TABLE "public"."_act_migrations" TO "authenticated";
GRANT ALL ON TABLE "public"."_act_migrations" TO "service_role";



GRANT ALL ON SEQUENCE "public"."_act_migrations_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."_act_migrations_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."_act_migrations_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."receipt_status" TO "anon";
GRANT ALL ON TABLE "public"."receipt_status" TO "authenticated";
GRANT ALL ON TABLE "public"."receipt_status" TO "service_role";



GRANT ALL ON TABLE "public"."accounting_summary" TO "anon";
GRANT ALL ON TABLE "public"."accounting_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."accounting_summary" TO "service_role";



GRANT ALL ON TABLE "public"."wiki_page_links" TO "anon";
GRANT ALL ON TABLE "public"."wiki_page_links" TO "authenticated";
GRANT ALL ON TABLE "public"."wiki_page_links" TO "service_role";



GRANT ALL ON TABLE "public"."wiki_pages" TO "anon";
GRANT ALL ON TABLE "public"."wiki_pages" TO "authenticated";
GRANT ALL ON TABLE "public"."wiki_pages" TO "service_role";



GRANT ALL ON TABLE "public"."active_wiki_pages" TO "anon";
GRANT ALL ON TABLE "public"."active_wiki_pages" TO "authenticated";
GRANT ALL ON TABLE "public"."active_wiki_pages" TO "service_role";



GRANT ALL ON TABLE "public"."activities" TO "anon";
GRANT ALL ON TABLE "public"."activities" TO "authenticated";
GRANT ALL ON TABLE "public"."activities" TO "service_role";



GRANT ALL ON TABLE "public"."agent_actions" TO "anon";
GRANT ALL ON TABLE "public"."agent_actions" TO "authenticated";
GRANT ALL ON TABLE "public"."agent_actions" TO "service_role";



GRANT ALL ON TABLE "public"."agent_audit_log" TO "anon";
GRANT ALL ON TABLE "public"."agent_audit_log" TO "authenticated";
GRANT ALL ON TABLE "public"."agent_audit_log" TO "service_role";



GRANT ALL ON TABLE "public"."agent_registry" TO "anon";
GRANT ALL ON TABLE "public"."agent_registry" TO "authenticated";
GRANT ALL ON TABLE "public"."agent_registry" TO "service_role";



GRANT ALL ON TABLE "public"."agent_health_dashboard" TO "anon";
GRANT ALL ON TABLE "public"."agent_health_dashboard" TO "authenticated";
GRANT ALL ON TABLE "public"."agent_health_dashboard" TO "service_role";



GRANT ALL ON TABLE "public"."agent_learnings" TO "anon";
GRANT ALL ON TABLE "public"."agent_learnings" TO "authenticated";
GRANT ALL ON TABLE "public"."agent_learnings" TO "service_role";



GRANT ALL ON TABLE "public"."agent_performance" TO "anon";
GRANT ALL ON TABLE "public"."agent_performance" TO "authenticated";
GRANT ALL ON TABLE "public"."agent_performance" TO "service_role";



GRANT ALL ON TABLE "public"."agent_proposals" TO "anon";
GRANT ALL ON TABLE "public"."agent_proposals" TO "authenticated";
GRANT ALL ON TABLE "public"."agent_proposals" TO "service_role";



GRANT ALL ON TABLE "public"."agent_requests" TO "anon";
GRANT ALL ON TABLE "public"."agent_requests" TO "authenticated";
GRANT ALL ON TABLE "public"."agent_requests" TO "service_role";



GRANT ALL ON TABLE "public"."agent_task_queue" TO "anon";
GRANT ALL ON TABLE "public"."agent_task_queue" TO "authenticated";
GRANT ALL ON TABLE "public"."agent_task_queue" TO "service_role";



GRANT ALL ON TABLE "public"."agents" TO "anon";
GRANT ALL ON TABLE "public"."agents" TO "authenticated";
GRANT ALL ON TABLE "public"."agents" TO "service_role";



GRANT ALL ON TABLE "public"."agent_status" TO "anon";
GRANT ALL ON TABLE "public"."agent_status" TO "authenticated";
GRANT ALL ON TABLE "public"."agent_status" TO "service_role";



GRANT ALL ON TABLE "public"."agentic_chat" TO "anon";
GRANT ALL ON TABLE "public"."agentic_chat" TO "authenticated";
GRANT ALL ON TABLE "public"."agentic_chat" TO "service_role";



GRANT ALL ON TABLE "public"."agentic_project_dashboard" TO "anon";
GRANT ALL ON TABLE "public"."agentic_project_dashboard" TO "authenticated";
GRANT ALL ON TABLE "public"."agentic_project_dashboard" TO "service_role";



GRANT ALL ON TABLE "public"."agentic_projects" TO "anon";
GRANT ALL ON TABLE "public"."agentic_projects" TO "authenticated";
GRANT ALL ON TABLE "public"."agentic_projects" TO "service_role";



GRANT ALL ON TABLE "public"."agentic_tasks" TO "anon";
GRANT ALL ON TABLE "public"."agentic_tasks" TO "authenticated";
GRANT ALL ON TABLE "public"."agentic_tasks" TO "service_role";



GRANT ALL ON TABLE "public"."agentic_work_log" TO "anon";
GRANT ALL ON TABLE "public"."agentic_work_log" TO "authenticated";
GRANT ALL ON TABLE "public"."agentic_work_log" TO "service_role";



GRANT ALL ON TABLE "public"."ai_content_verifications" TO "anon";
GRANT ALL ON TABLE "public"."ai_content_verifications" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_content_verifications" TO "service_role";



GRANT ALL ON TABLE "public"."ai_discoveries" TO "anon";
GRANT ALL ON TABLE "public"."ai_discoveries" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_discoveries" TO "service_role";



GRANT ALL ON TABLE "public"."alma_community_contexts" TO "anon";
GRANT ALL ON TABLE "public"."alma_community_contexts" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_community_contexts" TO "service_role";



GRANT ALL ON TABLE "public"."alma_consent_ledger" TO "anon";
GRANT ALL ON TABLE "public"."alma_consent_ledger" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_consent_ledger" TO "service_role";



GRANT ALL ON TABLE "public"."alma_content_entities" TO "anon";
GRANT ALL ON TABLE "public"."alma_content_entities" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_content_entities" TO "service_role";



GRANT ALL ON TABLE "public"."alma_funding_data" TO "anon";
GRANT ALL ON TABLE "public"."alma_funding_data" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_funding_data" TO "service_role";



GRANT ALL ON TABLE "public"."alma_cost_analysis" TO "anon";
GRANT ALL ON TABLE "public"."alma_cost_analysis" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_cost_analysis" TO "service_role";



GRANT ALL ON TABLE "public"."alma_coverage_metrics" TO "anon";
GRANT ALL ON TABLE "public"."alma_coverage_metrics" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_coverage_metrics" TO "service_role";



GRANT ALL ON TABLE "public"."alma_media_articles" TO "anon";
GRANT ALL ON TABLE "public"."alma_media_articles" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_media_articles" TO "service_role";



GRANT ALL ON TABLE "public"."alma_daily_sentiment" TO "anon";
GRANT ALL ON TABLE "public"."alma_daily_sentiment" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_daily_sentiment" TO "service_role";



GRANT ALL ON TABLE "public"."alma_dashboard_funding" TO "anon";
GRANT ALL ON TABLE "public"."alma_dashboard_funding" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_dashboard_funding" TO "service_role";



GRANT ALL ON TABLE "public"."alma_interventions" TO "anon";
GRANT ALL ON TABLE "public"."alma_interventions" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_interventions" TO "service_role";



GRANT ALL ON TABLE "public"."alma_dashboard_interventions" TO "anon";
GRANT ALL ON TABLE "public"."alma_dashboard_interventions" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_dashboard_interventions" TO "service_role";



GRANT ALL ON TABLE "public"."alma_discovered_links" TO "anon";
GRANT ALL ON TABLE "public"."alma_discovered_links" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_discovered_links" TO "service_role";



GRANT ALL ON TABLE "public"."alma_dashboard_queue" TO "anon";
GRANT ALL ON TABLE "public"."alma_dashboard_queue" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_dashboard_queue" TO "service_role";



GRANT ALL ON TABLE "public"."alma_source_registry" TO "anon";
GRANT ALL ON TABLE "public"."alma_source_registry" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_source_registry" TO "service_role";



GRANT ALL ON TABLE "public"."alma_dashboard_sources" TO "anon";
GRANT ALL ON TABLE "public"."alma_dashboard_sources" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_dashboard_sources" TO "service_role";



GRANT ALL ON TABLE "public"."alma_entity_tags" TO "anon";
GRANT ALL ON TABLE "public"."alma_entity_tags" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_entity_tags" TO "service_role";



GRANT ALL ON TABLE "public"."alma_tags" TO "anon";
GRANT ALL ON TABLE "public"."alma_tags" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_tags" TO "service_role";



GRANT ALL ON TABLE "public"."alma_dashboard_tags" TO "anon";
GRANT ALL ON TABLE "public"."alma_dashboard_tags" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_dashboard_tags" TO "service_role";



GRANT ALL ON TABLE "public"."alma_embeddings" TO "anon";
GRANT ALL ON TABLE "public"."alma_embeddings" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_embeddings" TO "service_role";



GRANT ALL ON TABLE "public"."alma_entity_sources" TO "anon";
GRANT ALL ON TABLE "public"."alma_entity_sources" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_entity_sources" TO "service_role";



GRANT ALL ON TABLE "public"."alma_evidence" TO "anon";
GRANT ALL ON TABLE "public"."alma_evidence" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_evidence" TO "service_role";



GRANT ALL ON TABLE "public"."alma_evidence_outcomes" TO "anon";
GRANT ALL ON TABLE "public"."alma_evidence_outcomes" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_evidence_outcomes" TO "service_role";



GRANT ALL ON TABLE "public"."alma_external_source_cache" TO "anon";
GRANT ALL ON TABLE "public"."alma_external_source_cache" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_external_source_cache" TO "service_role";



GRANT ALL ON TABLE "public"."alma_extraction_patterns" TO "anon";
GRANT ALL ON TABLE "public"."alma_extraction_patterns" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_extraction_patterns" TO "service_role";



GRANT ALL ON TABLE "public"."alma_funding_applications" TO "anon";
GRANT ALL ON TABLE "public"."alma_funding_applications" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_funding_applications" TO "service_role";



GRANT ALL ON TABLE "public"."alma_funding_opportunities" TO "anon";
GRANT ALL ON TABLE "public"."alma_funding_opportunities" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_funding_opportunities" TO "service_role";



GRANT ALL ON TABLE "public"."alma_government_programs" TO "anon";
GRANT ALL ON TABLE "public"."alma_government_programs" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_government_programs" TO "service_role";



GRANT ALL ON TABLE "public"."alma_ingestion_jobs" TO "anon";
GRANT ALL ON TABLE "public"."alma_ingestion_jobs" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_ingestion_jobs" TO "service_role";



GRANT ALL ON TABLE "public"."alma_intervention_contexts" TO "anon";
GRANT ALL ON TABLE "public"."alma_intervention_contexts" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_intervention_contexts" TO "service_role";



GRANT ALL ON TABLE "public"."alma_intervention_evidence" TO "anon";
GRANT ALL ON TABLE "public"."alma_intervention_evidence" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_intervention_evidence" TO "service_role";



GRANT ALL ON TABLE "public"."alma_intervention_funding" TO "anon";
GRANT ALL ON TABLE "public"."alma_intervention_funding" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_intervention_funding" TO "service_role";



GRANT ALL ON TABLE "public"."alma_intervention_outcomes" TO "anon";
GRANT ALL ON TABLE "public"."alma_intervention_outcomes" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_intervention_outcomes" TO "service_role";



GRANT ALL ON TABLE "public"."alma_intervention_profiles" TO "anon";
GRANT ALL ON TABLE "public"."alma_intervention_profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_intervention_profiles" TO "service_role";



GRANT ALL ON TABLE "public"."alma_outcomes" TO "anon";
GRANT ALL ON TABLE "public"."alma_outcomes" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_outcomes" TO "service_role";



GRANT ALL ON TABLE "public"."registered_services" TO "anon";
GRANT ALL ON TABLE "public"."registered_services" TO "authenticated";
GRANT ALL ON TABLE "public"."registered_services" TO "service_role";



GRANT ALL ON TABLE "public"."alma_interventions_unified" TO "anon";
GRANT ALL ON TABLE "public"."alma_interventions_unified" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_interventions_unified" TO "service_role";



GRANT ALL ON TABLE "public"."alma_locations" TO "anon";
GRANT ALL ON TABLE "public"."alma_locations" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_locations" TO "service_role";



GRANT ALL ON TABLE "public"."alma_metrics_history" TO "anon";
GRANT ALL ON TABLE "public"."alma_metrics_history" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_metrics_history" TO "service_role";



GRANT ALL ON TABLE "public"."alma_program_interventions" TO "anon";
GRANT ALL ON TABLE "public"."alma_program_interventions" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_program_interventions" TO "service_role";



GRANT ALL ON TABLE "public"."alma_raw_content" TO "anon";
GRANT ALL ON TABLE "public"."alma_raw_content" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_raw_content" TO "service_role";



GRANT ALL ON TABLE "public"."alma_report_deliveries" TO "anon";
GRANT ALL ON TABLE "public"."alma_report_deliveries" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_report_deliveries" TO "service_role";



GRANT ALL ON TABLE "public"."alma_report_subscriptions" TO "anon";
GRANT ALL ON TABLE "public"."alma_report_subscriptions" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_report_subscriptions" TO "service_role";



GRANT ALL ON TABLE "public"."alma_research_findings" TO "anon";
GRANT ALL ON TABLE "public"."alma_research_findings" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_research_findings" TO "service_role";



GRANT ALL ON TABLE "public"."alma_research_sessions" TO "anon";
GRANT ALL ON TABLE "public"."alma_research_sessions" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_research_sessions" TO "service_role";



GRANT ALL ON TABLE "public"."alma_research_tool_logs" TO "anon";
GRANT ALL ON TABLE "public"."alma_research_tool_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_research_tool_logs" TO "service_role";



GRANT ALL ON TABLE "public"."alma_scrape_history" TO "anon";
GRANT ALL ON TABLE "public"."alma_scrape_history" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_scrape_history" TO "service_role";



GRANT ALL ON TABLE "public"."alma_sentiment_program_correlation" TO "anon";
GRANT ALL ON TABLE "public"."alma_sentiment_program_correlation" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_sentiment_program_correlation" TO "service_role";



GRANT ALL ON TABLE "public"."alma_source_documents" TO "anon";
GRANT ALL ON TABLE "public"."alma_source_documents" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_source_documents" TO "service_role";



GRANT ALL ON TABLE "public"."alma_unified_search" TO "anon";
GRANT ALL ON TABLE "public"."alma_unified_search" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_unified_search" TO "service_role";



GRANT ALL ON TABLE "public"."alma_usage_log" TO "anon";
GRANT ALL ON TABLE "public"."alma_usage_log" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_usage_log" TO "service_role";



GRANT ALL ON TABLE "public"."alma_weekly_reports" TO "anon";
GRANT ALL ON TABLE "public"."alma_weekly_reports" TO "authenticated";
GRANT ALL ON TABLE "public"."alma_weekly_reports" TO "service_role";



GRANT ALL ON TABLE "public"."analysis_jobs" TO "anon";
GRANT ALL ON TABLE "public"."analysis_jobs" TO "authenticated";
GRANT ALL ON TABLE "public"."analysis_jobs" TO "service_role";



GRANT ALL ON TABLE "public"."api_pricing" TO "anon";
GRANT ALL ON TABLE "public"."api_pricing" TO "authenticated";
GRANT ALL ON TABLE "public"."api_pricing" TO "service_role";



GRANT ALL ON TABLE "public"."api_usage" TO "anon";
GRANT ALL ON TABLE "public"."api_usage" TO "authenticated";
GRANT ALL ON TABLE "public"."api_usage" TO "service_role";



GRANT ALL ON TABLE "public"."app_users" TO "anon";
GRANT ALL ON TABLE "public"."app_users" TO "authenticated";
GRANT ALL ON TABLE "public"."app_users" TO "service_role";



GRANT ALL ON SEQUENCE "public"."app_users_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."app_users_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."app_users_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."art_innovation" TO "anon";
GRANT ALL ON TABLE "public"."art_innovation" TO "authenticated";
GRANT ALL ON TABLE "public"."art_innovation" TO "service_role";



GRANT ALL ON TABLE "public"."art_innovation_profiles" TO "anon";
GRANT ALL ON TABLE "public"."art_innovation_profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."art_innovation_profiles" TO "service_role";



GRANT ALL ON TABLE "public"."article_locations" TO "anon";
GRANT ALL ON TABLE "public"."article_locations" TO "authenticated";
GRANT ALL ON TABLE "public"."article_locations" TO "service_role";



GRANT ALL ON TABLE "public"."article_related_art" TO "anon";
GRANT ALL ON TABLE "public"."article_related_art" TO "authenticated";
GRANT ALL ON TABLE "public"."article_related_art" TO "service_role";



GRANT ALL ON TABLE "public"."article_related_articles" TO "anon";
GRANT ALL ON TABLE "public"."article_related_articles" TO "authenticated";
GRANT ALL ON TABLE "public"."article_related_articles" TO "service_role";



GRANT ALL ON TABLE "public"."article_related_evidence" TO "anon";
GRANT ALL ON TABLE "public"."article_related_evidence" TO "authenticated";
GRANT ALL ON TABLE "public"."article_related_evidence" TO "service_role";



GRANT ALL ON TABLE "public"."article_related_interventions" TO "anon";
GRANT ALL ON TABLE "public"."article_related_interventions" TO "authenticated";
GRANT ALL ON TABLE "public"."article_related_interventions" TO "service_role";



GRANT ALL ON TABLE "public"."article_related_programs" TO "anon";
GRANT ALL ON TABLE "public"."article_related_programs" TO "authenticated";
GRANT ALL ON TABLE "public"."article_related_programs" TO "service_role";



GRANT ALL ON TABLE "public"."article_related_services" TO "anon";
GRANT ALL ON TABLE "public"."article_related_services" TO "authenticated";
GRANT ALL ON TABLE "public"."article_related_services" TO "service_role";



GRANT ALL ON TABLE "public"."article_tags" TO "anon";
GRANT ALL ON TABLE "public"."article_tags" TO "authenticated";
GRANT ALL ON TABLE "public"."article_tags" TO "service_role";



GRANT ALL ON TABLE "public"."articles" TO "anon";
GRANT ALL ON TABLE "public"."articles" TO "authenticated";
GRANT ALL ON TABLE "public"."articles" TO "service_role";



GRANT ALL ON TABLE "public"."audit_logs" TO "anon";
GRANT ALL ON TABLE "public"."audit_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."audit_logs" TO "service_role";



GRANT ALL ON TABLE "public"."australian_frameworks" TO "anon";
GRANT ALL ON TABLE "public"."australian_frameworks" TO "authenticated";
GRANT ALL ON TABLE "public"."australian_frameworks" TO "service_role";



GRANT ALL ON TABLE "public"."authors" TO "anon";
GRANT ALL ON TABLE "public"."authors" TO "authenticated";
GRANT ALL ON TABLE "public"."authors" TO "service_role";



GRANT ALL ON TABLE "public"."auto_approval_quality" TO "anon";
GRANT ALL ON TABLE "public"."auto_approval_quality" TO "authenticated";
GRANT ALL ON TABLE "public"."auto_approval_quality" TO "service_role";



GRANT ALL ON TABLE "public"."automated_insights" TO "anon";
GRANT ALL ON TABLE "public"."automated_insights" TO "authenticated";
GRANT ALL ON TABLE "public"."automated_insights" TO "service_role";



GRANT ALL ON TABLE "public"."autonomous_executions" TO "anon";
GRANT ALL ON TABLE "public"."autonomous_executions" TO "authenticated";
GRANT ALL ON TABLE "public"."autonomous_executions" TO "service_role";



GRANT ALL ON TABLE "public"."autonomous_review_queue" TO "anon";
GRANT ALL ON TABLE "public"."autonomous_review_queue" TO "authenticated";
GRANT ALL ON TABLE "public"."autonomous_review_queue" TO "service_role";



GRANT ALL ON TABLE "public"."backups" TO "anon";
GRANT ALL ON TABLE "public"."backups" TO "authenticated";
GRANT ALL ON TABLE "public"."backups" TO "service_role";



GRANT ALL ON TABLE "public"."best_practices" TO "anon";
GRANT ALL ON TABLE "public"."best_practices" TO "authenticated";
GRANT ALL ON TABLE "public"."best_practices" TO "service_role";



GRANT ALL ON TABLE "public"."billing_coupons" TO "anon";
GRANT ALL ON TABLE "public"."billing_coupons" TO "authenticated";
GRANT ALL ON TABLE "public"."billing_coupons" TO "service_role";



GRANT ALL ON SEQUENCE "public"."billing_coupons_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."billing_coupons_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."billing_coupons_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."billing_customers" TO "anon";
GRANT ALL ON TABLE "public"."billing_customers" TO "authenticated";
GRANT ALL ON TABLE "public"."billing_customers" TO "service_role";



GRANT ALL ON SEQUENCE "public"."billing_customers_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."billing_customers_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."billing_customers_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."billing_invoice_lines" TO "anon";
GRANT ALL ON TABLE "public"."billing_invoice_lines" TO "authenticated";
GRANT ALL ON TABLE "public"."billing_invoice_lines" TO "service_role";



GRANT ALL ON SEQUENCE "public"."billing_invoice_lines_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."billing_invoice_lines_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."billing_invoice_lines_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."billing_invoices" TO "anon";
GRANT ALL ON TABLE "public"."billing_invoices" TO "authenticated";
GRANT ALL ON TABLE "public"."billing_invoices" TO "service_role";



GRANT ALL ON SEQUENCE "public"."billing_invoices_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."billing_invoices_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."billing_invoices_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."billing_payments" TO "anon";
GRANT ALL ON TABLE "public"."billing_payments" TO "authenticated";
GRANT ALL ON TABLE "public"."billing_payments" TO "service_role";



GRANT ALL ON SEQUENCE "public"."billing_payments_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."billing_payments_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."billing_payments_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."billing_prices" TO "anon";
GRANT ALL ON TABLE "public"."billing_prices" TO "authenticated";
GRANT ALL ON TABLE "public"."billing_prices" TO "service_role";



GRANT ALL ON SEQUENCE "public"."billing_prices_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."billing_prices_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."billing_prices_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."billing_products" TO "anon";
GRANT ALL ON TABLE "public"."billing_products" TO "authenticated";
GRANT ALL ON TABLE "public"."billing_products" TO "service_role";



GRANT ALL ON SEQUENCE "public"."billing_products_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."billing_products_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."billing_products_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."billing_subscription_items" TO "anon";
GRANT ALL ON TABLE "public"."billing_subscription_items" TO "authenticated";
GRANT ALL ON TABLE "public"."billing_subscription_items" TO "service_role";



GRANT ALL ON SEQUENCE "public"."billing_subscription_items_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."billing_subscription_items_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."billing_subscription_items_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."billing_subscriptions" TO "anon";
GRANT ALL ON TABLE "public"."billing_subscriptions" TO "authenticated";
GRANT ALL ON TABLE "public"."billing_subscriptions" TO "service_role";



GRANT ALL ON SEQUENCE "public"."billing_subscriptions_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."billing_subscriptions_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."billing_subscriptions_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."billing_tax_rates" TO "anon";
GRANT ALL ON TABLE "public"."billing_tax_rates" TO "authenticated";
GRANT ALL ON TABLE "public"."billing_tax_rates" TO "service_role";



GRANT ALL ON SEQUENCE "public"."billing_tax_rates_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."billing_tax_rates_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."billing_tax_rates_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."billing_tax_settings" TO "anon";
GRANT ALL ON TABLE "public"."billing_tax_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."billing_tax_settings" TO "service_role";



GRANT ALL ON TABLE "public"."billing_webhook_events" TO "anon";
GRANT ALL ON TABLE "public"."billing_webhook_events" TO "authenticated";
GRANT ALL ON TABLE "public"."billing_webhook_events" TO "service_role";



GRANT ALL ON SEQUENCE "public"."billing_webhook_events_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."billing_webhook_events_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."billing_webhook_events_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."blog_comments" TO "anon";
GRANT ALL ON TABLE "public"."blog_comments" TO "authenticated";
GRANT ALL ON TABLE "public"."blog_comments" TO "service_role";



GRANT ALL ON TABLE "public"."blog_content_links" TO "anon";
GRANT ALL ON TABLE "public"."blog_content_links" TO "authenticated";
GRANT ALL ON TABLE "public"."blog_content_links" TO "service_role";



GRANT ALL ON TABLE "public"."blog_media" TO "anon";
GRANT ALL ON TABLE "public"."blog_media" TO "authenticated";
GRANT ALL ON TABLE "public"."blog_media" TO "service_role";



GRANT ALL ON TABLE "public"."blog_posts" TO "anon";
GRANT ALL ON TABLE "public"."blog_posts" TO "authenticated";
GRANT ALL ON TABLE "public"."blog_posts" TO "service_role";



GRANT ALL ON TABLE "public"."blog_posts_profiles" TO "anon";
GRANT ALL ON TABLE "public"."blog_posts_profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."blog_posts_profiles" TO "service_role";



GRANT ALL ON TABLE "public"."bookkeeping_project_links" TO "anon";
GRANT ALL ON TABLE "public"."bookkeeping_project_links" TO "authenticated";
GRANT ALL ON TABLE "public"."bookkeeping_project_links" TO "service_role";



GRANT ALL ON SEQUENCE "public"."bookkeeping_project_links_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."bookkeeping_project_links_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."bookkeeping_project_links_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."bookkeeping_receipts" TO "anon";
GRANT ALL ON TABLE "public"."bookkeeping_receipts" TO "authenticated";
GRANT ALL ON TABLE "public"."bookkeeping_receipts" TO "service_role";



GRANT ALL ON SEQUENCE "public"."bookkeeping_receipts_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."bookkeeping_receipts_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."bookkeeping_receipts_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."bookkeeping_rules" TO "anon";
GRANT ALL ON TABLE "public"."bookkeeping_rules" TO "authenticated";
GRANT ALL ON TABLE "public"."bookkeeping_rules" TO "service_role";



GRANT ALL ON SEQUENCE "public"."bookkeeping_rules_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."bookkeeping_rules_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."bookkeeping_rules_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."bookkeeping_sync_state" TO "anon";
GRANT ALL ON TABLE "public"."bookkeeping_sync_state" TO "authenticated";
GRANT ALL ON TABLE "public"."bookkeeping_sync_state" TO "service_role";



GRANT ALL ON TABLE "public"."bookkeeping_transactions" TO "anon";
GRANT ALL ON TABLE "public"."bookkeeping_transactions" TO "authenticated";
GRANT ALL ON TABLE "public"."bookkeeping_transactions" TO "service_role";



GRANT ALL ON SEQUENCE "public"."bookkeeping_transactions_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."bookkeeping_transactions_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."bookkeeping_transactions_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."brand_tests" TO "anon";
GRANT ALL ON TABLE "public"."brand_tests" TO "authenticated";
GRANT ALL ON TABLE "public"."brand_tests" TO "service_role";



GRANT ALL ON TABLE "public"."business_agent_queries" TO "anon";
GRANT ALL ON TABLE "public"."business_agent_queries" TO "authenticated";
GRANT ALL ON TABLE "public"."business_agent_queries" TO "service_role";



GRANT ALL ON TABLE "public"."business_alerts" TO "anon";
GRANT ALL ON TABLE "public"."business_alerts" TO "authenticated";
GRANT ALL ON TABLE "public"."business_alerts" TO "service_role";



GRANT ALL ON TABLE "public"."businesses" TO "anon";
GRANT ALL ON TABLE "public"."businesses" TO "authenticated";
GRANT ALL ON TABLE "public"."businesses" TO "service_role";



GRANT ALL ON SEQUENCE "public"."businesses_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."businesses_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."businesses_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."calendar_events" TO "anon";
GRANT ALL ON TABLE "public"."calendar_events" TO "authenticated";
GRANT ALL ON TABLE "public"."calendar_events" TO "service_role";



GRANT ALL ON TABLE "public"."canonical_entities" TO "anon";
GRANT ALL ON TABLE "public"."canonical_entities" TO "authenticated";
GRANT ALL ON TABLE "public"."canonical_entities" TO "service_role";



GRANT ALL ON TABLE "public"."ce_activities" TO "anon";
GRANT ALL ON TABLE "public"."ce_activities" TO "authenticated";
GRANT ALL ON TABLE "public"."ce_activities" TO "service_role";



GRANT ALL ON TABLE "public"."ce_backups" TO "anon";
GRANT ALL ON TABLE "public"."ce_backups" TO "authenticated";
GRANT ALL ON TABLE "public"."ce_backups" TO "service_role";



GRANT ALL ON TABLE "public"."ce_brand_analyses" TO "anon";
GRANT ALL ON TABLE "public"."ce_brand_analyses" TO "authenticated";
GRANT ALL ON TABLE "public"."ce_brand_analyses" TO "service_role";



GRANT ALL ON TABLE "public"."ce_brand_tests" TO "anon";
GRANT ALL ON TABLE "public"."ce_brand_tests" TO "authenticated";
GRANT ALL ON TABLE "public"."ce_brand_tests" TO "service_role";



GRANT ALL ON TABLE "public"."ce_media_assets" TO "anon";
GRANT ALL ON TABLE "public"."ce_media_assets" TO "authenticated";
GRANT ALL ON TABLE "public"."ce_media_assets" TO "service_role";



GRANT ALL ON TABLE "public"."ce_metrics" TO "anon";
GRANT ALL ON TABLE "public"."ce_metrics" TO "authenticated";
GRANT ALL ON TABLE "public"."ce_metrics" TO "service_role";



GRANT ALL ON TABLE "public"."ce_saved_searches" TO "anon";
GRANT ALL ON TABLE "public"."ce_saved_searches" TO "authenticated";
GRANT ALL ON TABLE "public"."ce_saved_searches" TO "service_role";



GRANT ALL ON TABLE "public"."ce_search_history" TO "anon";
GRANT ALL ON TABLE "public"."ce_search_history" TO "authenticated";
GRANT ALL ON TABLE "public"."ce_search_history" TO "service_role";



GRANT ALL ON TABLE "public"."ce_stories" TO "anon";
GRANT ALL ON TABLE "public"."ce_stories" TO "authenticated";
GRANT ALL ON TABLE "public"."ce_stories" TO "service_role";



GRANT ALL ON TABLE "public"."ce_users" TO "anon";
GRANT ALL ON TABLE "public"."ce_users" TO "authenticated";
GRANT ALL ON TABLE "public"."ce_users" TO "service_role";



GRANT ALL ON TABLE "public"."channel_messages" TO "anon";
GRANT ALL ON TABLE "public"."channel_messages" TO "authenticated";
GRANT ALL ON TABLE "public"."channel_messages" TO "service_role";



GRANT ALL ON TABLE "public"."clearinghouse_documents" TO "anon";
GRANT ALL ON TABLE "public"."clearinghouse_documents" TO "authenticated";
GRANT ALL ON TABLE "public"."clearinghouse_documents" TO "service_role";



GRANT ALL ON TABLE "public"."cms_content_blocks" TO "anon";
GRANT ALL ON TABLE "public"."cms_content_blocks" TO "authenticated";
GRANT ALL ON TABLE "public"."cms_content_blocks" TO "service_role";



GRANT ALL ON TABLE "public"."cms_media" TO "anon";
GRANT ALL ON TABLE "public"."cms_media" TO "authenticated";
GRANT ALL ON TABLE "public"."cms_media" TO "service_role";



GRANT ALL ON TABLE "public"."cms_pages" TO "anon";
GRANT ALL ON TABLE "public"."cms_pages" TO "authenticated";
GRANT ALL ON TABLE "public"."cms_pages" TO "service_role";



GRANT ALL ON TABLE "public"."coe_key_people" TO "anon";
GRANT ALL ON TABLE "public"."coe_key_people" TO "authenticated";
GRANT ALL ON TABLE "public"."coe_key_people" TO "service_role";



GRANT ALL ON TABLE "public"."coe_key_people_v" TO "anon";
GRANT ALL ON TABLE "public"."coe_key_people_v" TO "authenticated";
GRANT ALL ON TABLE "public"."coe_key_people_v" TO "service_role";



GRANT ALL ON TABLE "public"."collection_media" TO "anon";
GRANT ALL ON TABLE "public"."collection_media" TO "authenticated";
GRANT ALL ON TABLE "public"."collection_media" TO "service_role";



GRANT ALL ON TABLE "public"."communications_history" TO "anon";
GRANT ALL ON TABLE "public"."communications_history" TO "authenticated";
GRANT ALL ON TABLE "public"."communications_history" TO "service_role";



GRANT ALL ON TABLE "public"."community_connections" TO "anon";
GRANT ALL ON TABLE "public"."community_connections" TO "authenticated";
GRANT ALL ON TABLE "public"."community_connections" TO "service_role";



GRANT ALL ON TABLE "public"."community_events" TO "anon";
GRANT ALL ON TABLE "public"."community_events" TO "authenticated";
GRANT ALL ON TABLE "public"."community_events" TO "service_role";



GRANT ALL ON TABLE "public"."community_engagement_overview" TO "anon";
GRANT ALL ON TABLE "public"."community_engagement_overview" TO "authenticated";
GRANT ALL ON TABLE "public"."community_engagement_overview" TO "service_role";



GRANT ALL ON TABLE "public"."community_feedback" TO "anon";
GRANT ALL ON TABLE "public"."community_feedback" TO "authenticated";
GRANT ALL ON TABLE "public"."community_feedback" TO "service_role";



GRANT ALL ON TABLE "public"."community_health_metrics" TO "anon";
GRANT ALL ON TABLE "public"."community_health_metrics" TO "authenticated";
GRANT ALL ON TABLE "public"."community_health_metrics" TO "service_role";



GRANT ALL ON TABLE "public"."community_inquiries" TO "anon";
GRANT ALL ON TABLE "public"."community_inquiries" TO "authenticated";
GRANT ALL ON TABLE "public"."community_inquiries" TO "service_role";



GRANT ALL ON TABLE "public"."registered_services_profiles" TO "anon";
GRANT ALL ON TABLE "public"."registered_services_profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."registered_services_profiles" TO "service_role";



GRANT ALL ON TABLE "public"."community_programs_profiles_v" TO "anon";
GRANT ALL ON TABLE "public"."community_programs_profiles_v" TO "authenticated";
GRANT ALL ON TABLE "public"."community_programs_profiles_v" TO "service_role";



GRANT ALL ON TABLE "public"."compliance_tracking" TO "anon";
GRANT ALL ON TABLE "public"."compliance_tracking" TO "authenticated";
GRANT ALL ON TABLE "public"."compliance_tracking" TO "service_role";



GRANT ALL ON TABLE "public"."consent_management" TO "anon";
GRANT ALL ON TABLE "public"."consent_management" TO "authenticated";
GRANT ALL ON TABLE "public"."consent_management" TO "service_role";



GRANT ALL ON TABLE "public"."consent_records" TO "anon";
GRANT ALL ON TABLE "public"."consent_records" TO "authenticated";
GRANT ALL ON TABLE "public"."consent_records" TO "service_role";



GRANT ALL ON TABLE "public"."email_financial_documents" TO "anon";
GRANT ALL ON TABLE "public"."email_financial_documents" TO "authenticated";
GRANT ALL ON TABLE "public"."email_financial_documents" TO "service_role";



GRANT ALL ON TABLE "public"."consolidation_progress" TO "anon";
GRANT ALL ON TABLE "public"."consolidation_progress" TO "authenticated";
GRANT ALL ON TABLE "public"."consolidation_progress" TO "service_role";



GRANT ALL ON TABLE "public"."contact_cadence_metrics" TO "anon";
GRANT ALL ON TABLE "public"."contact_cadence_metrics" TO "authenticated";
GRANT ALL ON TABLE "public"."contact_cadence_metrics" TO "service_role";



GRANT ALL ON TABLE "public"."contact_communications" TO "anon";
GRANT ALL ON TABLE "public"."contact_communications" TO "authenticated";
GRANT ALL ON TABLE "public"."contact_communications" TO "service_role";



GRANT ALL ON TABLE "public"."contact_edges" TO "anon";
GRANT ALL ON TABLE "public"."contact_edges" TO "authenticated";
GRANT ALL ON TABLE "public"."contact_edges" TO "service_role";



GRANT ALL ON SEQUENCE "public"."contact_edges_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."contact_edges_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."contact_edges_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."contact_enrichments" TO "anon";
GRANT ALL ON TABLE "public"."contact_enrichments" TO "authenticated";
GRANT ALL ON TABLE "public"."contact_enrichments" TO "service_role";



GRANT ALL ON TABLE "public"."contact_intelligence" TO "anon";
GRANT ALL ON TABLE "public"."contact_intelligence" TO "authenticated";
GRANT ALL ON TABLE "public"."contact_intelligence" TO "service_role";



GRANT ALL ON TABLE "public"."contact_intelligence_insights" TO "anon";
GRANT ALL ON TABLE "public"."contact_intelligence_insights" TO "authenticated";
GRANT ALL ON TABLE "public"."contact_intelligence_insights" TO "service_role";



GRANT ALL ON TABLE "public"."contact_intelligence_scores" TO "anon";
GRANT ALL ON TABLE "public"."contact_intelligence_scores" TO "authenticated";
GRANT ALL ON TABLE "public"."contact_intelligence_scores" TO "service_role";



GRANT ALL ON TABLE "public"."contact_interactions" TO "anon";
GRANT ALL ON TABLE "public"."contact_interactions" TO "authenticated";
GRANT ALL ON TABLE "public"."contact_interactions" TO "service_role";



GRANT ALL ON TABLE "public"."contact_invites" TO "anon";
GRANT ALL ON TABLE "public"."contact_invites" TO "authenticated";
GRANT ALL ON TABLE "public"."contact_invites" TO "service_role";



GRANT ALL ON SEQUENCE "public"."contact_invites_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."contact_invites_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."contact_invites_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."contact_project_links" TO "anon";
GRANT ALL ON TABLE "public"."contact_project_links" TO "authenticated";
GRANT ALL ON TABLE "public"."contact_project_links" TO "service_role";



GRANT ALL ON TABLE "public"."contact_review_decisions" TO "anon";
GRANT ALL ON TABLE "public"."contact_review_decisions" TO "authenticated";
GRANT ALL ON TABLE "public"."contact_review_decisions" TO "service_role";



GRANT ALL ON TABLE "public"."contact_support_preferences" TO "anon";
GRANT ALL ON TABLE "public"."contact_support_preferences" TO "authenticated";
GRANT ALL ON TABLE "public"."contact_support_preferences" TO "service_role";



GRANT ALL ON TABLE "public"."contact_support_recommendations" TO "anon";
GRANT ALL ON TABLE "public"."contact_support_recommendations" TO "authenticated";
GRANT ALL ON TABLE "public"."contact_support_recommendations" TO "service_role";



GRANT ALL ON TABLE "public"."content_link_suggestions" TO "anon";
GRANT ALL ON TABLE "public"."content_link_suggestions" TO "authenticated";
GRANT ALL ON TABLE "public"."content_link_suggestions" TO "service_role";



GRANT ALL ON TABLE "public"."conversation_context" TO "anon";
GRANT ALL ON TABLE "public"."conversation_context" TO "authenticated";
GRANT ALL ON TABLE "public"."conversation_context" TO "service_role";



GRANT ALL ON TABLE "public"."coordinating_tasks" TO "anon";
GRANT ALL ON TABLE "public"."coordinating_tasks" TO "authenticated";
GRANT ALL ON TABLE "public"."coordinating_tasks" TO "service_role";



GRANT ALL ON TABLE "public"."cultural_liaisons" TO "anon";
GRANT ALL ON TABLE "public"."cultural_liaisons" TO "authenticated";
GRANT ALL ON TABLE "public"."cultural_liaisons" TO "service_role";



GRANT ALL ON TABLE "public"."cultural_protocols" TO "anon";
GRANT ALL ON TABLE "public"."cultural_protocols" TO "authenticated";
GRANT ALL ON TABLE "public"."cultural_protocols" TO "service_role";



GRANT ALL ON TABLE "public"."cultural_review_queue" TO "anon";
GRANT ALL ON TABLE "public"."cultural_review_queue" TO "authenticated";
GRANT ALL ON TABLE "public"."cultural_review_queue" TO "service_role";



GRANT ALL ON TABLE "public"."knowledge_versions" TO "anon";
GRANT ALL ON TABLE "public"."knowledge_versions" TO "authenticated";
GRANT ALL ON TABLE "public"."knowledge_versions" TO "service_role";



GRANT ALL ON TABLE "public"."current_knowledge" TO "anon";
GRANT ALL ON TABLE "public"."current_knowledge" TO "authenticated";
GRANT ALL ON TABLE "public"."current_knowledge" TO "service_role";



GRANT ALL ON TABLE "public"."data_quality_audit" TO "anon";
GRANT ALL ON TABLE "public"."data_quality_audit" TO "authenticated";
GRANT ALL ON TABLE "public"."data_quality_audit" TO "service_role";



GRANT ALL ON TABLE "public"."data_quality_metrics" TO "anon";
GRANT ALL ON TABLE "public"."data_quality_metrics" TO "authenticated";
GRANT ALL ON TABLE "public"."data_quality_metrics" TO "service_role";



GRANT ALL ON TABLE "public"."data_sources" TO "anon";
GRANT ALL ON TABLE "public"."data_sources" TO "authenticated";
GRANT ALL ON TABLE "public"."data_sources" TO "service_role";



GRANT ALL ON TABLE "public"."decision_outcomes" TO "anon";
GRANT ALL ON TABLE "public"."decision_outcomes" TO "authenticated";
GRANT ALL ON TABLE "public"."decision_outcomes" TO "service_role";



GRANT ALL ON TABLE "public"."decisions" TO "anon";
GRANT ALL ON TABLE "public"."decisions" TO "authenticated";
GRANT ALL ON TABLE "public"."decisions" TO "service_role";



GRANT ALL ON TABLE "public"."decision_analytics" TO "anon";
GRANT ALL ON TABLE "public"."decision_analytics" TO "authenticated";
GRANT ALL ON TABLE "public"."decision_analytics" TO "service_role";



GRANT ALL ON TABLE "public"."decision_patterns" TO "anon";
GRANT ALL ON TABLE "public"."decision_patterns" TO "authenticated";
GRANT ALL ON TABLE "public"."decision_patterns" TO "service_role";



GRANT ALL ON TABLE "public"."decision_traces" TO "anon";
GRANT ALL ON TABLE "public"."decision_traces" TO "authenticated";
GRANT ALL ON TABLE "public"."decision_traces" TO "service_role";



GRANT ALL ON TABLE "public"."delegated_tasks" TO "anon";
GRANT ALL ON TABLE "public"."delegated_tasks" TO "authenticated";
GRANT ALL ON TABLE "public"."delegated_tasks" TO "service_role";



GRANT ALL ON TABLE "public"."discovered_subscriptions" TO "anon";
GRANT ALL ON TABLE "public"."discovered_subscriptions" TO "authenticated";
GRANT ALL ON TABLE "public"."discovered_subscriptions" TO "service_role";



GRANT ALL ON TABLE "public"."donations" TO "anon";
GRANT ALL ON TABLE "public"."donations" TO "authenticated";
GRANT ALL ON TABLE "public"."donations" TO "service_role";



GRANT ALL ON TABLE "public"."ecosystem_projects" TO "anon";
GRANT ALL ON TABLE "public"."ecosystem_projects" TO "authenticated";
GRANT ALL ON TABLE "public"."ecosystem_projects" TO "service_role";



GRANT ALL ON TABLE "public"."ecosystem_sites" TO "anon";
GRANT ALL ON TABLE "public"."ecosystem_sites" TO "authenticated";
GRANT ALL ON TABLE "public"."ecosystem_sites" TO "service_role";



GRANT ALL ON TABLE "public"."elder_review_queue" TO "anon";
GRANT ALL ON TABLE "public"."elder_review_queue" TO "authenticated";
GRANT ALL ON TABLE "public"."elder_review_queue" TO "service_role";



GRANT ALL ON TABLE "public"."entity_identifiers" TO "anon";
GRANT ALL ON TABLE "public"."entity_identifiers" TO "authenticated";
GRANT ALL ON TABLE "public"."entity_identifiers" TO "service_role";



GRANT ALL ON TABLE "public"."enrichment_ready_contacts" TO "anon";
GRANT ALL ON TABLE "public"."enrichment_ready_contacts" TO "authenticated";
GRANT ALL ON TABLE "public"."enrichment_ready_contacts" TO "service_role";



GRANT ALL ON TABLE "public"."enrichment_reviews" TO "anon";
GRANT ALL ON TABLE "public"."enrichment_reviews" TO "authenticated";
GRANT ALL ON TABLE "public"."enrichment_reviews" TO "service_role";



GRANT ALL ON TABLE "public"."entities" TO "anon";
GRANT ALL ON TABLE "public"."entities" TO "authenticated";
GRANT ALL ON TABLE "public"."entities" TO "service_role";



GRANT ALL ON TABLE "public"."entity_mappings" TO "anon";
GRANT ALL ON TABLE "public"."entity_mappings" TO "authenticated";
GRANT ALL ON TABLE "public"."entity_mappings" TO "service_role";



GRANT ALL ON TABLE "public"."entity_merge_log" TO "anon";
GRANT ALL ON TABLE "public"."entity_merge_log" TO "authenticated";
GRANT ALL ON TABLE "public"."entity_merge_log" TO "service_role";



GRANT ALL ON TABLE "public"."entity_potential_matches" TO "anon";
GRANT ALL ON TABLE "public"."entity_potential_matches" TO "authenticated";
GRANT ALL ON TABLE "public"."entity_potential_matches" TO "service_role";



GRANT ALL ON TABLE "public"."entity_relationships" TO "anon";
GRANT ALL ON TABLE "public"."entity_relationships" TO "authenticated";
GRANT ALL ON TABLE "public"."entity_relationships" TO "service_role";



GRANT ALL ON TABLE "public"."event_registrations" TO "anon";
GRANT ALL ON TABLE "public"."event_registrations" TO "authenticated";
GRANT ALL ON TABLE "public"."event_registrations" TO "service_role";



GRANT ALL ON TABLE "public"."events" TO "anon";
GRANT ALL ON TABLE "public"."events" TO "authenticated";
GRANT ALL ON TABLE "public"."events" TO "service_role";



GRANT ALL ON TABLE "public"."events_old_backup" TO "anon";
GRANT ALL ON TABLE "public"."events_old_backup" TO "authenticated";
GRANT ALL ON TABLE "public"."events_old_backup" TO "service_role";



GRANT ALL ON SEQUENCE "public"."events_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."events_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."events_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."exa_api_usage" TO "anon";
GRANT ALL ON TABLE "public"."exa_api_usage" TO "authenticated";
GRANT ALL ON TABLE "public"."exa_api_usage" TO "service_role";



GRANT ALL ON TABLE "public"."exa_company_intelligence" TO "anon";
GRANT ALL ON TABLE "public"."exa_company_intelligence" TO "authenticated";
GRANT ALL ON TABLE "public"."exa_company_intelligence" TO "service_role";



GRANT ALL ON TABLE "public"."exa_enrichment_queue" TO "anon";
GRANT ALL ON TABLE "public"."exa_enrichment_queue" TO "authenticated";
GRANT ALL ON TABLE "public"."exa_enrichment_queue" TO "service_role";



GRANT ALL ON TABLE "public"."exa_linkedin_profiles" TO "anon";
GRANT ALL ON TABLE "public"."exa_linkedin_profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."exa_linkedin_profiles" TO "service_role";



GRANT ALL ON TABLE "public"."exa_media_mentions" TO "anon";
GRANT ALL ON TABLE "public"."exa_media_mentions" TO "authenticated";
GRANT ALL ON TABLE "public"."exa_media_mentions" TO "service_role";



GRANT ALL ON TABLE "public"."facility_partnerships" TO "anon";
GRANT ALL ON TABLE "public"."facility_partnerships" TO "authenticated";
GRANT ALL ON TABLE "public"."facility_partnerships" TO "service_role";



GRANT ALL ON TABLE "public"."facility_statistics" TO "anon";
GRANT ALL ON TABLE "public"."facility_statistics" TO "authenticated";
GRANT ALL ON TABLE "public"."facility_statistics" TO "service_role";



GRANT ALL ON TABLE "public"."fellows" TO "anon";
GRANT ALL ON TABLE "public"."fellows" TO "authenticated";
GRANT ALL ON TABLE "public"."fellows" TO "service_role";



GRANT ALL ON SEQUENCE "public"."fellows_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."fellows_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."fellows_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."financial_by_account" TO "anon";
GRANT ALL ON TABLE "public"."financial_by_account" TO "authenticated";
GRANT ALL ON TABLE "public"."financial_by_account" TO "service_role";



GRANT ALL ON TABLE "public"."financial_monthly_summary" TO "anon";
GRANT ALL ON TABLE "public"."financial_monthly_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."financial_monthly_summary" TO "service_role";



GRANT ALL ON TABLE "public"."financial_project_summaries" TO "anon";
GRANT ALL ON TABLE "public"."financial_project_summaries" TO "authenticated";
GRANT ALL ON TABLE "public"."financial_project_summaries" TO "service_role";



GRANT ALL ON TABLE "public"."financial_summary" TO "anon";
GRANT ALL ON TABLE "public"."financial_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."financial_summary" TO "service_role";



GRANT ALL ON TABLE "public"."ghl_contacts" TO "anon";
GRANT ALL ON TABLE "public"."ghl_contacts" TO "authenticated";
GRANT ALL ON TABLE "public"."ghl_contacts" TO "service_role";



GRANT ALL ON TABLE "public"."ghl_engagement_metrics" TO "anon";
GRANT ALL ON TABLE "public"."ghl_engagement_metrics" TO "authenticated";
GRANT ALL ON TABLE "public"."ghl_engagement_metrics" TO "service_role";



GRANT ALL ON TABLE "public"."ghl_opportunities" TO "anon";
GRANT ALL ON TABLE "public"."ghl_opportunities" TO "authenticated";
GRANT ALL ON TABLE "public"."ghl_opportunities" TO "service_role";



GRANT ALL ON TABLE "public"."ghl_pipelines" TO "anon";
GRANT ALL ON TABLE "public"."ghl_pipelines" TO "authenticated";
GRANT ALL ON TABLE "public"."ghl_pipelines" TO "service_role";



GRANT ALL ON TABLE "public"."ghl_sync_log" TO "anon";
GRANT ALL ON TABLE "public"."ghl_sync_log" TO "authenticated";
GRANT ALL ON TABLE "public"."ghl_sync_log" TO "service_role";



GRANT ALL ON TABLE "public"."ghl_tags" TO "anon";
GRANT ALL ON TABLE "public"."ghl_tags" TO "authenticated";
GRANT ALL ON TABLE "public"."ghl_tags" TO "service_role";



GRANT ALL ON TABLE "public"."gmail_auth_tokens" TO "anon";
GRANT ALL ON TABLE "public"."gmail_auth_tokens" TO "authenticated";
GRANT ALL ON TABLE "public"."gmail_auth_tokens" TO "service_role";



GRANT ALL ON TABLE "public"."gmail_contacts" TO "anon";
GRANT ALL ON TABLE "public"."gmail_contacts" TO "authenticated";
GRANT ALL ON TABLE "public"."gmail_contacts" TO "service_role";



GRANT ALL ON TABLE "public"."gmail_messages" TO "anon";
GRANT ALL ON TABLE "public"."gmail_messages" TO "authenticated";
GRANT ALL ON TABLE "public"."gmail_messages" TO "service_role";



GRANT ALL ON TABLE "public"."gmail_sync_state" TO "anon";
GRANT ALL ON TABLE "public"."gmail_sync_state" TO "authenticated";
GRANT ALL ON TABLE "public"."gmail_sync_state" TO "service_role";



GRANT ALL ON TABLE "public"."knowledge_extraction_queue" TO "anon";
GRANT ALL ON TABLE "public"."knowledge_extraction_queue" TO "authenticated";
GRANT ALL ON TABLE "public"."knowledge_extraction_queue" TO "service_role";



GRANT ALL ON TABLE "public"."gmail_sync_stats" TO "anon";
GRANT ALL ON TABLE "public"."gmail_sync_stats" TO "authenticated";
GRANT ALL ON TABLE "public"."gmail_sync_stats" TO "service_role";



GRANT ALL ON TABLE "public"."gmail_sync_status" TO "anon";
GRANT ALL ON TABLE "public"."gmail_sync_status" TO "authenticated";
GRANT ALL ON TABLE "public"."gmail_sync_status" TO "service_role";



GRANT ALL ON TABLE "public"."goal_metrics" TO "anon";
GRANT ALL ON TABLE "public"."goal_metrics" TO "authenticated";
GRANT ALL ON TABLE "public"."goal_metrics" TO "service_role";



GRANT ALL ON TABLE "public"."goal_updates" TO "anon";
GRANT ALL ON TABLE "public"."goal_updates" TO "authenticated";
GRANT ALL ON TABLE "public"."goal_updates" TO "service_role";



GRANT ALL ON TABLE "public"."goals_2026" TO "anon";
GRANT ALL ON TABLE "public"."goals_2026" TO "authenticated";
GRANT ALL ON TABLE "public"."goals_2026" TO "service_role";



GRANT ALL ON TABLE "public"."goal_progress_summary" TO "anon";
GRANT ALL ON TABLE "public"."goal_progress_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."goal_progress_summary" TO "service_role";



GRANT ALL ON TABLE "public"."grant_financial_tracking" TO "anon";
GRANT ALL ON TABLE "public"."grant_financial_tracking" TO "authenticated";
GRANT ALL ON TABLE "public"."grant_financial_tracking" TO "service_role";



GRANT ALL ON TABLE "public"."grant_opportunities" TO "anon";
GRANT ALL ON TABLE "public"."grant_opportunities" TO "authenticated";
GRANT ALL ON TABLE "public"."grant_opportunities" TO "service_role";



GRANT ALL ON TABLE "public"."harvest_businesses" TO "anon";
GRANT ALL ON TABLE "public"."harvest_businesses" TO "authenticated";
GRANT ALL ON TABLE "public"."harvest_businesses" TO "service_role";



GRANT ALL ON SEQUENCE "public"."harvest_businesses_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."harvest_businesses_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."harvest_businesses_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."harvest_events" TO "anon";
GRANT ALL ON TABLE "public"."harvest_events" TO "authenticated";
GRANT ALL ON TABLE "public"."harvest_events" TO "service_role";



GRANT ALL ON SEQUENCE "public"."harvest_events_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."harvest_events_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."harvest_events_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."health_alerts" TO "anon";
GRANT ALL ON TABLE "public"."health_alerts" TO "authenticated";
GRANT ALL ON TABLE "public"."health_alerts" TO "service_role";



GRANT ALL ON TABLE "public"."historical_inquiries" TO "anon";
GRANT ALL ON TABLE "public"."historical_inquiries" TO "authenticated";
GRANT ALL ON TABLE "public"."historical_inquiries" TO "service_role";



GRANT ALL ON TABLE "public"."ignored_email_patterns" TO "anon";
GRANT ALL ON TABLE "public"."ignored_email_patterns" TO "authenticated";
GRANT ALL ON TABLE "public"."ignored_email_patterns" TO "service_role";



GRANT ALL ON TABLE "public"."impact_evidence" TO "anon";
GRANT ALL ON TABLE "public"."impact_evidence" TO "authenticated";
GRANT ALL ON TABLE "public"."impact_evidence" TO "service_role";



GRANT ALL ON TABLE "public"."impact_stories" TO "anon";
GRANT ALL ON TABLE "public"."impact_stories" TO "authenticated";
GRANT ALL ON TABLE "public"."impact_stories" TO "service_role";



GRANT ALL ON TABLE "public"."intelligence_briefings" TO "anon";
GRANT ALL ON TABLE "public"."intelligence_briefings" TO "authenticated";
GRANT ALL ON TABLE "public"."intelligence_briefings" TO "service_role";



GRANT ALL ON TABLE "public"."intelligence_geo_alerts" TO "anon";
GRANT ALL ON TABLE "public"."intelligence_geo_alerts" TO "authenticated";
GRANT ALL ON TABLE "public"."intelligence_geo_alerts" TO "service_role";



GRANT ALL ON TABLE "public"."intelligence_refusals" TO "anon";
GRANT ALL ON TABLE "public"."intelligence_refusals" TO "authenticated";
GRANT ALL ON TABLE "public"."intelligence_refusals" TO "service_role";



GRANT ALL ON TABLE "public"."interactions" TO "anon";
GRANT ALL ON TABLE "public"."interactions" TO "authenticated";
GRANT ALL ON TABLE "public"."interactions" TO "service_role";



GRANT ALL ON SEQUENCE "public"."interactions_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."interactions_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."interactions_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."international_invitations" TO "anon";
GRANT ALL ON TABLE "public"."international_invitations" TO "authenticated";
GRANT ALL ON TABLE "public"."international_invitations" TO "service_role";



GRANT ALL ON TABLE "public"."international_programs" TO "anon";
GRANT ALL ON TABLE "public"."international_programs" TO "authenticated";
GRANT ALL ON TABLE "public"."international_programs" TO "service_role";



GRANT ALL ON TABLE "public"."justice_matrix_campaigns" TO "anon";
GRANT ALL ON TABLE "public"."justice_matrix_campaigns" TO "authenticated";
GRANT ALL ON TABLE "public"."justice_matrix_campaigns" TO "service_role";



GRANT ALL ON TABLE "public"."justice_matrix_cases" TO "anon";
GRANT ALL ON TABLE "public"."justice_matrix_cases" TO "authenticated";
GRANT ALL ON TABLE "public"."justice_matrix_cases" TO "service_role";



GRANT ALL ON TABLE "public"."justice_matrix_discovered" TO "anon";
GRANT ALL ON TABLE "public"."justice_matrix_discovered" TO "authenticated";
GRANT ALL ON TABLE "public"."justice_matrix_discovered" TO "service_role";



GRANT ALL ON TABLE "public"."justice_matrix_resources" TO "anon";
GRANT ALL ON TABLE "public"."justice_matrix_resources" TO "authenticated";
GRANT ALL ON TABLE "public"."justice_matrix_resources" TO "service_role";



GRANT ALL ON TABLE "public"."justice_matrix_scrape_logs" TO "anon";
GRANT ALL ON TABLE "public"."justice_matrix_scrape_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."justice_matrix_scrape_logs" TO "service_role";



GRANT ALL ON TABLE "public"."justice_matrix_sources" TO "anon";
GRANT ALL ON TABLE "public"."justice_matrix_sources" TO "authenticated";
GRANT ALL ON TABLE "public"."justice_matrix_sources" TO "service_role";



GRANT ALL ON TABLE "public"."justicehub_nodes" TO "anon";
GRANT ALL ON TABLE "public"."justicehub_nodes" TO "authenticated";
GRANT ALL ON TABLE "public"."justicehub_nodes" TO "service_role";



GRANT ALL ON TABLE "public"."knowledge_chunks" TO "anon";
GRANT ALL ON TABLE "public"."knowledge_chunks" TO "authenticated";
GRANT ALL ON TABLE "public"."knowledge_chunks" TO "service_role";



GRANT ALL ON TABLE "public"."pmpp_knowledge" TO "anon";
GRANT ALL ON TABLE "public"."pmpp_knowledge" TO "authenticated";
GRANT ALL ON TABLE "public"."pmpp_knowledge" TO "service_role";



GRANT ALL ON TABLE "public"."knowledge_review_schedule" TO "anon";
GRANT ALL ON TABLE "public"."knowledge_review_schedule" TO "authenticated";
GRANT ALL ON TABLE "public"."knowledge_review_schedule" TO "service_role";



GRANT ALL ON TABLE "public"."knowledge_source_sync" TO "anon";
GRANT ALL ON TABLE "public"."knowledge_source_sync" TO "authenticated";
GRANT ALL ON TABLE "public"."knowledge_source_sync" TO "service_role";



GRANT ALL ON TABLE "public"."knowledge_source_health" TO "anon";
GRANT ALL ON TABLE "public"."knowledge_source_health" TO "authenticated";
GRANT ALL ON TABLE "public"."knowledge_source_health" TO "service_role";



GRANT ALL ON TABLE "public"."knowledge_sources" TO "anon";
GRANT ALL ON TABLE "public"."knowledge_sources" TO "authenticated";
GRANT ALL ON TABLE "public"."knowledge_sources" TO "service_role";



GRANT ALL ON TABLE "public"."learned_thresholds" TO "anon";
GRANT ALL ON TABLE "public"."learned_thresholds" TO "authenticated";
GRANT ALL ON TABLE "public"."learned_thresholds" TO "service_role";



GRANT ALL ON TABLE "public"."linkedin_contacts" TO "anon";
GRANT ALL ON TABLE "public"."linkedin_contacts" TO "authenticated";
GRANT ALL ON TABLE "public"."linkedin_contacts" TO "service_role";



GRANT ALL ON TABLE "public"."linkedin_imports" TO "anon";
GRANT ALL ON TABLE "public"."linkedin_imports" TO "authenticated";
GRANT ALL ON TABLE "public"."linkedin_imports" TO "service_role";



GRANT ALL ON SEQUENCE "public"."linkedin_imports_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."linkedin_imports_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."linkedin_imports_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."linkedin_project_connections" TO "anon";
GRANT ALL ON TABLE "public"."linkedin_project_connections" TO "authenticated";
GRANT ALL ON TABLE "public"."linkedin_project_connections" TO "service_role";



GRANT ALL ON TABLE "public"."locations" TO "anon";
GRANT ALL ON TABLE "public"."locations" TO "authenticated";
GRANT ALL ON TABLE "public"."locations" TO "service_role";



GRANT ALL ON TABLE "public"."media_assets" TO "anon";
GRANT ALL ON TABLE "public"."media_assets" TO "authenticated";
GRANT ALL ON TABLE "public"."media_assets" TO "service_role";



GRANT ALL ON TABLE "public"."media_collections" TO "anon";
GRANT ALL ON TABLE "public"."media_collections" TO "authenticated";
GRANT ALL ON TABLE "public"."media_collections" TO "service_role";



GRANT ALL ON TABLE "public"."media_files" TO "anon";
GRANT ALL ON TABLE "public"."media_files" TO "authenticated";
GRANT ALL ON TABLE "public"."media_files" TO "service_role";



GRANT ALL ON TABLE "public"."media_item" TO "anon";
GRANT ALL ON TABLE "public"."media_item" TO "authenticated";
GRANT ALL ON TABLE "public"."media_item" TO "service_role";



GRANT ALL ON TABLE "public"."media_items" TO "anon";
GRANT ALL ON TABLE "public"."media_items" TO "authenticated";
GRANT ALL ON TABLE "public"."media_items" TO "service_role";



GRANT ALL ON TABLE "public"."media_library" TO "anon";
GRANT ALL ON TABLE "public"."media_library" TO "authenticated";
GRANT ALL ON TABLE "public"."media_library" TO "service_role";



GRANT ALL ON TABLE "public"."media_processing_jobs" TO "anon";
GRANT ALL ON TABLE "public"."media_processing_jobs" TO "authenticated";
GRANT ALL ON TABLE "public"."media_processing_jobs" TO "service_role";



GRANT ALL ON TABLE "public"."media_usage" TO "anon";
GRANT ALL ON TABLE "public"."media_usage" TO "authenticated";
GRANT ALL ON TABLE "public"."media_usage" TO "service_role";



GRANT ALL ON TABLE "public"."messages" TO "anon";
GRANT ALL ON TABLE "public"."messages" TO "authenticated";
GRANT ALL ON TABLE "public"."messages" TO "service_role";



GRANT ALL ON TABLE "public"."metrics" TO "anon";
GRANT ALL ON TABLE "public"."metrics" TO "authenticated";
GRANT ALL ON TABLE "public"."metrics" TO "service_role";



GRANT ALL ON TABLE "public"."migration_email_templates" TO "anon";
GRANT ALL ON TABLE "public"."migration_email_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."migration_email_templates" TO "service_role";



GRANT ALL ON TABLE "public"."migration_progress" TO "anon";
GRANT ALL ON TABLE "public"."migration_progress" TO "authenticated";
GRANT ALL ON TABLE "public"."migration_progress" TO "service_role";



GRANT ALL ON TABLE "public"."migration_rate_limits" TO "anon";
GRANT ALL ON TABLE "public"."migration_rate_limits" TO "authenticated";
GRANT ALL ON TABLE "public"."migration_rate_limits" TO "service_role";



GRANT ALL ON TABLE "public"."missing_receipts" TO "anon";
GRANT ALL ON TABLE "public"."missing_receipts" TO "authenticated";
GRANT ALL ON TABLE "public"."missing_receipts" TO "service_role";



GRANT ALL ON TABLE "public"."xero_bank_transactions" TO "anon";
GRANT ALL ON TABLE "public"."xero_bank_transactions" TO "authenticated";
GRANT ALL ON TABLE "public"."xero_bank_transactions" TO "service_role";



GRANT ALL ON TABLE "public"."missing_subscriptions" TO "anon";
GRANT ALL ON TABLE "public"."missing_subscriptions" TO "authenticated";
GRANT ALL ON TABLE "public"."missing_subscriptions" TO "service_role";



GRANT ALL ON TABLE "public"."newsletter_subscribers" TO "anon";
GRANT ALL ON TABLE "public"."newsletter_subscribers" TO "authenticated";
GRANT ALL ON TABLE "public"."newsletter_subscribers" TO "service_role";



GRANT ALL ON TABLE "public"."newsletter_subscriptions" TO "anon";
GRANT ALL ON TABLE "public"."newsletter_subscriptions" TO "authenticated";
GRANT ALL ON TABLE "public"."newsletter_subscriptions" TO "service_role";



GRANT ALL ON TABLE "public"."normalized_documents" TO "anon";
GRANT ALL ON TABLE "public"."normalized_documents" TO "authenticated";
GRANT ALL ON TABLE "public"."normalized_documents" TO "service_role";



GRANT ALL ON TABLE "public"."normalized_stories" TO "anon";
GRANT ALL ON TABLE "public"."normalized_stories" TO "authenticated";
GRANT ALL ON TABLE "public"."normalized_stories" TO "service_role";



GRANT ALL ON TABLE "public"."normalized_storytellers" TO "anon";
GRANT ALL ON TABLE "public"."normalized_storytellers" TO "authenticated";
GRANT ALL ON TABLE "public"."normalized_storytellers" TO "service_role";



GRANT ALL ON TABLE "public"."wiki_notifications" TO "anon";
GRANT ALL ON TABLE "public"."wiki_notifications" TO "authenticated";
GRANT ALL ON TABLE "public"."wiki_notifications" TO "service_role";



GRANT ALL ON TABLE "public"."notification_summary" TO "anon";
GRANT ALL ON TABLE "public"."notification_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."notification_summary" TO "service_role";



GRANT ALL ON TABLE "public"."notion_opportunities" TO "anon";
GRANT ALL ON TABLE "public"."notion_opportunities" TO "authenticated";
GRANT ALL ON TABLE "public"."notion_opportunities" TO "service_role";



GRANT ALL ON TABLE "public"."notion_organization_people" TO "anon";
GRANT ALL ON TABLE "public"."notion_organization_people" TO "authenticated";
GRANT ALL ON TABLE "public"."notion_organization_people" TO "service_role";



GRANT ALL ON TABLE "public"."notion_organizations" TO "anon";
GRANT ALL ON TABLE "public"."notion_organizations" TO "authenticated";
GRANT ALL ON TABLE "public"."notion_organizations" TO "service_role";



GRANT ALL ON TABLE "public"."notion_people" TO "anon";
GRANT ALL ON TABLE "public"."notion_people" TO "authenticated";
GRANT ALL ON TABLE "public"."notion_people" TO "service_role";



GRANT ALL ON TABLE "public"."notion_project_organizations" TO "anon";
GRANT ALL ON TABLE "public"."notion_project_organizations" TO "authenticated";
GRANT ALL ON TABLE "public"."notion_project_organizations" TO "service_role";



GRANT ALL ON TABLE "public"."notion_project_people" TO "anon";
GRANT ALL ON TABLE "public"."notion_project_people" TO "authenticated";
GRANT ALL ON TABLE "public"."notion_project_people" TO "service_role";



GRANT ALL ON TABLE "public"."notion_projects" TO "anon";
GRANT ALL ON TABLE "public"."notion_projects" TO "authenticated";
GRANT ALL ON TABLE "public"."notion_projects" TO "service_role";



GRANT ALL ON TABLE "public"."notion_projects_cache" TO "anon";
GRANT ALL ON TABLE "public"."notion_projects_cache" TO "authenticated";
GRANT ALL ON TABLE "public"."notion_projects_cache" TO "service_role";



GRANT ALL ON TABLE "public"."opportunities" TO "anon";
GRANT ALL ON TABLE "public"."opportunities" TO "authenticated";
GRANT ALL ON TABLE "public"."opportunities" TO "service_role";



GRANT ALL ON SEQUENCE "public"."opportunities_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."opportunities_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."opportunities_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."organization_connections" TO "anon";
GRANT ALL ON TABLE "public"."organization_connections" TO "authenticated";
GRANT ALL ON TABLE "public"."organization_connections" TO "service_role";



GRANT ALL ON TABLE "public"."organization_enrichment" TO "anon";
GRANT ALL ON TABLE "public"."organization_enrichment" TO "authenticated";
GRANT ALL ON TABLE "public"."organization_enrichment" TO "service_role";



GRANT ALL ON TABLE "public"."organization_members" TO "anon";
GRANT ALL ON TABLE "public"."organization_members" TO "authenticated";
GRANT ALL ON TABLE "public"."organization_members" TO "service_role";



GRANT ALL ON TABLE "public"."organization_sync_log" TO "anon";
GRANT ALL ON TABLE "public"."organization_sync_log" TO "authenticated";
GRANT ALL ON TABLE "public"."organization_sync_log" TO "service_role";



GRANT ALL ON TABLE "public"."organizations" TO "anon";
GRANT ALL ON TABLE "public"."organizations" TO "authenticated";
GRANT ALL ON TABLE "public"."organizations" TO "service_role";



GRANT ALL ON TABLE "public"."organizations_profiles" TO "anon";
GRANT ALL ON TABLE "public"."organizations_profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."organizations_profiles" TO "service_role";



GRANT ALL ON TABLE "public"."outreach_strategies" TO "anon";
GRANT ALL ON TABLE "public"."outreach_strategies" TO "authenticated";
GRANT ALL ON TABLE "public"."outreach_strategies" TO "service_role";



GRANT ALL ON TABLE "public"."outreach_tasks" TO "anon";
GRANT ALL ON TABLE "public"."outreach_tasks" TO "authenticated";
GRANT ALL ON TABLE "public"."outreach_tasks" TO "service_role";



GRANT ALL ON TABLE "public"."subscription_receipts" TO "anon";
GRANT ALL ON TABLE "public"."subscription_receipts" TO "authenticated";
GRANT ALL ON TABLE "public"."subscription_receipts" TO "service_role";



GRANT ALL ON TABLE "public"."outstanding_invoices" TO "anon";
GRANT ALL ON TABLE "public"."outstanding_invoices" TO "authenticated";
GRANT ALL ON TABLE "public"."outstanding_invoices" TO "service_role";



GRANT ALL ON TABLE "public"."pages" TO "anon";
GRANT ALL ON TABLE "public"."pages" TO "authenticated";
GRANT ALL ON TABLE "public"."pages" TO "service_role";



GRANT ALL ON TABLE "public"."partner_contacts" TO "anon";
GRANT ALL ON TABLE "public"."partner_contacts" TO "authenticated";
GRANT ALL ON TABLE "public"."partner_contacts" TO "service_role";



GRANT ALL ON TABLE "public"."partner_external_links" TO "anon";
GRANT ALL ON TABLE "public"."partner_external_links" TO "authenticated";
GRANT ALL ON TABLE "public"."partner_external_links" TO "service_role";



GRANT ALL ON TABLE "public"."partner_goals" TO "anon";
GRANT ALL ON TABLE "public"."partner_goals" TO "authenticated";
GRANT ALL ON TABLE "public"."partner_goals" TO "service_role";



GRANT ALL ON TABLE "public"."partner_impact_metrics" TO "anon";
GRANT ALL ON TABLE "public"."partner_impact_metrics" TO "authenticated";
GRANT ALL ON TABLE "public"."partner_impact_metrics" TO "service_role";



GRANT ALL ON TABLE "public"."partner_photos" TO "anon";
GRANT ALL ON TABLE "public"."partner_photos" TO "authenticated";
GRANT ALL ON TABLE "public"."partner_photos" TO "service_role";



GRANT ALL ON TABLE "public"."partner_site_locations" TO "anon";
GRANT ALL ON TABLE "public"."partner_site_locations" TO "authenticated";
GRANT ALL ON TABLE "public"."partner_site_locations" TO "service_role";



GRANT ALL ON TABLE "public"."partner_stories" TO "anon";
GRANT ALL ON TABLE "public"."partner_stories" TO "authenticated";
GRANT ALL ON TABLE "public"."partner_stories" TO "service_role";



GRANT ALL ON TABLE "public"."partner_storytellers" TO "anon";
GRANT ALL ON TABLE "public"."partner_storytellers" TO "authenticated";
GRANT ALL ON TABLE "public"."partner_storytellers" TO "service_role";



GRANT ALL ON TABLE "public"."partner_storytellers_v" TO "anon";
GRANT ALL ON TABLE "public"."partner_storytellers_v" TO "authenticated";
GRANT ALL ON TABLE "public"."partner_storytellers_v" TO "service_role";



GRANT ALL ON TABLE "public"."partner_videos" TO "anon";
GRANT ALL ON TABLE "public"."partner_videos" TO "authenticated";
GRANT ALL ON TABLE "public"."partner_videos" TO "service_role";



GRANT ALL ON TABLE "public"."partners" TO "anon";
GRANT ALL ON TABLE "public"."partners" TO "authenticated";
GRANT ALL ON TABLE "public"."partners" TO "service_role";



GRANT ALL ON TABLE "public"."pending_contacts" TO "anon";
GRANT ALL ON TABLE "public"."pending_contacts" TO "authenticated";
GRANT ALL ON TABLE "public"."pending_contacts" TO "service_role";



GRANT ALL ON TABLE "public"."pending_elder_reviews" TO "anon";
GRANT ALL ON TABLE "public"."pending_elder_reviews" TO "authenticated";
GRANT ALL ON TABLE "public"."pending_elder_reviews" TO "service_role";



GRANT ALL ON TABLE "public"."pending_extractions" TO "anon";
GRANT ALL ON TABLE "public"."pending_extractions" TO "authenticated";
GRANT ALL ON TABLE "public"."pending_extractions" TO "service_role";



GRANT ALL ON TABLE "public"."pending_proposals" TO "anon";
GRANT ALL ON TABLE "public"."pending_proposals" TO "authenticated";
GRANT ALL ON TABLE "public"."pending_proposals" TO "service_role";



GRANT ALL ON TABLE "public"."person_identity_map" TO "anon";
GRANT ALL ON TABLE "public"."person_identity_map" TO "authenticated";
GRANT ALL ON TABLE "public"."person_identity_map" TO "service_role";



GRANT ALL ON TABLE "public"."photo_album_photos" TO "anon";
GRANT ALL ON TABLE "public"."photo_album_photos" TO "authenticated";
GRANT ALL ON TABLE "public"."photo_album_photos" TO "service_role";



GRANT ALL ON TABLE "public"."photo_album_shares" TO "anon";
GRANT ALL ON TABLE "public"."photo_album_shares" TO "authenticated";
GRANT ALL ON TABLE "public"."photo_album_shares" TO "service_role";



GRANT ALL ON TABLE "public"."photo_albums" TO "anon";
GRANT ALL ON TABLE "public"."photo_albums" TO "authenticated";
GRANT ALL ON TABLE "public"."photo_albums" TO "service_role";



GRANT ALL ON TABLE "public"."photo_storyteller_tags" TO "anon";
GRANT ALL ON TABLE "public"."photo_storyteller_tags" TO "authenticated";
GRANT ALL ON TABLE "public"."photo_storyteller_tags" TO "service_role";



GRANT ALL ON TABLE "public"."photos" TO "anon";
GRANT ALL ON TABLE "public"."photos" TO "authenticated";
GRANT ALL ON TABLE "public"."photos" TO "service_role";



GRANT ALL ON TABLE "public"."platform_collection_media" TO "anon";
GRANT ALL ON TABLE "public"."platform_collection_media" TO "authenticated";
GRANT ALL ON TABLE "public"."platform_collection_media" TO "service_role";



GRANT ALL ON TABLE "public"."platform_media_collections" TO "anon";
GRANT ALL ON TABLE "public"."platform_media_collections" TO "authenticated";
GRANT ALL ON TABLE "public"."platform_media_collections" TO "service_role";



GRANT ALL ON TABLE "public"."platform_media_items" TO "anon";
GRANT ALL ON TABLE "public"."platform_media_items" TO "authenticated";
GRANT ALL ON TABLE "public"."platform_media_items" TO "service_role";



GRANT ALL ON TABLE "public"."platform_media_processing_jobs" TO "anon";
GRANT ALL ON TABLE "public"."platform_media_processing_jobs" TO "authenticated";
GRANT ALL ON TABLE "public"."platform_media_processing_jobs" TO "service_role";



GRANT ALL ON TABLE "public"."platform_media_usage" TO "anon";
GRANT ALL ON TABLE "public"."platform_media_usage" TO "authenticated";
GRANT ALL ON TABLE "public"."platform_media_usage" TO "service_role";



GRANT ALL ON TABLE "public"."platform_organizations" TO "anon";
GRANT ALL ON TABLE "public"."platform_organizations" TO "authenticated";
GRANT ALL ON TABLE "public"."platform_organizations" TO "service_role";



GRANT ALL ON TABLE "public"."platform_organization_stats" TO "anon";
GRANT ALL ON TABLE "public"."platform_organization_stats" TO "authenticated";
GRANT ALL ON TABLE "public"."platform_organization_stats" TO "service_role";



GRANT ALL ON TABLE "public"."platform_public_media_with_collections" TO "anon";
GRANT ALL ON TABLE "public"."platform_public_media_with_collections" TO "authenticated";
GRANT ALL ON TABLE "public"."platform_public_media_with_collections" TO "service_role";



GRANT ALL ON TABLE "public"."portraits" TO "anon";
GRANT ALL ON TABLE "public"."portraits" TO "authenticated";
GRANT ALL ON TABLE "public"."portraits" TO "service_role";



GRANT ALL ON TABLE "public"."privacy_audit_log" TO "anon";
GRANT ALL ON TABLE "public"."privacy_audit_log" TO "authenticated";
GRANT ALL ON TABLE "public"."privacy_audit_log" TO "service_role";



GRANT ALL ON SEQUENCE "public"."privacy_audit_log_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."privacy_audit_log_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."privacy_audit_log_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."privacy_dsr_requests" TO "anon";
GRANT ALL ON TABLE "public"."privacy_dsr_requests" TO "authenticated";
GRANT ALL ON TABLE "public"."privacy_dsr_requests" TO "service_role";



GRANT ALL ON SEQUENCE "public"."privacy_dsr_requests_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."privacy_dsr_requests_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."privacy_dsr_requests_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."privacy_settings" TO "anon";
GRANT ALL ON TABLE "public"."privacy_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."privacy_settings" TO "service_role";



GRANT ALL ON TABLE "public"."processing_jobs" TO "anon";
GRANT ALL ON TABLE "public"."processing_jobs" TO "authenticated";
GRANT ALL ON TABLE "public"."processing_jobs" TO "service_role";



GRANT ALL ON TABLE "public"."profile_appearances" TO "anon";
GRANT ALL ON TABLE "public"."profile_appearances" TO "authenticated";
GRANT ALL ON TABLE "public"."profile_appearances" TO "service_role";



GRANT ALL ON TABLE "public"."profile_sync_log" TO "anon";
GRANT ALL ON TABLE "public"."profile_sync_log" TO "authenticated";
GRANT ALL ON TABLE "public"."profile_sync_log" TO "service_role";



GRANT ALL ON TABLE "public"."profiles" TO "anon";
GRANT ALL ON TABLE "public"."profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."profiles" TO "service_role";



GRANT ALL ON TABLE "public"."program_outcomes" TO "anon";
GRANT ALL ON TABLE "public"."program_outcomes" TO "authenticated";
GRANT ALL ON TABLE "public"."program_outcomes" TO "service_role";



GRANT ALL ON TABLE "public"."program_visits" TO "anon";
GRANT ALL ON TABLE "public"."program_visits" TO "authenticated";
GRANT ALL ON TABLE "public"."program_visits" TO "service_role";



GRANT ALL ON TABLE "public"."project_activity_summary" TO "anon";
GRANT ALL ON TABLE "public"."project_activity_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."project_activity_summary" TO "service_role";



GRANT ALL ON TABLE "public"."project_contact_alignment" TO "anon";
GRANT ALL ON TABLE "public"."project_contact_alignment" TO "authenticated";
GRANT ALL ON TABLE "public"."project_contact_alignment" TO "service_role";



GRANT ALL ON TABLE "public"."project_contact_matches" TO "anon";
GRANT ALL ON TABLE "public"."project_contact_matches" TO "authenticated";
GRANT ALL ON TABLE "public"."project_contact_matches" TO "service_role";



GRANT ALL ON TABLE "public"."project_contributions" TO "anon";
GRANT ALL ON TABLE "public"."project_contributions" TO "authenticated";
GRANT ALL ON TABLE "public"."project_contributions" TO "service_role";



GRANT ALL ON TABLE "public"."project_health" TO "anon";
GRANT ALL ON TABLE "public"."project_health" TO "authenticated";
GRANT ALL ON TABLE "public"."project_health" TO "service_role";



GRANT ALL ON TABLE "public"."project_health_analysis" TO "anon";
GRANT ALL ON TABLE "public"."project_health_analysis" TO "authenticated";
GRANT ALL ON TABLE "public"."project_health_analysis" TO "service_role";



GRANT ALL ON TABLE "public"."project_health_history" TO "anon";
GRANT ALL ON TABLE "public"."project_health_history" TO "authenticated";
GRANT ALL ON TABLE "public"."project_health_history" TO "service_role";



GRANT ALL ON TABLE "public"."project_outcomes" TO "anon";
GRANT ALL ON TABLE "public"."project_outcomes" TO "authenticated";
GRANT ALL ON TABLE "public"."project_outcomes" TO "service_role";



GRANT ALL ON TABLE "public"."projects" TO "anon";
GRANT ALL ON TABLE "public"."projects" TO "authenticated";
GRANT ALL ON TABLE "public"."projects" TO "service_role";



GRANT ALL ON TABLE "public"."project_impact_summary" TO "anon";
GRANT ALL ON TABLE "public"."project_impact_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."project_impact_summary" TO "service_role";



GRANT ALL ON TABLE "public"."project_intelligence" TO "anon";
GRANT ALL ON TABLE "public"."project_intelligence" TO "authenticated";
GRANT ALL ON TABLE "public"."project_intelligence" TO "service_role";



GRANT ALL ON TABLE "public"."project_knowledge" TO "anon";
GRANT ALL ON TABLE "public"."project_knowledge" TO "authenticated";
GRANT ALL ON TABLE "public"."project_knowledge" TO "service_role";



GRANT ALL ON TABLE "public"."project_media_links" TO "anon";
GRANT ALL ON TABLE "public"."project_media_links" TO "authenticated";
GRANT ALL ON TABLE "public"."project_media_links" TO "service_role";



GRANT ALL ON TABLE "public"."project_outcome_updates" TO "anon";
GRANT ALL ON TABLE "public"."project_outcome_updates" TO "authenticated";
GRANT ALL ON TABLE "public"."project_outcome_updates" TO "service_role";



GRANT ALL ON TABLE "public"."project_pairings" TO "anon";
GRANT ALL ON TABLE "public"."project_pairings" TO "authenticated";
GRANT ALL ON TABLE "public"."project_pairings" TO "service_role";



GRANT ALL ON TABLE "public"."project_research" TO "anon";
GRANT ALL ON TABLE "public"."project_research" TO "authenticated";
GRANT ALL ON TABLE "public"."project_research" TO "service_role";



GRANT ALL ON TABLE "public"."project_support_graph" TO "anon";
GRANT ALL ON TABLE "public"."project_support_graph" TO "authenticated";
GRANT ALL ON TABLE "public"."project_support_graph" TO "service_role";



GRANT ALL ON TABLE "public"."project_support_overview" TO "anon";
GRANT ALL ON TABLE "public"."project_support_overview" TO "authenticated";
GRANT ALL ON TABLE "public"."project_support_overview" TO "service_role";



GRANT ALL ON TABLE "public"."project_updates" TO "anon";
GRANT ALL ON TABLE "public"."project_updates" TO "authenticated";
GRANT ALL ON TABLE "public"."project_updates" TO "service_role";



GRANT ALL ON TABLE "public"."public_media_with_collections" TO "anon";
GRANT ALL ON TABLE "public"."public_media_with_collections" TO "authenticated";
GRANT ALL ON TABLE "public"."public_media_with_collections" TO "service_role";



GRANT ALL ON TABLE "public"."public_profiles" TO "anon";
GRANT ALL ON TABLE "public"."public_profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."public_profiles" TO "service_role";



GRANT ALL ON TABLE "public"."pulse_events" TO "anon";
GRANT ALL ON TABLE "public"."pulse_events" TO "authenticated";
GRANT ALL ON TABLE "public"."pulse_events" TO "service_role";



GRANT ALL ON TABLE "public"."push_subscriptions" TO "anon";
GRANT ALL ON TABLE "public"."push_subscriptions" TO "authenticated";
GRANT ALL ON TABLE "public"."push_subscriptions" TO "service_role";



GRANT ALL ON TABLE "public"."quotes" TO "anon";
GRANT ALL ON TABLE "public"."quotes" TO "authenticated";
GRANT ALL ON TABLE "public"."quotes" TO "service_role";



GRANT ALL ON TABLE "public"."rd_activity_log" TO "anon";
GRANT ALL ON TABLE "public"."rd_activity_log" TO "authenticated";
GRANT ALL ON TABLE "public"."rd_activity_log" TO "service_role";



GRANT ALL ON TABLE "public"."receipt_match_history" TO "anon";
GRANT ALL ON TABLE "public"."receipt_match_history" TO "authenticated";
GRANT ALL ON TABLE "public"."receipt_match_history" TO "service_role";



GRANT ALL ON TABLE "public"."receipt_matches" TO "anon";
GRANT ALL ON TABLE "public"."receipt_matches" TO "authenticated";
GRANT ALL ON TABLE "public"."receipt_matches" TO "service_role";



GRANT ALL ON TABLE "public"."receipt_reconciliation_weeks" TO "anon";
GRANT ALL ON TABLE "public"."receipt_reconciliation_weeks" TO "authenticated";
GRANT ALL ON TABLE "public"."receipt_reconciliation_weeks" TO "service_role";



GRANT ALL ON TABLE "public"."receipt_weekly_summary" TO "anon";
GRANT ALL ON TABLE "public"."receipt_weekly_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."receipt_weekly_summary" TO "service_role";



GRANT ALL ON TABLE "public"."recent_agent_activity" TO "anon";
GRANT ALL ON TABLE "public"."recent_agent_activity" TO "authenticated";
GRANT ALL ON TABLE "public"."recent_agent_activity" TO "service_role";



GRANT ALL ON TABLE "public"."recommendation_outcomes" TO "anon";
GRANT ALL ON TABLE "public"."recommendation_outcomes" TO "authenticated";
GRANT ALL ON TABLE "public"."recommendation_outcomes" TO "service_role";



GRANT ALL ON TABLE "public"."relationship_health" TO "anon";
GRANT ALL ON TABLE "public"."relationship_health" TO "authenticated";
GRANT ALL ON TABLE "public"."relationship_health" TO "service_role";



GRANT ALL ON TABLE "public"."research_items" TO "anon";
GRANT ALL ON TABLE "public"."research_items" TO "authenticated";
GRANT ALL ON TABLE "public"."research_items" TO "service_role";



GRANT ALL ON TABLE "public"."review_curated_entries" TO "anon";
GRANT ALL ON TABLE "public"."review_curated_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."review_curated_entries" TO "service_role";



GRANT ALL ON TABLE "public"."review_media_links" TO "anon";
GRANT ALL ON TABLE "public"."review_media_links" TO "authenticated";
GRANT ALL ON TABLE "public"."review_media_links" TO "service_role";



GRANT ALL ON TABLE "public"."review_projects" TO "anon";
GRANT ALL ON TABLE "public"."review_projects" TO "authenticated";
GRANT ALL ON TABLE "public"."review_projects" TO "service_role";



GRANT ALL ON TABLE "public"."review_videos" TO "anon";
GRANT ALL ON TABLE "public"."review_videos" TO "authenticated";
GRANT ALL ON TABLE "public"."review_videos" TO "service_role";



GRANT ALL ON TABLE "public"."review_year_settings" TO "anon";
GRANT ALL ON TABLE "public"."review_year_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."review_year_settings" TO "service_role";



GRANT ALL ON TABLE "public"."role_taxonomy" TO "anon";
GRANT ALL ON TABLE "public"."role_taxonomy" TO "authenticated";
GRANT ALL ON TABLE "public"."role_taxonomy" TO "service_role";



GRANT ALL ON TABLE "public"."scraped_services" TO "anon";
GRANT ALL ON TABLE "public"."scraped_services" TO "authenticated";
GRANT ALL ON TABLE "public"."scraped_services" TO "service_role";



GRANT ALL ON TABLE "public"."scraping_metadata" TO "anon";
GRANT ALL ON TABLE "public"."scraping_metadata" TO "authenticated";
GRANT ALL ON TABLE "public"."scraping_metadata" TO "service_role";



GRANT ALL ON TABLE "public"."search_history" TO "anon";
GRANT ALL ON TABLE "public"."search_history" TO "authenticated";
GRANT ALL ON TABLE "public"."search_history" TO "service_role";



GRANT ALL ON TABLE "public"."service_contacts" TO "anon";
GRANT ALL ON TABLE "public"."service_contacts" TO "authenticated";
GRANT ALL ON TABLE "public"."service_contacts" TO "service_role";



GRANT ALL ON TABLE "public"."service_locations" TO "anon";
GRANT ALL ON TABLE "public"."service_locations" TO "authenticated";
GRANT ALL ON TABLE "public"."service_locations" TO "service_role";



GRANT ALL ON TABLE "public"."services" TO "anon";
GRANT ALL ON TABLE "public"."services" TO "authenticated";
GRANT ALL ON TABLE "public"."services" TO "service_role";



GRANT ALL ON TABLE "public"."services_complete" TO "anon";
GRANT ALL ON TABLE "public"."services_complete" TO "authenticated";
GRANT ALL ON TABLE "public"."services_complete" TO "service_role";



GRANT ALL ON TABLE "public"."services_profiles" TO "anon";
GRANT ALL ON TABLE "public"."services_profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."services_profiles" TO "service_role";



GRANT ALL ON TABLE "public"."services_unified" TO "anon";
GRANT ALL ON TABLE "public"."services_unified" TO "authenticated";
GRANT ALL ON TABLE "public"."services_unified" TO "service_role";



GRANT ALL ON TABLE "public"."site_deployments" TO "anon";
GRANT ALL ON TABLE "public"."site_deployments" TO "authenticated";
GRANT ALL ON TABLE "public"."site_deployments" TO "service_role";



GRANT ALL ON TABLE "public"."site_health_checks" TO "anon";
GRANT ALL ON TABLE "public"."site_health_checks" TO "authenticated";
GRANT ALL ON TABLE "public"."site_health_checks" TO "service_role";



GRANT ALL ON TABLE "public"."site_latest_health" TO "anon";
GRANT ALL ON TABLE "public"."site_latest_health" TO "authenticated";
GRANT ALL ON TABLE "public"."site_latest_health" TO "service_role";



GRANT ALL ON TABLE "public"."skills_evidence" TO "anon";
GRANT ALL ON TABLE "public"."skills_evidence" TO "authenticated";
GRANT ALL ON TABLE "public"."skills_evidence" TO "service_role";



GRANT ALL ON TABLE "public"."sprint_snapshots" TO "anon";
GRANT ALL ON TABLE "public"."sprint_snapshots" TO "authenticated";
GRANT ALL ON TABLE "public"."sprint_snapshots" TO "service_role";



GRANT ALL ON TABLE "public"."stories" TO "anon";
GRANT ALL ON TABLE "public"."stories" TO "authenticated";
GRANT ALL ON TABLE "public"."stories" TO "service_role";



GRANT ALL ON TABLE "public"."story_analysis" TO "anon";
GRANT ALL ON TABLE "public"."story_analysis" TO "authenticated";
GRANT ALL ON TABLE "public"."story_analysis" TO "service_role";



GRANT ALL ON TABLE "public"."story_attribution_events" TO "anon";
GRANT ALL ON TABLE "public"."story_attribution_events" TO "authenticated";
GRANT ALL ON TABLE "public"."story_attribution_events" TO "service_role";



GRANT ALL ON TABLE "public"."story_comments" TO "anon";
GRANT ALL ON TABLE "public"."story_comments" TO "authenticated";
GRANT ALL ON TABLE "public"."story_comments" TO "service_role";



GRANT ALL ON TABLE "public"."story_reactions" TO "anon";
GRANT ALL ON TABLE "public"."story_reactions" TO "authenticated";
GRANT ALL ON TABLE "public"."story_reactions" TO "service_role";



GRANT ALL ON TABLE "public"."story_related_art" TO "anon";
GRANT ALL ON TABLE "public"."story_related_art" TO "authenticated";
GRANT ALL ON TABLE "public"."story_related_art" TO "service_role";



GRANT ALL ON TABLE "public"."story_related_interventions" TO "anon";
GRANT ALL ON TABLE "public"."story_related_interventions" TO "authenticated";
GRANT ALL ON TABLE "public"."story_related_interventions" TO "service_role";



GRANT ALL ON TABLE "public"."story_related_programs" TO "anon";
GRANT ALL ON TABLE "public"."story_related_programs" TO "authenticated";
GRANT ALL ON TABLE "public"."story_related_programs" TO "service_role";



GRANT ALL ON TABLE "public"."story_related_services" TO "anon";
GRANT ALL ON TABLE "public"."story_related_services" TO "authenticated";
GRANT ALL ON TABLE "public"."story_related_services" TO "service_role";



GRANT ALL ON TABLE "public"."storyteller_ai_intelligence" TO "anon";
GRANT ALL ON TABLE "public"."storyteller_ai_intelligence" TO "authenticated";
GRANT ALL ON TABLE "public"."storyteller_ai_intelligence" TO "service_role";



GRANT ALL ON TABLE "public"."storyteller_connections" TO "anon";
GRANT ALL ON TABLE "public"."storyteller_connections" TO "authenticated";
GRANT ALL ON TABLE "public"."storyteller_connections" TO "service_role";



GRANT ALL ON TABLE "public"."storyteller_media" TO "anon";
GRANT ALL ON TABLE "public"."storyteller_media" TO "authenticated";
GRANT ALL ON TABLE "public"."storyteller_media" TO "service_role";



GRANT ALL ON TABLE "public"."storyteller_videos" TO "anon";
GRANT ALL ON TABLE "public"."storyteller_videos" TO "authenticated";
GRANT ALL ON TABLE "public"."storyteller_videos" TO "service_role";



GRANT ALL ON TABLE "public"."storytellers" TO "anon";
GRANT ALL ON TABLE "public"."storytellers" TO "authenticated";
GRANT ALL ON TABLE "public"."storytellers" TO "service_role";



GRANT ALL ON TABLE "public"."studio_projects" TO "anon";
GRANT ALL ON TABLE "public"."studio_projects" TO "authenticated";
GRANT ALL ON TABLE "public"."studio_projects" TO "service_role";



GRANT ALL ON TABLE "public"."subscription_analytics" TO "anon";
GRANT ALL ON TABLE "public"."subscription_analytics" TO "authenticated";
GRANT ALL ON TABLE "public"."subscription_analytics" TO "service_role";



GRANT ALL ON TABLE "public"."subscription_cost_anomalies" TO "anon";
GRANT ALL ON TABLE "public"."subscription_cost_anomalies" TO "authenticated";
GRANT ALL ON TABLE "public"."subscription_cost_anomalies" TO "service_role";



GRANT ALL ON TABLE "public"."subscription_cost_by_account" TO "anon";
GRANT ALL ON TABLE "public"."subscription_cost_by_account" TO "authenticated";
GRANT ALL ON TABLE "public"."subscription_cost_by_account" TO "service_role";



GRANT ALL ON TABLE "public"."subscription_cost_by_category" TO "anon";
GRANT ALL ON TABLE "public"."subscription_cost_by_category" TO "authenticated";
GRANT ALL ON TABLE "public"."subscription_cost_by_category" TO "service_role";



GRANT ALL ON TABLE "public"."subscription_history" TO "anon";
GRANT ALL ON TABLE "public"."subscription_history" TO "authenticated";
GRANT ALL ON TABLE "public"."subscription_history" TO "service_role";



GRANT ALL ON TABLE "public"."subscription_payment_calendar" TO "anon";
GRANT ALL ON TABLE "public"."subscription_payment_calendar" TO "authenticated";
GRANT ALL ON TABLE "public"."subscription_payment_calendar" TO "service_role";



GRANT ALL ON TABLE "public"."subscription_renewal_alerts" TO "anon";
GRANT ALL ON TABLE "public"."subscription_renewal_alerts" TO "authenticated";
GRANT ALL ON TABLE "public"."subscription_renewal_alerts" TO "service_role";



GRANT ALL ON TABLE "public"."subscriptions" TO "anon";
GRANT ALL ON TABLE "public"."subscriptions" TO "authenticated";
GRANT ALL ON TABLE "public"."subscriptions" TO "service_role";



GRANT ALL ON TABLE "public"."suggestion_feedback" TO "anon";
GRANT ALL ON TABLE "public"."suggestion_feedback" TO "authenticated";
GRANT ALL ON TABLE "public"."suggestion_feedback" TO "service_role";



GRANT ALL ON TABLE "public"."support_matches" TO "anon";
GRANT ALL ON TABLE "public"."support_matches" TO "authenticated";
GRANT ALL ON TABLE "public"."support_matches" TO "service_role";



GRANT ALL ON TABLE "public"."sync_events" TO "anon";
GRANT ALL ON TABLE "public"."sync_events" TO "authenticated";
GRANT ALL ON TABLE "public"."sync_events" TO "service_role";



GRANT ALL ON TABLE "public"."sync_event_statistics" TO "anon";
GRANT ALL ON TABLE "public"."sync_event_statistics" TO "authenticated";
GRANT ALL ON TABLE "public"."sync_event_statistics" TO "service_role";



GRANT ALL ON TABLE "public"."sync_queue" TO "anon";
GRANT ALL ON TABLE "public"."sync_queue" TO "authenticated";
GRANT ALL ON TABLE "public"."sync_queue" TO "service_role";



GRANT ALL ON TABLE "public"."sync_state" TO "anon";
GRANT ALL ON TABLE "public"."sync_state" TO "authenticated";
GRANT ALL ON TABLE "public"."sync_state" TO "service_role";



GRANT ALL ON TABLE "public"."tag_inference_rules" TO "anon";
GRANT ALL ON TABLE "public"."tag_inference_rules" TO "authenticated";
GRANT ALL ON TABLE "public"."tag_inference_rules" TO "service_role";



GRANT ALL ON TABLE "public"."task_queue_dashboard" TO "anon";
GRANT ALL ON TABLE "public"."task_queue_dashboard" TO "authenticated";
GRANT ALL ON TABLE "public"."task_queue_dashboard" TO "service_role";



GRANT ALL ON TABLE "public"."themes" TO "anon";
GRANT ALL ON TABLE "public"."themes" TO "authenticated";
GRANT ALL ON TABLE "public"."themes" TO "service_role";



GRANT ALL ON TABLE "public"."touchpoints" TO "anon";
GRANT ALL ON TABLE "public"."touchpoints" TO "authenticated";
GRANT ALL ON TABLE "public"."touchpoints" TO "service_role";



GRANT ALL ON TABLE "public"."training_dataset" TO "anon";
GRANT ALL ON TABLE "public"."training_dataset" TO "authenticated";
GRANT ALL ON TABLE "public"."training_dataset" TO "service_role";



GRANT ALL ON TABLE "public"."training_ready_content" TO "anon";
GRANT ALL ON TABLE "public"."training_ready_content" TO "authenticated";
GRANT ALL ON TABLE "public"."training_ready_content" TO "service_role";



GRANT ALL ON TABLE "public"."transcript_analysis" TO "anon";
GRANT ALL ON TABLE "public"."transcript_analysis" TO "authenticated";
GRANT ALL ON TABLE "public"."transcript_analysis" TO "service_role";



GRANT ALL ON TABLE "public"."transcript_usage" TO "anon";
GRANT ALL ON TABLE "public"."transcript_usage" TO "authenticated";
GRANT ALL ON TABLE "public"."transcript_usage" TO "service_role";



GRANT ALL ON TABLE "public"."transcripts" TO "anon";
GRANT ALL ON TABLE "public"."transcripts" TO "authenticated";
GRANT ALL ON TABLE "public"."transcripts" TO "service_role";



GRANT ALL ON TABLE "public"."unreconciled_financial_documents" TO "anon";
GRANT ALL ON TABLE "public"."unreconciled_financial_documents" TO "authenticated";
GRANT ALL ON TABLE "public"."unreconciled_financial_documents" TO "service_role";



GRANT ALL ON TABLE "public"."unused_subscriptions" TO "anon";
GRANT ALL ON TABLE "public"."unused_subscriptions" TO "authenticated";
GRANT ALL ON TABLE "public"."unused_subscriptions" TO "service_role";



GRANT ALL ON TABLE "public"."user_behavior_insights" TO "anon";
GRANT ALL ON TABLE "public"."user_behavior_insights" TO "authenticated";
GRANT ALL ON TABLE "public"."user_behavior_insights" TO "service_role";



GRANT ALL ON TABLE "public"."user_community_engagement" TO "anon";
GRANT ALL ON TABLE "public"."user_community_engagement" TO "authenticated";
GRANT ALL ON TABLE "public"."user_community_engagement" TO "service_role";



GRANT ALL ON TABLE "public"."user_profiles" TO "anon";
GRANT ALL ON TABLE "public"."user_profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."user_profiles" TO "service_role";



GRANT ALL ON TABLE "public"."user_project_preferences" TO "anon";
GRANT ALL ON TABLE "public"."user_project_preferences" TO "authenticated";
GRANT ALL ON TABLE "public"."user_project_preferences" TO "service_role";



GRANT ALL ON TABLE "public"."user_dashboard_summary" TO "anon";
GRANT ALL ON TABLE "public"."user_dashboard_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."user_dashboard_summary" TO "service_role";



GRANT ALL ON TABLE "public"."user_gamification_stats" TO "anon";
GRANT ALL ON TABLE "public"."user_gamification_stats" TO "authenticated";
GRANT ALL ON TABLE "public"."user_gamification_stats" TO "service_role";



GRANT ALL ON TABLE "public"."user_identities" TO "anon";
GRANT ALL ON TABLE "public"."user_identities" TO "authenticated";
GRANT ALL ON TABLE "public"."user_identities" TO "service_role";



GRANT ALL ON TABLE "public"."users" TO "anon";
GRANT ALL ON TABLE "public"."users" TO "authenticated";
GRANT ALL ON TABLE "public"."users" TO "service_role";



GRANT ALL ON TABLE "public"."v_agent_activity_summary" TO "anon";
GRANT ALL ON TABLE "public"."v_agent_activity_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."v_agent_activity_summary" TO "service_role";



GRANT ALL ON TABLE "public"."v_awaiting_response" TO "anon";
GRANT ALL ON TABLE "public"."v_awaiting_response" TO "authenticated";
GRANT ALL ON TABLE "public"."v_awaiting_response" TO "service_role";



GRANT ALL ON TABLE "public"."v_cache_efficiency" TO "anon";
GRANT ALL ON TABLE "public"."v_cache_efficiency" TO "authenticated";
GRANT ALL ON TABLE "public"."v_cache_efficiency" TO "service_role";



GRANT ALL ON TABLE "public"."v_calendar_events_with_projects" TO "anon";
GRANT ALL ON TABLE "public"."v_calendar_events_with_projects" TO "authenticated";
GRANT ALL ON TABLE "public"."v_calendar_events_with_projects" TO "service_role";



GRANT ALL ON TABLE "public"."v_calibration_issues" TO "anon";
GRANT ALL ON TABLE "public"."v_calibration_issues" TO "authenticated";
GRANT ALL ON TABLE "public"."v_calibration_issues" TO "service_role";



GRANT ALL ON TABLE "public"."v_contact_communication_summary" TO "anon";
GRANT ALL ON TABLE "public"."v_contact_communication_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."v_contact_communication_summary" TO "service_role";



GRANT ALL ON TABLE "public"."v_contacts_with_protocols" TO "anon";
GRANT ALL ON TABLE "public"."v_contacts_with_protocols" TO "authenticated";
GRANT ALL ON TABLE "public"."v_contacts_with_protocols" TO "service_role";



GRANT ALL ON TABLE "public"."v_cultural_data_access" TO "anon";
GRANT ALL ON TABLE "public"."v_cultural_data_access" TO "authenticated";
GRANT ALL ON TABLE "public"."v_cultural_data_access" TO "service_role";



GRANT ALL ON TABLE "public"."v_cultural_data_summary" TO "anon";
GRANT ALL ON TABLE "public"."v_cultural_data_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."v_cultural_data_summary" TO "service_role";



GRANT ALL ON TABLE "public"."v_daily_api_costs" TO "anon";
GRANT ALL ON TABLE "public"."v_daily_api_costs" TO "authenticated";
GRANT ALL ON TABLE "public"."v_daily_api_costs" TO "service_role";



GRANT ALL ON TABLE "public"."v_decision_quality_dashboard" TO "anon";
GRANT ALL ON TABLE "public"."v_decision_quality_dashboard" TO "authenticated";
GRANT ALL ON TABLE "public"."v_decision_quality_dashboard" TO "service_role";



GRANT ALL ON TABLE "public"."v_decisions_needing_feedback" TO "anon";
GRANT ALL ON TABLE "public"."v_decisions_needing_feedback" TO "authenticated";
GRANT ALL ON TABLE "public"."v_decisions_needing_feedback" TO "service_role";



GRANT ALL ON TABLE "public"."v_donor_summary" TO "anon";
GRANT ALL ON TABLE "public"."v_donor_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."v_donor_summary" TO "service_role";



GRANT ALL ON TABLE "public"."v_duplicate_review_queue" TO "anon";
GRANT ALL ON TABLE "public"."v_duplicate_review_queue" TO "authenticated";
GRANT ALL ON TABLE "public"."v_duplicate_review_queue" TO "service_role";



GRANT ALL ON TABLE "public"."v_entity_resolution_stats" TO "anon";
GRANT ALL ON TABLE "public"."v_entity_resolution_stats" TO "authenticated";
GRANT ALL ON TABLE "public"."v_entity_resolution_stats" TO "service_role";



GRANT ALL ON TABLE "public"."youth_detention_facilities" TO "anon";
GRANT ALL ON TABLE "public"."youth_detention_facilities" TO "authenticated";
GRANT ALL ON TABLE "public"."youth_detention_facilities" TO "service_role";



GRANT ALL ON TABLE "public"."v_facilities_with_partnerships" TO "anon";
GRANT ALL ON TABLE "public"."v_facilities_with_partnerships" TO "authenticated";
GRANT ALL ON TABLE "public"."v_facilities_with_partnerships" TO "service_role";



GRANT ALL ON TABLE "public"."v_funders_summary" TO "anon";
GRANT ALL ON TABLE "public"."v_funders_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."v_funders_summary" TO "service_role";



GRANT ALL ON TABLE "public"."v_funding_pipeline" TO "anon";
GRANT ALL ON TABLE "public"."v_funding_pipeline" TO "authenticated";
GRANT ALL ON TABLE "public"."v_funding_pipeline" TO "service_role";



GRANT ALL ON TABLE "public"."v_incorrect_decisions" TO "anon";
GRANT ALL ON TABLE "public"."v_incorrect_decisions" TO "authenticated";
GRANT ALL ON TABLE "public"."v_incorrect_decisions" TO "service_role";



GRANT ALL ON TABLE "public"."v_latest_reports" TO "anon";
GRANT ALL ON TABLE "public"."v_latest_reports" TO "authenticated";
GRANT ALL ON TABLE "public"."v_latest_reports" TO "service_role";



GRANT ALL ON TABLE "public"."v_need_to_respond" TO "anon";
GRANT ALL ON TABLE "public"."v_need_to_respond" TO "authenticated";
GRANT ALL ON TABLE "public"."v_need_to_respond" TO "service_role";



GRANT ALL ON TABLE "public"."v_pending_contacts_review" TO "anon";
GRANT ALL ON TABLE "public"."v_pending_contacts_review" TO "authenticated";
GRANT ALL ON TABLE "public"."v_pending_contacts_review" TO "service_role";



GRANT ALL ON TABLE "public"."v_pending_cultural_reviews" TO "anon";
GRANT ALL ON TABLE "public"."v_pending_cultural_reviews" TO "authenticated";
GRANT ALL ON TABLE "public"."v_pending_cultural_reviews" TO "service_role";



GRANT ALL ON TABLE "public"."v_pending_receipts" TO "anon";
GRANT ALL ON TABLE "public"."v_pending_receipts" TO "authenticated";
GRANT ALL ON TABLE "public"."v_pending_receipts" TO "service_role";



GRANT ALL ON TABLE "public"."v_project_actions" TO "anon";
GRANT ALL ON TABLE "public"."v_project_actions" TO "authenticated";
GRANT ALL ON TABLE "public"."v_project_actions" TO "service_role";



GRANT ALL ON TABLE "public"."v_project_decisions" TO "anon";
GRANT ALL ON TABLE "public"."v_project_decisions" TO "authenticated";
GRANT ALL ON TABLE "public"."v_project_decisions" TO "service_role";



GRANT ALL ON TABLE "public"."v_project_health_summary" TO "anon";
GRANT ALL ON TABLE "public"."v_project_health_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."v_project_health_summary" TO "service_role";



GRANT ALL ON TABLE "public"."v_project_questions" TO "anon";
GRANT ALL ON TABLE "public"."v_project_questions" TO "authenticated";
GRANT ALL ON TABLE "public"."v_project_questions" TO "service_role";



GRANT ALL ON TABLE "public"."v_projects_needing_attention" TO "anon";
GRANT ALL ON TABLE "public"."v_projects_needing_attention" TO "authenticated";
GRANT ALL ON TABLE "public"."v_projects_needing_attention" TO "service_role";



GRANT ALL ON TABLE "public"."v_receipt_weekly_summary" TO "anon";
GRANT ALL ON TABLE "public"."v_receipt_weekly_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."v_receipt_weekly_summary" TO "service_role";



GRANT ALL ON TABLE "public"."v_recent_agent_errors" TO "anon";
GRANT ALL ON TABLE "public"."v_recent_agent_errors" TO "authenticated";
GRANT ALL ON TABLE "public"."v_recent_agent_errors" TO "service_role";



GRANT ALL ON TABLE "public"."v_recent_communications" TO "anon";
GRANT ALL ON TABLE "public"."v_recent_communications" TO "authenticated";
GRANT ALL ON TABLE "public"."v_recent_communications" TO "service_role";



GRANT ALL ON TABLE "public"."v_recent_project_knowledge" TO "anon";
GRANT ALL ON TABLE "public"."v_recent_project_knowledge" TO "authenticated";
GRANT ALL ON TABLE "public"."v_recent_project_knowledge" TO "service_role";



GRANT ALL ON TABLE "public"."v_script_api_costs" TO "anon";
GRANT ALL ON TABLE "public"."v_script_api_costs" TO "authenticated";
GRANT ALL ON TABLE "public"."v_script_api_costs" TO "service_role";



GRANT ALL ON TABLE "public"."v_state_ecosystem_summary" TO "anon";
GRANT ALL ON TABLE "public"."v_state_ecosystem_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."v_state_ecosystem_summary" TO "service_role";



GRANT ALL ON TABLE "public"."voice_notes" TO "anon";
GRANT ALL ON TABLE "public"."voice_notes" TO "authenticated";
GRANT ALL ON TABLE "public"."voice_notes" TO "service_role";



GRANT ALL ON TABLE "public"."v_team_voice_notes" TO "anon";
GRANT ALL ON TABLE "public"."v_team_voice_notes" TO "authenticated";
GRANT ALL ON TABLE "public"."v_team_voice_notes" TO "service_role";



GRANT ALL ON TABLE "public"."v_unified_contacts" TO "anon";
GRANT ALL ON TABLE "public"."v_unified_contacts" TO "authenticated";
GRANT ALL ON TABLE "public"."v_unified_contacts" TO "service_role";



GRANT ALL ON TABLE "public"."v_voice_notes_cultural_review" TO "anon";
GRANT ALL ON TABLE "public"."v_voice_notes_cultural_review" TO "authenticated";
GRANT ALL ON TABLE "public"."v_voice_notes_cultural_review" TO "service_role";



GRANT ALL ON TABLE "public"."v_voice_notes_with_actions" TO "anon";
GRANT ALL ON TABLE "public"."v_voice_notes_with_actions" TO "authenticated";
GRANT ALL ON TABLE "public"."v_voice_notes_with_actions" TO "service_role";



GRANT ALL ON TABLE "public"."volunteer_hours" TO "anon";
GRANT ALL ON TABLE "public"."volunteer_hours" TO "authenticated";
GRANT ALL ON TABLE "public"."volunteer_hours" TO "service_role";



GRANT ALL ON TABLE "public"."v_volunteer_summary" TO "anon";
GRANT ALL ON TABLE "public"."v_volunteer_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."v_volunteer_summary" TO "service_role";



GRANT ALL ON TABLE "public"."vendor_contact_log" TO "anon";
GRANT ALL ON TABLE "public"."vendor_contact_log" TO "authenticated";
GRANT ALL ON TABLE "public"."vendor_contact_log" TO "service_role";



GRANT ALL ON TABLE "public"."video_embeds" TO "anon";
GRANT ALL ON TABLE "public"."video_embeds" TO "authenticated";
GRANT ALL ON TABLE "public"."video_embeds" TO "service_role";



GRANT ALL ON TABLE "public"."voice_note_shares" TO "anon";
GRANT ALL ON TABLE "public"."voice_note_shares" TO "authenticated";
GRANT ALL ON TABLE "public"."voice_note_shares" TO "service_role";



GRANT ALL ON TABLE "public"."volunteer_interest" TO "anon";
GRANT ALL ON TABLE "public"."volunteer_interest" TO "authenticated";
GRANT ALL ON TABLE "public"."volunteer_interest" TO "service_role";



GRANT ALL ON TABLE "public"."vw_alma_intervention_matches" TO "anon";
GRANT ALL ON TABLE "public"."vw_alma_intervention_matches" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_alma_intervention_matches" TO "service_role";



GRANT ALL ON TABLE "public"."vw_auto_mapped_contacts" TO "anon";
GRANT ALL ON TABLE "public"."vw_auto_mapped_contacts" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_auto_mapped_contacts" TO "service_role";



GRANT ALL ON TABLE "public"."vw_beautiful_obsolescence_progress" TO "anon";
GRANT ALL ON TABLE "public"."vw_beautiful_obsolescence_progress" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_beautiful_obsolescence_progress" TO "service_role";



GRANT ALL ON TABLE "public"."vw_engagement_tier_stats" TO "anon";
GRANT ALL ON TABLE "public"."vw_engagement_tier_stats" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_engagement_tier_stats" TO "service_role";



GRANT ALL ON TABLE "public"."vw_exa_queue_summary" TO "anon";
GRANT ALL ON TABLE "public"."vw_exa_queue_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_exa_queue_summary" TO "service_role";



GRANT ALL ON TABLE "public"."vw_exa_usage_summary" TO "anon";
GRANT ALL ON TABLE "public"."vw_exa_usage_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_exa_usage_summary" TO "service_role";



GRANT ALL ON TABLE "public"."vw_goods_enrichment_candidates" TO "anon";
GRANT ALL ON TABLE "public"."vw_goods_enrichment_candidates" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_goods_enrichment_candidates" TO "service_role";



GRANT ALL ON TABLE "public"."vw_high_value_project_matches" TO "anon";
GRANT ALL ON TABLE "public"."vw_high_value_project_matches" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_high_value_project_matches" TO "service_role";



GRANT ALL ON TABLE "public"."vw_justice_enrichment_candidates" TO "anon";
GRANT ALL ON TABLE "public"."vw_justice_enrichment_candidates" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_justice_enrichment_candidates" TO "service_role";



GRANT ALL ON TABLE "public"."vw_newsletter_segments" TO "anon";
GRANT ALL ON TABLE "public"."vw_newsletter_segments" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_newsletter_segments" TO "service_role";



GRANT ALL ON TABLE "public"."wiki_articles" TO "anon";
GRANT ALL ON TABLE "public"."wiki_articles" TO "authenticated";
GRANT ALL ON TABLE "public"."wiki_articles" TO "service_role";



GRANT ALL ON TABLE "public"."wiki_hierarchy" TO "anon";
GRANT ALL ON TABLE "public"."wiki_hierarchy" TO "authenticated";
GRANT ALL ON TABLE "public"."wiki_hierarchy" TO "service_role";



GRANT ALL ON TABLE "public"."wiki_page_versions" TO "anon";
GRANT ALL ON TABLE "public"."wiki_page_versions" TO "authenticated";
GRANT ALL ON TABLE "public"."wiki_page_versions" TO "service_role";



GRANT ALL ON TABLE "public"."wisdom_extracts" TO "anon";
GRANT ALL ON TABLE "public"."wisdom_extracts" TO "authenticated";
GRANT ALL ON TABLE "public"."wisdom_extracts" TO "service_role";



GRANT ALL ON TABLE "public"."wisdom_insights" TO "anon";
GRANT ALL ON TABLE "public"."wisdom_insights" TO "authenticated";
GRANT ALL ON TABLE "public"."wisdom_insights" TO "service_role";



GRANT ALL ON TABLE "public"."xero_bas_tracking" TO "anon";
GRANT ALL ON TABLE "public"."xero_bas_tracking" TO "authenticated";
GRANT ALL ON TABLE "public"."xero_bas_tracking" TO "service_role";



GRANT ALL ON TABLE "public"."xero_contacts" TO "anon";
GRANT ALL ON TABLE "public"."xero_contacts" TO "authenticated";
GRANT ALL ON TABLE "public"."xero_contacts" TO "service_role";



GRANT ALL ON TABLE "public"."xero_financial_alerts" TO "anon";
GRANT ALL ON TABLE "public"."xero_financial_alerts" TO "authenticated";
GRANT ALL ON TABLE "public"."xero_financial_alerts" TO "service_role";



GRANT ALL ON TABLE "public"."xero_invoices" TO "anon";
GRANT ALL ON TABLE "public"."xero_invoices" TO "authenticated";
GRANT ALL ON TABLE "public"."xero_invoices" TO "service_role";



GRANT ALL ON TABLE "public"."xero_financial_health" TO "anon";
GRANT ALL ON TABLE "public"."xero_financial_health" TO "authenticated";
GRANT ALL ON TABLE "public"."xero_financial_health" TO "service_role";



GRANT ALL ON TABLE "public"."xero_financial_snapshots" TO "anon";
GRANT ALL ON TABLE "public"."xero_financial_snapshots" TO "authenticated";
GRANT ALL ON TABLE "public"."xero_financial_snapshots" TO "service_role";



GRANT ALL ON TABLE "public"."xero_overdue_receivables" TO "anon";
GRANT ALL ON TABLE "public"."xero_overdue_receivables" TO "authenticated";
GRANT ALL ON TABLE "public"."xero_overdue_receivables" TO "service_role";



GRANT ALL ON TABLE "public"."xero_sync_log" TO "anon";
GRANT ALL ON TABLE "public"."xero_sync_log" TO "authenticated";
GRANT ALL ON TABLE "public"."xero_sync_log" TO "service_role";



GRANT ALL ON TABLE "public"."xero_sync_status" TO "anon";
GRANT ALL ON TABLE "public"."xero_sync_status" TO "authenticated";
GRANT ALL ON TABLE "public"."xero_sync_status" TO "service_role";



GRANT ALL ON TABLE "public"."xero_tokens" TO "anon";
GRANT ALL ON TABLE "public"."xero_tokens" TO "authenticated";
GRANT ALL ON TABLE "public"."xero_tokens" TO "service_role";



GRANT ALL ON TABLE "public"."xero_transactions" TO "anon";
GRANT ALL ON TABLE "public"."xero_transactions" TO "authenticated";
GRANT ALL ON TABLE "public"."xero_transactions" TO "service_role";



GRANT ALL ON TABLE "public"."xero_upcoming_payables" TO "anon";
GRANT ALL ON TABLE "public"."xero_upcoming_payables" TO "authenticated";
GRANT ALL ON TABLE "public"."xero_upcoming_payables" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";






























